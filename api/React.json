[
  {
    "id": "react-q1",
    "topic": "React",
    "mainQuestion": "Що таке React і в чому полягають його переваги?",
    "mainAnswer": "React (або React.js) — це бібліотека JavaScript з відкритим вихідним кодом для створення користувацьких інтерфейсів. Її розробила Facebook. Основна мета React — полегшити розробку швидких і масштабованих односторінкових застосунків (SPA) за допомогою компонентного підходу та Virtual DOM. \n**Переваги:** \n- **Декларативний підхід**: Спрощує створення складних UI, дозволяючи описувати, як UI має виглядати для певного стану, а React сам керує оновленнями. \n- **Компонентно-орієнтована архітектура**: Розбиття UI на незалежні, багаторазово використовувані компоненти, що полегшує розробку та супровід. \n- **Virtual DOM**: Забезпечує високу продуктивність за рахунок ефективного оновлення DOM. \n- **Односпрямований потік даних**: Спрощує налагодження та робить застосунок більш передбачуваним. \n- **Велика екосистема та спільнота**: Багато інструментів, бібліотек та активна підтримка спільноти.",
    "additionalQuestions": [
      {
        "id": "react-q1-aq1",
        "question": "Чи є React фреймворком чи бібліотекою?",
        "answer": "React позиціонується як бібліотека для створення користувацьких інтерфейсів, а не повноцінний фреймворк, оскільки він фокусується лише на рівні представлення (view layer) і не надає рішень для маршрутизації, управління станом або HTTP-запитів \"з коробки\"."
      },
      {
        "id": "react-q1-aq2",
        "question": "Що означає 'декларативний підхід' у React?",
        "answer": "Декларативний підхід означає, що ви описуєте, як має виглядати інтерфейс у певному стані, і React подбає про фактичні маніпуляції з DOM. Ви не даєте покрокові інструкції (як у імперативному підході), а лише декларуєте бажаний кінцевий результат."
      },
      {
        "id": "react-q1-aq3",
        "question": "Яка компанія розробила та підтримує React?",
        "answer": "React був розроблений та підтримується компанією Facebook (Meta Platforms)."
      }
    ]
  },
  {
    "id": "react-q2",
    "topic": "React",
    "mainQuestion": "Чи можна до вже існуючого сайту підключити лише один новий компонент на React? Як?",
    "mainAnswer": "Так, можна. React не вимагає, щоб весь сайт був побудований на ньому. Ви можете використовувати React для рендерингу окремих компонентів на вже існуючих сторінках. Для цього потрібно: \n1. Включити бібліотеки React та ReactDOM на сторінку (зазвичай через CDN або бандлер). \n2. Створити HTML-елемент (наприклад, `<div>`), який буде кореневим вузлом для вашого React-компонента. \n3. Використати метод `ReactDOM.render()` (для React 17-го і нижче) або `ReactDOM.createRoot().render()` (для React 18+), щоб вставити ваш React-компонент у цей HTML-елемент. \nЦе дозволяє поступово інтегрувати React у традиційні веб-застосунки.",
    "additionalQuestions": [
      {
        "id": "react-q2-aq1",
        "question": "Який метод використовується для рендерингу React-компонента в DOM у React 18?",
        "answer": "У React 18+ використовується `ReactDOM.createRoot(domNode).render(<MyComponent />);`."
      },
      {
        "id": "react-q2-aq2",
        "question": "Що таке \"кореневий вузол\" (root node) для React компонента?",
        "answer": "Кореневий вузол — це існуючий HTML-елемент на сторінці, до якого React буде 'прикріплювати' ваш компонент. Всі React-компоненти, які ви рендерите, будуть знаходитися всередині цього кореневого вузла."
      },
      {
        "id": "react-q2-aq3",
        "question": "Які можуть бути потенційні проблеми при інтеграції React в існуючий сайт?",
        "answer": "Можуть виникнути проблеми з конфліктами глобальних змінних, стилів (CSS), або якщо інший скрипт на сторінці змінює ту саму частину DOM, якою керує React. Також можуть бути складнощі з передачею даних між React-компонентами та існуючим кодом."
      }
    ]
  },
  {
    "id": "react-q3",
    "topic": "React",
    "mainQuestion": "Що таке JSX? Який у нього синтаксис?",
    "mainAnswer": "JSX (JavaScript XML) — це розширення синтаксису JavaScript, яке дозволяє писати HTML-подібний код безпосередньо в JavaScript. Він виглядає як HTML, але є синтаксичним цукром для викликів `React.createElement()`. JSX дозволяє розробникам описувати структуру UI компонента в тому ж файлі, де і логіка, роблячи код більш зрозумілим та інтуїтивним. \n**Синтаксис:** \n- Теги схожі на HTML: `<p>Привіт, світ!</p>` \n- Вбудовування JavaScript: Вирази JavaScript вставляються у фігурних дужках `{}`. Наприклад, `<h1>Привіт, {name}!</h1>` \n- Атрибути: Використовують camelCase (наприклад, `className` замість `class`). \n- Закриваючі теги: Всі теги повинні бути закриті (наприклад, `<img />` або `<p></p>`). \n- Фрагменти: Для повернення кількох елементів без додаткового вузла DOM, використовується `<>...</>` або `<React.Fragment>...</React.Fragment>`.",
    "additionalQuestions": [
      {
        "id": "react-q3-aq1",
        "question": "Чи розуміє браузер JSX напряму?",
        "answer": "Ні, браузер не розуміє JSX напряму. JSX-код транспілюється в чистий JavaScript (виклики `React.createElement()`) за допомогою таких інструментів, як Babel, перш ніж він буде виконаний браузером."
      },
      {
        "id": "react-q3-aq2",
        "question": "Яка різниця між `class` в HTML і `className` в JSX?",
        "answer": "В HTML для призначення CSS-класу використовується атрибут `class`. У JSX, оскільки `class` є зарезервованим словом у JavaScript (для оголошення класів), використовується `className` для уникнення конфліктів."
      },
      {
        "id": "react-q3-aq3",
        "question": "Чому JSX вимагає, щоб всі елементи були закриті?",
        "answer": "JSX транспілюється в JavaScript. JavaScript є строго типізованим і не може інтерпретувати незакриті теги. `<img />` є синтаксично коректним самозакривним елементом, на відміну від `<img` в HTML."
      }
    ]
  },
  {
    "id": "react-q4",
    "topic": "React",
    "mainQuestion": "Чи обов’язково використовувати JSX із Реактом?",
    "mainAnswer": "Ні, використовувати JSX із React не обов'язково. React можна використовувати і без JSX, створюючи елементи безпосередньо за допомогою методу `React.createElement()`. Наприклад, замість `<p>Привіт</p>` ви могли б написати `React.createElement('p', null, 'Привіт')`. \nОднак, JSX є настільки зручним, інтуїтивно зрозумілим і поширеним, що практично всі сучасні React-проекти використовують його. Він значно покращує читабельність та зручність написання UI-коду, тому відмова від нього рідко є виправданою.",
    "additionalQuestions": [
      {
        "id": "react-q4-aq1",
        "question": "Які переваги використання JSX над `React.createElement()`?",
        "answer": "JSX робить код більш читабельним, схожим на HTML, що полегшує візуалізацію структури UI. Він також спрощує написання та підтримування складних UI-ієрархій порівняно з вкладеними викликами `React.createElement()`."
      },
      {
        "id": "react-q4-aq2",
        "question": "Чому React команда рекомендує використовувати JSX?",
        "answer": "Команда React рекомендує JSX, оскільки він дозволяє писати розмітку і логіку разом, що відповідає компонентному підходу, де компоненти є самодостатніми одиницями UI. Це робить код більш зрозумілим та легшим для візуалізації."
      },
      {
        "id": "react-q4-aq3",
        "question": "Чи є якісь інші синтаксиси, схожі на JSX, у інших бібліотеках?",
        "answer": "Так, інші бібліотеки та фреймворки також мають свої синтаксичні розширення або шаблонізатори, які дозволяють писати декларативну розмітку. Наприклад, Vue.js використовує однофайлові компоненти з HTML-шаблонами, Svelte має свій власний синтаксис шаблонів, а Angular використовує HTML-шаблони зі спеціальними директивами."
      }
    ]
  },
  {
    "id": "react-q5",
    "topic": "React",
    "mainQuestion": "Що таке Virtual DOM?",
    "mainAnswer": "Virtual DOM (Віртуальний DOM) — це легка JavaScript-копія реального DOM. Коли стан React-компонента змінюється, React спочатку створює нове дерево Virtual DOM. Потім він порівнює це нове дерево з попереднім станом Virtual DOM (процес, що називається 'diffing'). React обчислює мінімальний набір змін, необхідних для оновлення реального DOM, і застосовує лише ці зміни. Це значно підвищує продуктивність, оскільки прямі маніпуляції з реальним DOM є повільними та ресурсоємними.",
    "additionalQuestions": [
      {
        "id": "react-q5-aq1",
        "question": "Чому маніпуляції з реальним DOM повільні?",
        "answer": "Маніпуляції з реальним DOM повільні, тому що кожна зміна викликає перерахунок стилів, макета (layout) та перемальовування (repaint) сторінки, що є ресурсоємними операціями для браузера. Крім того, прямі маніпуляції можуть бути неоптимальними, якщо зміни відбуваються часто."
      },
      {
        "id": "react-q5-aq2",
        "question": "Що таке 'diffing' та 'reconciliation' у контексті Virtual DOM?",
        "answer": "'Diffing' — це процес порівняння двох версій Virtual DOM для визначення відмінностей. 'Reconciliation' — це процес, за допомогою якого React оновлює реальний DOM на основі цих відмінностей, застосовуючи лише необхідні зміни."
      },
      {
        "id": "react-q5-aq3",
        "question": "Чи всі фреймворки використовують Virtual DOM?",
        "answer": "Ні, не всі. Хоча Virtual DOM є популярною оптимізацією в таких бібліотеках, як React, інші фреймворки можуть використовувати різні підходи. Наприклад, Svelte взагалі не використовує Virtual DOM, а компілює код у невеликі, оптимізовані для DOM зміни під час збирання."
      }
    ]
  },
  {
    "id": "react-q6",
    "topic": "React",
    "mainQuestion": "Що таке компонент і в чому різниця між компонентом-функцією та компонентом-класом? У чому відмінність між компонентом та JSX-елементом?",
    "mainAnswer": "**Компонент** у React — це незалежна, багаторазово використовувана частина UI, яка інкапсулює свою власну логіку та вигляд. Компоненти дозволяють розбивати UI на дрібніші, керовані частини. \n**Відмінності між компонентом-функцією та компонентом-класом:** \n- **Компонент-функція (Functional Component)**: Просто функція JavaScript, яка приймає `props` як аргумент і повертає JSX. До появи хуків (Hooks) вони були 'безстатусні' (stateless). З хуками (React 16.8+) вони можуть мати стан та доступ до життєвого циклу. \n- **Компонент-клас (Class Component)**: Клас JavaScript, який успадковується від `React.Component` та має метод `render()`, який повертає JSX. До появи хуків, вони були єдиним способом мати стан та методи життєвого циклу. \n**Відмінність між компонентом та JSX-елементом:** \n- **Компонент**: Це шаблон (функція або клас) для створення UI. Це *визначення* того, що буде рендеритися. \n- **JSX-елемент**: Це *екземпляр* або *опис* того, що буде рендеритися. Це те, що повертає метод `render()` компонента або сама функція-компонент, і що React потім використовуватиме для побудови Virtual DOM (наприклад, `<MyComponent />` або `<div>`).",
    "additionalQuestions": [
      {
        "id": "react-q6-aq1",
        "question": "Коли варто використовувати компоненти-класи замість компонентів-функцій у сучасній розробці React?",
        "answer": "У сучасній розробці React (після появи хуків у React 16.8) компоненти-функції з хуками можуть робити все, що робили компоненти-класи, і часто є кращим вибором через їхню простоту та легкість тестування. Компоненти-класи все ще можуть зустрічатися у старих кодових базах, або якщо є специфічна потреба у їхніх методах життєвого циклу без використання хуків."
      },
      {
        "id": "react-q6-aq2",
        "question": "Що таке 'стан' (state) у контексті React-компонентів?",
        "answer": "Стан (state) — це об'єкт, який містить дані, що належать конкретному компоненту і можуть змінюватися з часом, впливаючи на його рендеринг. Зміна стану компонента призводить до його повторного рендерингу."
      },
      {
        "id": "react-q6-aq3",
        "question": "Як React розуміє, чи JSX-тег є HTML-елементом, чи React-компонентом?",
        "answer": "React використовує правило, що теги, які починаються з великої літери (наприклад, `<MyComponent />`), вважаються React-компонентами, а теги, які починаються з малої літери (наприклад, `<div>`), вважаються стандартними HTML-елементами."
      }
    ]
  },
  {
    "id": "react-q7",
    "topic": "React",
    "mainQuestion": "Що таке props? Як отримати до них доступ і як їх поміняти?",
    "mainAnswer": "**Props** (від 'properties') — це механізм у React для передачі даних від батьківського компонента до дочірнього. Props є **тільки для читання** (read-only) і **незмінними** (immutable) для дочірнього компонента. Компоненти завжди повинні поводитися як 'чисті функції' по відношенню до своїх props. \n**Доступ до props:** \n- **Компонент-функція**: Props передаються як перший аргумент функції: `function MyComponent(props) { return <h1>{props.title}</h1>; }` \n- **Компонент-клас**: Props доступні через `this.props`: `class MyComponent extends React.Component { render() { return <h1>{this.props.title}</h1>; } }` \n**Зміна props:** \n- Дочірній компонент **не може** безпосередньо змінювати свої props. \n- Щоб змінити дані, які передаються через props, батьківський компонент повинен оновити свій власний стан (state) або props, які він отримує, і тоді передати нові значення дочірньому компоненту.",
    "additionalQuestions": [
      {
        "id": "react-q7-aq1",
        "question": "Чому props є незмінними?",
        "answer": "Props є незмінними для дочірнього компонента, щоб забезпечити передбачуваність потоку даних у React. Це допомагає підтримувати односпрямований потік даних і запобігає непередбаченим побічним ефектам, коли дочірній компонент випадково змінює дані, отримані від батька."
      },
      {
        "id": "react-q7-aq2",
        "question": "Як передати функцію як prop?",
        "answer": "Ви можете передавати функції як props так само, як і будь-які інші дані: `<ChildComponent onClick={() => console.log('Клік')} />`. Це поширений спосіб дозволити дочірньому компоненту викликати функцію, визначену в батьківському, для передачі даних або сповіщення про події."
      },
      {
        "id": "react-q7-aq3",
        "question": "Чи можна призначити значення за замовчуванням для props?",
        "answer": "Так, можна. Для компонентів-функцій можна використовувати синтаксис деструктуризації з присвоєнням значень за замовчуванням (`function MyComponent({ title = 'Default Title' })`). Для компонентів-класів раніше використовували `defaultProps` (статична властивість класу), але зараз це також можна зробити через значення за замовчуванням у деструктуризації."
      }
    ]
  },
  {
    "id": "react-q8",
    "topic": "React",
    "mainQuestion": "Що таке state? Як отримати до нього доступ і як його поміняти?",
    "mainAnswer": "**State** (стан) — це об'єкт JavaScript, який належить конкретному компоненту і містить дані, що можуть змінюватися з часом і впливати на рендеринг цього компонента. На відміну від `props`, `state` є приватним і повністю контролюється компонентом, який його володіє. Зміна стану призводить до повторного рендерингу компонента та його дочірніх елементів. \n**Доступ до state:** \n- **Компонент-клас**: Доступ через `this.state`. Наприклад: `this.state.count` \n- **Компонент-функція (з хуками)**: Доступ через повернене значення `useState` хука. Наприклад: `const [count, setCount] = useState(0); // count` \n**Зміна state:** \n- **Компонент-клас**: Зміна здійснюється за допомогою методу `this.setState()`. Наприклад: `this.setState({ count: this.state.count + 1 });`. `setState` є асинхронним і об'єднує зміни. \n- **Компонент-функція (з хуками)**: Зміна здійснюється за допомогою функції-сеттера, поверненої `useState`. Наприклад: `setCount(count + 1);`. Ця функція також є асинхронною.",
    "additionalQuestions": [
      {
        "id": "react-q8-aq1",
        "question": "Чи є зміна стану в React синхронною чи асинхронною?",
        "answer": "Зміна стану (`this.setState()` або функція-сеттер `useState`) є асинхронною. React групує кілька викликів `setState` для оптимізації продуктивності, тому не варто покладатися на миттєве оновлення `this.state` або значення стану після виклику `setState`."
      },
      {
        "id": "react-q8-aq2",
        "question": "Чому не можна змінювати стан напряму (наприклад, `this.state.count = 1`)?",
        "answer": "Пряма зміна стану не повідомить React про необхідність повторного рендерингу компонента, що призведе до розсинхронізації UI та стану. Завжди використовуйте `this.setState()` або функцію-сеттер від `useState`."
      },
      {
        "id": "react-q8-aq3",
        "question": "Як оновити стан, якщо нове значення залежить від попереднього?",
        "answer": "Для компонентів-класів передайте функцію в `setState`: `this.setState((prevState) => ({ count: prevState.count + 1 }));`. Для функціональних компонентів також передайте функцію в сеттер: `setCount((prevCount) => prevCount + 1);`. Це гарантує, що ви працюєте з найактуальнішим станом."
      }
    ]
  },
  {
    "id": "react-q9",
    "topic": "React",
    "mainQuestion": "Які є методи життєвого циклу React-компонента?",
    "mainAnswer": "Методи життєвого циклу (Lifecycle methods) — це спеціальні методи у компонентах-класах React, які викликаються в певні моменти їх існування: при створенні, оновленні або видаленні з DOM. Вони дозволяють виконувати код у відповідь на ці події. \n**Основні методи життєвого циклу (для класових компонентів, до появи хуків):** \n- **Монтування (Mounting - створення):** \n  - `constructor()`: Ініціалізація стану, прив'язка методів. \n  - `static getDerivedStateFromProps()`: Оновлення стану на основі props. \n  - `render()`: Рендеринг JSX. \n  - `componentDidMount()`: Викликається після першого рендерингу компонента в DOM. Ідеально для завантаження даних, підписок. \n- **Оновлення (Updating):** \n  - `static getDerivedStateFromProps()`: Знову ж таки, викликається при оновленні props/state. \n  - `shouldComponentUpdate()`: Для оптимізації, визначає, чи потрібно компоненту оновлюватися. \n  - `render()`: Повторний рендеринг JSX. \n  - `getSnapshotBeforeUpdate()`: Отримує знімок DOM перед його оновленням. \n  - `componentDidUpdate()`: Викликається після оновлення компонента. Добре для роботи з DOM після оновлення, або виконання побічних ефектів. \n- **Розмонтування (Unmounting - видалення):** \n  - `componentWillUnmount()`: Викликається безпосередньо перед видаленням компонента з DOM. Ідеально для очищення (відписка, скасування таймерів). \n- **Обробка помилок (Error Handling):** \n  - `static getDerivedStateFromError()`: Для рендерингу запасного UI після помилки. \n  - `componentDidCatch()`: Для логування інформації про помилку.",
    "additionalQuestions": [
      {
        "id": "react-q9-aq1",
        "question": "Які хуки у функціональних компонентах замінюють методи життєвого циклу класів?",
        "answer": "Хук `useEffect` може замінити `componentDidMount`, `componentDidUpdate` та `componentWillUnmount`. Хук `useState` замінює управління станом з `this.state` та `this.setState`."
      },
      {
        "id": "react-q9-aq2",
        "question": "Який метод життєвого циклу викликається найпершим при монтуванні компонента?",
        "answer": "`constructor()` викликається найпершим при створенні екземпляра компонента-класу."
      },
      {
        "id": "react-q9-aq3",
        "question": "Чи можна викликати `setState` у `render()`?",
        "answer": "Ні, категорично не можна викликати `setState` у методі `render()`. Це призведе до нескінченного циклу рендерингу, оскільки `setState` спричиняє повторний рендеринг, який знову викличе `setState`."
      }
    ]
  },
  {
    "id": "react-q10",
    "topic": "React",
    "mainQuestion": "Як користуватися методом `componentDidMount` і для чого він потрібен?",
    "mainAnswer": "`componentDidMount()` — це метод життєвого циклу компонента-класу, який викликається одразу після того, як компонент та всі його дочірні елементи були відрендерені та вставлені в DOM. \n**Для чого потрібен:** \n- **Завантаження даних (Data Fetching)**: Ідеальне місце для виконання HTTP-запитів до API, оскільки компонент вже знаходиться в DOM, і ви можете оновити його стан після отримання даних. \n- **Підписки**: Встановлення підписок на зовнішні джерела даних (наприклад, вебсокет). \n- **Маніпуляції з DOM**: Якщо вам потрібно отримати доступ до реального DOM-вузла після того, як він був відрендерений (наприклад, для інтеграції зі сторонніми бібліотеками, які працюють безпосередньо з DOM).",
    "additionalQuestions": [
      {
        "id": "react-q10-aq1",
        "question": "Який хук замінює `componentDidMount` у функціональних компонентах?",
        "answer": "Хук `useEffect` з порожнім масивом залежностей (`[]`) замінює `componentDidMount`. Код у ньому виконається лише один раз після першого рендерингу: `useEffect(() => { /* код тут */ }, []);`."
      },
      {
        "id": "react-q10-aq2",
        "question": "Чи можна викликати `setState` у `componentDidMount`?",
        "answer": "Так, можна викликати `setState` у `componentDidMount`. Це призведе до повторного рендерингу, але це є дозволеним, оскільки відбувається після початкового рендерингу і зазвичай використовується для встановлення початкових даних."
      },
      {
        "id": "react-q10-aq3",
        "question": "Що станеться, якщо `componentDidMount` поверне значення?",
        "answer": "`componentDidMount` (як і інші методи життєвого циклу, крім `render`) не очікує і не обробляє повернене значення. Будь-яке повернене значення буде проігноровано React."
      }
    ]
  },
  {
    "id": "react-q11",
    "topic": "React",
    "mainQuestion": "Як користуватися методом `componentDidUpdate` і для чого він потрібен?",
    "mainAnswer": "`componentDidUpdate(prevProps, prevState, snapshot)` — це метод життєвого циклу компонента-класу, який викликається одразу після того, як відбулося оновлення компонента (внаслідок зміни props або state). \n**Для чого потрібен:** \n- **Виконання побічних ефектів у відповідь на зміни props/state**: Наприклад, оновлення DOM залежно від нового стану, повторне завантаження даних, якщо змінився ID елемента, або взаємодія зі сторонніми бібліотеками. \n- **Важливо**: Завжди слід порівнювати `prevProps` та `prevState` з поточними `this.props` та `this.state` всередині цього методу, щоб уникнути нескінченних циклів рендерингу при виклику `this.setState()`.",
    "additionalQuestions": [
      {
        "id": "react-q11-aq1",
        "question": "Який хук замінює `componentDidUpdate` у функціональних компонентах?",
        "answer": "Хук `useEffect` з масивом залежностей, що містить змінні, за зміною яких потрібно стежити, замінює `componentDidUpdate`. Наприклад: `useEffect(() => { /* код тут */ }, [dependency1, dependency2]);`."
      },
      {
        "id": "react-q11-aq2",
        "question": "Які аргументи приймає `componentDidUpdate`?",
        "answer": "`componentDidUpdate` приймає три аргументи: `prevProps` (попередні props), `prevState` (попередній стан) та `snapshot` (значення, повернуте з `getSnapshotBeforeUpdate()`, якщо він використовується)."
      },
      {
        "id": "react-q11-aq3",
        "question": "Чому важливо порівнювати попередні та поточні props/state у `componentDidUpdate`?",
        "answer": "Це необхідно для запобігання нескінченним циклам. Якщо `setState` викликається всередині `componentDidUpdate` без умови порівняння, то кожне оновлення буде викликати нове оновлення, що призведе до зациклення."
      }
    ]
  },
  {
    "id": "react-q12",
    "topic": "React",
    "mainQuestion": "Як користуватися методом `componentWillUnmount` і для чого він потрібен?",
    "mainAnswer": "`componentWillUnmount()` — це метод життєвого циклу компонента-класу, який викликається безпосередньо перед тим, як компонент буде видалено з DOM та розмонтовано. \n**Для чого потрібен:** \n- **Очищення ресурсів**: Це останній шанс виконати будь-які операції очищення. \n- **Скасування підписок**: Відписка від подій (наприклад, `addEventListener`), вебсокетів, таймерів (наприклад, `clearInterval`, `clearTimeout`). \n- **Скасування мережевих запитів**: Скасування незавершених HTTP-запитів, щоб уникнути витоків пам'яті або встановлення стану на розмонтованому компоненті.",
    "additionalQuestions": [
      {
        "id": "react-q12-aq1",
        "question": "Який хук замінює `componentWillUnmount` у функціональних компонентах?",
        "answer": "Хук `useEffect` з функцією очищення, що повертається з колбека, замінює `componentWillUnmount`. Наприклад: `useEffect(() => { /* код для підписки */ return () => { /* код для відписки */ }; }, []);`."
      },
      {
        "id": "react-q12-aq2",
        "question": "Що станеться, якщо не очистити підписки або таймери в `componentWillUnmount`?",
        "answer": "Це може призвести до **витоків пам'яті** та непередбачуваної поведінки. Навіть після видалення компонента, колбеки підписок або таймерів можуть продовжувати виконуватися, намагаючись оновити стан неіснуючого компонента, що може спричинити помилки."
      },
      {
        "id": "react-q12-aq3",
        "question": "Чи можна викликати `setState` у `componentWillUnmount`?",
        "answer": "Ні, не варто викликати `setState` у `componentWillUnmount`. Компонент вже знаходиться на етапі розмонтування, і будь-які зміни стану не будуть мати ефекту на UI, а лише викличуть попередження React про використання `setState` на розмонтованому компоненті."
      }
    ]
  },
  {
    "id": "react-q13",
    "topic": "React",
    "mainQuestion": "Як можна навісити подію на JSX-компонент? Чи можна навішувати події на компоненти?",
    "mainAnswer": "У React події навішуються на JSX-елементи (наприклад, `<div>`, `<button>`) за допомогою **camelCase-атрибутів**, які приймають функцію-обробник. \nПриклад: `<button onClick={handleClick}>Натисни мене</button>`. \n\n**Чи можна навішувати події на компоненти?** \nТак, можна, але це працює дещо інакше: \n- **На кастомні React-компоненти (наприклад, `<MyButton />`)**: Атрибут події, такий як `onClick`, який ви передаєте кастомному компоненту, буде переданий йому як `prop`. Цей `prop` має бути потім **явно переданий** (прокинутий) до реального DOM-елемента всередині цього кастомного компонента, щоб подія спрацювала. \nПриклад: \n```jsx \nfunction MyButton({ onClick, children }) { \n  return <button onClick={onClick}>{children}</button>; \n} \n// Використання: \n<MyButton onClick={() => console.log('Клік')}>Мій Button</MyButton> \n``` \nЯкщо не прокинути `onClick` до внутрішнього `button`, подія не спрацює. \n- **На DOM-елементи**: Події навішуються напряму, як зазначено вище.",
    "additionalQuestions": [
      {
        "id": "react-q13-aq1",
        "question": "Яка різниця між `onClick` у React та `onclick` у чистому HTML?",
        "answer": "У React `onClick` — це JSX-атрибут у camelCase, який приймає функцію JavaScript. У HTML `onclick` — це атрибут, який приймає рядок з JavaScript-кодом. React-події також є синтетичними подіями, які обгортають нативні події браузера."
      },
      {
        "id": "react-q13-aq2",
        "question": "Що таке 'синтетичні події' (Synthetic Events) у React?",
        "answer": "Синтетичні події — це обгортка React навколо нативних подій браузера. Вони забезпечують кросбраузерну сумісність і мають однакову структуру, незалежно від браузера. Об'єкти синтетичних подій повторно використовуються React для оптимізації продуктивності, тому ви не повинні зберігати посилання на них або звертатися до них асинхронно."
      },
      {
        "id": "react-q13-aq3",
        "question": "Як передати аргументи в обробник подій у React?",
        "answer": "Найкращий спосіб — використовувати стрілкову функцію або `bind` у JSX: \n- Стрілкова функція: `<button onClick={() => handleClick(argument)}>` \n- `bind`: `<button onClick={this.handleClick.bind(this, argument)}>` (для класових компонентів)."
      }
    ]
  },
  {
    "id": "react-q14",
    "topic": "React",
    "mainQuestion": "Результат яких типів може повертати метод `render` (або компонент-функція)?",
    "mainAnswer": "Метод `render()` компонента-класу (або компонент-функція) може повертати наступні типи значень: \n1.  **JSX-елемент**: Найпоширеніший випадок, наприклад, `<div>Привіт</div>`. \n2.  **Масив або `React.Fragment`**: Дозволяє повертати кілька елементів без створення додаткового батьківського вузла в DOM. Наприклад, `[<p>1</p>, <p>2</p>]` або `<>...</>`. \n3.  **Портал (Portal)**: Дозволяє рендерити дочірні елементи в DOM-вузол, який знаходиться *поза* ієрархією батьківського компонента. \n4.  **`null`**: Якщо компонент не повинен нічого рендерити. \n5.  **Рядок або число**: Рендериться як текстовий вузол. \n6.  **Булеве значення (`true`/`false`)**: React ігнорує булеві значення, що дозволяє використовувати їх для умовного рендерингу, наприклад, `{isLoggedIn && <Profile />}`.",
    "additionalQuestions": [
      {
        "id": "react-q14-aq1",
        "question": "У яких випадках варто використовувати `React.Fragment` або `Short Syntax Fragments (<></>)`?",
        "answer": "`React.Fragment` (або `<>...</>`) варто використовувати, коли компонент має повернути кілька дочірніх елементів, але ви не хочете додавати зайвий `div` (або інший елемент) у DOM. Це допомагає підтримувати чисту структуру DOM, особливо для гнучких макетів (CSS Flexbox/Grid)."
      },
      {
        "id": "react-q14-aq2",
        "question": "Для чого потрібні React Portals?",
        "answer": "React Portals дозволяють рендерити дочірні елементи поза DOM-ієрархією батьківського компонента. Це корисно для модальних вікон, спливаючих меню, тултипів та інших елементів, які повинні 'вириватися' з поточного контексту DOM, але при цьому зберігати логіку та стан React-компонента."
      },
      {
        "id": "react-q14-aq3",
        "question": "Що буде, якщо `render` поверне `undefined`?",
        "answer": "Якщо метод `render` (або функція-компонент) поверне `undefined` замість `null`, React викине помилку, оскільки `undefined` не є допустимим поверненим значенням для рендерингу."
      }
    ]
  },
  {
    "id": "react-q15",
    "topic": "React",
    "mainQuestion": "У яких випадках потрібно присвоювати елементам та/або компонентам атрибут `key`? Яке значення слід присвоювати цьому атрибуту? Для чого він потрібен?",
    "mainAnswer": "`key` — це спеціальний строковий атрибут, який потрібно присвоювати елементам при рендерингу списків компонентів або елементів. \n**Коли потрібен:** Коли ви рендерите список елементів, отриманих з масиву (наприклад, за допомогою `map`). \n**Яке значення присвоювати:** `key` має бути **унікальним** серед своїх 'братів' (sibling elements) у цьому списку. Ідеально використовувати стабільний та унікальний ID з даних (наприклад, ID запису з бази даних). \n**Для чого потрібен:** React використовує `key` для ефективної ідентифікації елементів у списку та відстеження їхніх змін, додавання, видалення та перевпорядкування. Це дозволяє React оптимізувати оновлення DOM, повторно використовувати існуючі елементи замість перерендерингу всього списку, що значно покращує продуктивність при роботі з динамічними списками. Без `key` або з неоптимальним `key` (наприклад, індекс масиву при змінюваному порядку), React може некоректно оновлювати UI або мати проблеми з продуктивністю.",
    "additionalQuestions": [
      {
        "id": "react-q15-aq1",
        "question": "Чому використання індексу масиву як `key` є поганою практикою, якщо елементи списку можуть змінювати порядок?",
        "answer": "Якщо елементи списку змінюють порядок, а `key` є індексом, React може переплутати елементи. Це призведе до неправильних оновлень UI, проблем з внутрішнім станом компонента або неоптимального рендерингу, оскільки React вважатиме, що той самий елемент просто змінив вміст, замість того, щоб зрозуміти, що елемент перемістився."
      },
      {
        "id": "react-q15-aq2",
        "question": "Чи потрібно, щоб `key` був глобально унікальним?",
        "answer": "Ні, `key` має бути унікальним лише серед своїх 'братів' (sibling elements) у межах одного списку. Ви можете використовувати той самий `key` в іншому списку, якщо ці списки не є братами."
      },
      {
        "id": "react-q15-aq3",
        "question": "Чи передається `key` як `prop` до компонента?",
        "answer": "Ні, атрибут `key` є спеціальним атрибутом, який використовується React внутрішньо для оптимізації ідентифікації елементів. Він не доступний як `prop` у дочірньому компоненті."
      }
    ]
  },
  {
    "id": "react-q16",
    "topic": "React",
    "mainQuestion": "Що таке контрольовані компоненти?",
    "mainAnswer": "**Контрольовані компоненти** (Controlled Components) — це елементи форм у React (наприклад, `<input>`, `<textarea>`, `<select>`), значення яких повністю контролюються станом (state) React-компонента. Значення поля форми не зберігається безпосередньо в DOM, а зберігається в стані компонента. Коли користувач вводить дані, React перехоплює цю подію (`onChange`), оновлює стан компонента, і це нове значення стану потім відображається в полі форми. \n**Приклад:** \n```jsx \nfunction MyForm() { \n  const [value, setValue] = useState(''); \n  return <input type=\"text\" value={value} onChange={(e) => setValue(e.target.value)} />; \n} \n``` \nЦе забезпечує єдине джерело істини для даних форми, полегшує валідацію та маніпуляції з формою.",
    "additionalQuestions": [
      {
        "id": "react-q16-aq1",
        "question": "Яка головна перевага контрольованих компонентів?",
        "answer": "Головна перевага — це те, що стан форми завжди синхронізований зі станом React. Це значно спрощує доступ до даних форми, їх валідацію та маніпуляції з ними, оскільки дані вже знаходяться у керуючому компоненті."
      },
      {
        "id": "react-q16-aq2",
        "question": "Який атрибут використовується для контрольованого `input` і який обробник подій?",
        "answer": "Для контрольованого `<input>` використовується атрибут `value` (для введення тексту) або `checked` (для чекбоксів/радіокнопок) для зв'язування зі станом, а обробник подій `onChange` використовується для оновлення стану при зміні значення."
      },
      {
        "id": "react-q16-aq3",
        "question": "Чи можна використовувати контрольовані компоненти без хука `useState`?",
        "answer": "Так, у компонентах-класах контрольовані компоненти реалізуються за допомогою `this.state` та `this.setState()`. Хук `useState` є сучасним способом управління станом у функціональних компонентах."
      }
    ]
  },
  {
    "id": "react-q17",
    "topic": "React",
    "mainQuestion": "Чи відрізняються чимось атрибути та події для полів форми у Реакті від звичайних у DOM?",
    "mainAnswer": "Так, є кілька ключових відмінностей: \n- **Іменування атрибутів (Naming Conventions)**: У React атрибути пишуться в `camelCase` (наприклад, `htmlFor` замість `for`, `className` замість `class`), тоді як у HTML/DOM вони зазвичай у `kebab-case` або просто нижньому регістрі. \n- **Обробники подій (Event Handlers)**: У React обробники подій також пишуться в `camelCase` (наприклад, `onClick`, `onChange`) і приймають **функції** як значення, тоді як у HTML/DOM вони зазвичай у нижньому регістрі (`onclick`) і приймають **рядки з JavaScript-кодом**. \n- **Синтетичні події (Synthetic Events)**: React створює об'єкти 'синтетичних подій' як обгортки для нативних подій браузера, забезпечуючи кросбраузерну сумісність. \n- **Значення полів форми**: Для текстових полів (`<input type=\"text\">`, `<textarea>`), значення контролюється атрибутом `value` (а не `defaultValue`). Для `checkbox` та `radio` — `checked` (а не `defaultChecked`). \n- **Атрибут `style`**: У React атрибут `style` приймає об'єкт JavaScript, а не рядок CSS-стилів. Наприклад: `style={{ color: 'red', fontSize: '16px' }}`. \n- **`for` в `label`**: У React використовується `htmlFor` замість `for` для атрибута `label`.",
    "additionalQuestions": [
      {
        "id": "react-q17-aq1",
        "question": "Як у React призначити CSS-стилі інлайн?",
        "answer": "У React інлайн-стилі призначаються за допомогою об'єкта JavaScript, де ключі — це властивості CSS у camelCase, а значення — їхні значення: `<div style={{ backgroundColor: 'blue', padding: '10px' }}></div>`."
      },
      {
        "id": "react-q17-aq2",
        "question": "Яка роль атрибута `defaultValue` для полів форми в React?",
        "answer": "`defaultValue` використовується для *неконтрольованих* компонентів форми, щоб встановити початкове значення. Після цього React перестає керувати цим значенням, і воно контролюється DOM."
      },
      {
        "id": "react-q17-aq3",
        "question": "Що потрібно робити з об'єктом події (`event`) у React, якщо мені потрібно його використовувати асинхронно?",
        "answer": "Об'єкти синтетичних подій React повторно використовуються для оптимізації. Якщо вам потрібно отримати доступ до властивостей події асинхронно (після того, як обробник завершив роботу), вам потрібно викликати `event.persist()` (хоча в нових версіях React це рідко потрібно, оскільки подію вже не обнуляють) або зберегти потрібні властивості в окремі змінні."
      }
    ]
  },
  {
    "id": "react-q18",
    "topic": "React",
    "mainQuestion": "Що таке неконтрольовані компоненти? У яких випадках є сенс їх використовувати?",
    "mainAnswer": "**Неконтрольовані компоненти** (Uncontrolled Components) — це елементи форм у React, значення яких керуються DOM, а не станом React-компонента. Замість того, щоб React керував значенням поля через стан та обробник `onChange`, ви використовуєте рефи (refs) для прямого доступу до DOM-вузла поля та отримання його значення, коли це потрібно (наприклад, при відправці форми). \n**Приклад:** \n```jsx \nfunction MyUncontrolledForm() { \n  const inputRef = useRef(null); \n  function handleSubmit(event) { \n    event.preventDefault(); \n    alert('Введено: ' + inputRef.current.value); \n  } \n  return ( \n    <form onSubmit={handleSubmit}> \n      <input type=\"text\" ref={inputRef} defaultValue=\"Привіт\" /> \n      <button type=\"submit\">Відправити</button> \n    </form> \n  ); \n} \n``` \n**Коли використовувати:** \n- **Прості форми**: Для невеликих форм, де не потрібна миттєва валідація або складні маніпуляції з введенням. \n- **Інтеграція зі сторонніми бібліотеками DOM**: Якщо ви використовуєте бібліотеку, яка безпосередньо маніпулює DOM-елементами форми (наприклад, деякі плагіни для введення дати). \n- **Зменшення кількості повторних рендерингів**: Для дуже великих форм з багатьма полями, де контрольовані компоненти можуть викликати надмірні рендеринги. \nЗазвичай, **контрольовані компоненти є рекомендованим підходом** у React, оскільки вони забезпечують єдине джерело істини та кращий контроль над даними форми.",
    "additionalQuestions": [
      {
        "id": "react-q18-aq1",
        "question": "Що таке 'рефи' (refs) у React і для чого вони використовуються?",
        "answer": "Рефи — це спосіб отримати прямий доступ до DOM-вузлів або екземплярів React-компонентів. Вони використовуються у випадках, коли потрібно взаємодіяти з елементами DOM напряму (наприклад, фокусування, прокрутка, вимірювання розмірів) або для інтеграції зі сторонніми бібліотеками, які працюють безпосередньо з DOM."
      },
      {
        "id": "react-q18-aq2",
        "question": "Який хук використовується для створення рефів у функціональних компонентах?",
        "answer": "Для створення рефів у функціональних компонентах використовується хук `useRef`. Він повертає об'єкт рефа, який можна прив'язати до DOM-елемента за допомогою атрибута `ref`."
      },
      {
        "id": "react-q18-aq3",
        "question": "Чому контрольовані компоненти є кращими для більшості випадків?",
        "answer": "Контрольовані компоненти забезпечують більш передбачуваний потік даних, спрощують валідацію введених даних в реальному часі, дозволяють легше скидати форми та керувати їхнім станом декларативно. Це призводить до більш підтримуваного та передбачуваного коду."
      }
    ]
  },
  {
    "id": "react-q19",
    "topic": "React",
    "mainQuestion": "Що таке підйом стану (lifting state up)? Наведіть приклад ситуації, коли ним варто скористатися.",
    "mainAnswer": "**Підйом стану** (Lifting State Up) — це патерн у React, коли кілька компонентів потребують одного й того ж спільного стану, або коли один компонент потребує зміни стану іншого (не-дочірнього) компонента. Замість того, щоб зберігати цей стан у кожному з цих компонентів окремо, стан **переміщується вгору** до їхнього найближчого спільного батьківського компонента. \nБатьківський компонент потім передає дані зі свого стану вниз до дочірніх компонентів через `props`, а також може передавати функції-колбеки як `props`, щоб дочірні компоненти могли повідомляти батьківський про зміни, які вимагають оновлення стану. \n\n**Приклад ситуації:** \nВи маєте два компоненти: `TemperatureInput` (для введення температури в Цельсіях) та `CelsiusDisplay` (для відображення температури в Цельсіях). Обидва компоненти повинні відображати або оновлювати **одну й ту саму температуру**. \nЗамість того, щоб кожен компонент зберігав свою власну температуру, стан температури `temperature` піднімається до спільного батьківського компонента (наприклад, `Calculator`). Батьківський компонент `Calculator` керує станом `temperature`, передає його до `TemperatureInput` як `props` (разом з функцією-колбеком для оновлення) та до `CelsiusDisplay` як `props` для відображення.",
    "additionalQuestions": [
      {
        "id": "react-q19-aq1",
        "question": "Яка головна перевага підйому стану?",
        "answer": "Головна перевага — це підтримка єдиного джерела істини (single source of truth) для спільного стану. Це забезпечує синхронізацію даних між компонентами, полегшує налагодження та робить потік даних більш передбачуваним."
      },
      {
        "id": "react-q19-aq2",
        "question": "Чи завжди варто піднімати стан, якщо він використовується кількома компонентами?",
        "answer": "Так, якщо кілька компонентів потребують доступу до одного й того ж стану або цей стан впливає на них, підйом стану є рекомендованим патерном. Однак, для дуже складних глобальних станів може бути доцільніше використовувати системи управління станом, такі як Redux, Zustand, Recoil або React Context API."
      },
      {
        "id": "react-q19-aq3",
        "question": "Як дочірній компонент повідомляє батьківський про зміну стану при підйомі стану?",
        "answer": "Батьківський компонент передає функцію-колбек (яка змінює стан батька) як `prop` до дочірнього компонента. Коли в дочірньому компоненті відбувається подія, він викликає цю функцію-колбек, передаючи їй необхідні дані."
      }
    ]
  },
  {
    "id": "react-q20",
    "topic": "React",
    "mainQuestion": "Що таке композиція компонентів?",
    "mainAnswer": "**Композиція компонентів** (Component Composition) — це фундаментальний патерн у React, який полягає в побудові складних UI-елементів шляхом поєднання (композиції) простіших, незалежних компонентів. Замість того, щоб успадковувати функціональність (як у традиційному об'єктно-орієнтованому програмуванні), React заохочує композицію, де компоненти 'міститимуть' інші компоненти у своїй розмітці. \nЦе дозволяє створювати гнучкі, модульні та багаторазово використовувані UI. Компоненти можуть передавати дані та функціональність іншим компонентам через `props`, включаючи `children` prop. \n**Приклад:** \n```jsx \n// Компонент-контейнер, що приймає дочірні елементи \nfunction Card({ children }) { \n  return <div className=\"card\">{children}</div>; \n} \n// Використання: \n<Card> \n  <h2>Заголовок картки</h2> \n  <p>Опис картки.</p> \n  <button>Дія</button> \n</Card> \n``` \nТут `Card` є компонентом, який 'компонує' інші елементи, що передаються йому через `children`.",
    "additionalQuestions": [
      {
        "id": "react-q20-aq1",
        "question": "Яка альтернатива композиції компонентів у ООП і чому React віддає перевагу композиції?",
        "answer": "Альтернатива — це успадкування (inheritance). React віддає перевагу композиції, тому що вона є більш гнучкою, дозволяє уникнути проблем 'ієрархії успадкування' та 'крихкості базового класу'. Композиція робить компоненти більш незалежними, багаторазово використовуваними та легкими для тестування."
      },
      {
        "id": "react-q20-aq2",
        "question": "Що таке `props.children` і для чого він використовується?",
        "answer": "`props.children` — це спеціальний prop, який автоматично передається до компонента, коли він має дочірні елементи (тобто все, що знаходиться між відкриваючим і закриваючим тегами компонента). Він дозволяє 'прокидати' вміст, переданий компоненту, до його рендеру."
      },
      {
        "id": "react-q20-aq3",
        "question": "Наведіть приклад композиції 'спеціалізації'.",
        "answer": "Композиція може використовуватися для 'спеціалізації' компонентів. Наприклад, ви можете мати загальний компонент `Button` і створити `PrimaryButton` або `DangerButton`, які рендерять `Button` з певними попередньо встановленими стилями або властивостями, передаючи їх через props: `<Button type=\"primary\" />`."
      }
    ]
  },
  {
    "id": "react-q21",
    "topic": "React",
    "mainQuestion": "Що таке `React.Fragment` і в яких випадках ним варто користуватися?",
    "mainAnswer": "`React.Fragment` (та його скорочений синтаксис `<></>`) — це спеціальний компонент у React, який дозволяє групувати кілька елементів без додавання додаткових DOM-вузлів у браузері. \n**Коли ним варто користуватися:** \n- **Повернення кількох елементів**: Метод `render()` або функціональний компонент повинні повертати один кореневий елемент. Якщо вам потрібно повернути кілька елементів без створення зайвого `div` (наприклад, у списках або таблицях), `Fragment` є ідеальним рішенням. \n- **Чиста DOM-структура**: Допомагає підтримувати семантично коректну та чисту DOM-структуру, особливо при використанні CSS-фреймворків, таких як Flexbox або Grid, де зайві обгортки можуть порушити макет. \n- **Уникнення 'обгорткових' `div`'ів**: Замість того, щоб писати `<div><ChildA /><ChildB /></div>`, ви можете написати `<><ChildA /><ChildB /></>`, що робить код більш читабельним і не додає зайвого HTML.",
    "additionalQuestions": [
      {
        "id": "react-q21-aq1",
        "question": "Чи можна використовувати `key` з коротким синтаксисом фрагментів (`<></>`)?",
        "answer": "Ні, короткий синтаксис `<></>` не підтримує атрибут `key`. Якщо вам потрібно передати `key` (наприклад, при рендерингу фрагментів у списку), ви повинні використовувати повний синтаксис `React.Fragment` з атрибутом `key`: `<React.Fragment key={item.id}>...</React.Fragment>`."
      },
      {
        "id": "react-q21-aq2",
        "question": "Яка різниця між `React.Fragment` та просто `div` для обгортання елементів?",
        "answer": "`div` створить реальний DOM-елемент у браузері, тоді як `React.Fragment` не додає ніяких додаткових вузлів у DOM. Це може бути важливо для продуктивності та семантики."
      },
      {
        "id": "react-q21-aq3",
        "question": "Чи можуть фрагменти містити лише один дочірній елемент?",
        "answer": "Так, фрагменти можуть містити лише один дочірній елемент, хоча це зазвичай не має сенсу, оскільки сам цей елемент вже є кореневим. Але синтаксично це дозволено."
      }
    ]
  },
  {
    "id": "react-q22",
    "topic": "React",
    "mainQuestion": "Для чого потрібен PropTypes і які види перевірок у ньому доступні?",
    "mainAnswer": "**PropTypes** — це бібліотека (раніше частина React, тепер окремий пакет `prop-types`), яка використовується для **валідації типів props**, що передаються компонентам. Вона допомагає розробникам відловлювати помилки, пов'язані з неправильним типом даних, на етапі розробки, перш ніж вони призведуть до проблем під час виконання. PropTypes є дуже корисним для розробки великих застосунків, де є багато компонентів та розробників. \n**Види перевірок (декілька прикладів):** \n- **Основні типи:** `PropTypes.string`, `PropTypes.number`, `PropTypes.bool`, `PropTypes.array`, `PropTypes.object`, `PropTypes.func`, `PropTypes.symbol`. \n- **Обов'язкові props:** Додайте `.isRequired` до будь-якого типу: `PropTypes.string.isRequired`. \n- **Конкретні типи елементів React:** `PropTypes.element` (для одного елемента), `PropTypes.node` (для будь-якого рендерованого React-об'єкта: числа, рядки, елементи, масиви). \n- **Конкретні значення:** `PropTypes.oneOf(['News', 'Photos'])`. \n- **Масив певного типу:** `PropTypes.arrayOf(PropTypes.number)`. \n- **Об'єкт з певними властивостями:** `PropTypes.shape({ name: PropTypes.string, age: PropTypes.number })`. \n- **Екземпляр класу:** `PropTypes.instanceOf(MyClass)`. \n- **Будь-який тип:** `PropTypes.any` (слід уникати). \nПриклад використання: \n```jsx \nimport PropTypes from 'prop-types'; \nfunction Greeting({ name }) { return <h1>Привіт, {name}</h1>; } \nGreeting.propTypes = { \n  name: PropTypes.string.isRequired \n}; \n``` \n**Важливо**: PropTypes виконує перевірки лише в режимі розробки і не впливає на продуктивність у продакшн-збірці.",
    "additionalQuestions": [
      {
        "id": "react-q22-aq1",
        "question": "Чи замінює TypeScript PropTypes?",
        "answer": "Так, TypeScript значною мірою замінює PropTypes. TypeScript надає статичну типізацію, яка перевіряє типи props під час компіляції (розробки), що є більш надійним і потужним, ніж PropTypes, який працює лише під час виконання в режимі розробки. У більшості сучасних React-проектів з TypeScript PropTypes вже не використовується."
      },
      {
        "id": "react-q22-aq2",
        "question": "Що станеться, якщо передати prop неправильного типу, коли PropTypes встановлений?",
        "answer": "Якщо ви передасте prop неправильного типу, React виведе попередження у консолі розробника в режимі розробки. У режимі продакшну ці перевірки вимкнені, і попередження не відображаються."
      },
      {
        "id": "react-q22-aq3",
        "question": "Чи впливає PropTypes на розмір бандлу (bundle size) застосунку?",
        "answer": "Так, оскільки PropTypes є бібліотекою, її включення збільшує розмір бандлу. Однак, більшість бандлерів (наприклад, Webpack) автоматично видаляють код PropTypes у продакшн-збірках, щоб зменшити розмір файлу для користувача."
      }
    ]
  },
  {
    "id": "react-q23",
    "topic": "React",
    "mainQuestion": "Розкажи про React Hooks.",
    "mainAnswer": "**React Hooks** — це функції, які були представлені в React 16.8, що дозволяють функціональним компонентам використовувати стан (state) та інші можливості React (методи життєвого циклу) без необхідності писати клас. Вони дозволяють 'підключитися' до функцій стану та життєвого циклу React з функціональних компонентів. \n**Основні хуки:** \n- **`useState`**: Дозволяє функціональним компонентам додавати стан. Повертає пару: поточне значення стану та функцію для його оновлення. \n- **`useEffect`**: Дозволяє виконувати побічні ефекти (side effects) у функціональних компонентах (наприклад, завантаження даних, маніпуляції з DOM, підписки). Він спрацьовує після рендерингу, і може бути налаштований на спрацьовування лише при зміні певних залежностей. \n- **`useContext`**: Дозволяє підписуватися на React контекст без вкладеності компонентів. \n- **`useRef`**: Дозволяє створювати рефи для прямого доступу до DOM-елементів або для збереження змінюваних значень, які не викликають повторного рендерингу. \n- **`useReducer`**: Альтернатива `useState` для більш складної логіки стану. \n- **`useCallback` / `useMemo`**: Для оптимізації продуктивності, запам'ятовують функції/значення, щоб уникнути непотрібних перерахунків/перерендерингів. \n\n**Переваги хуків:** \n- **Спрощення коду**: Усувають необхідність писати класи, що зменшує складність коду та полегшує його розуміння. \n- **Повторне використання логіки стану**: Дозволяють легко ділитися логікою стану між компонентами. \n- **Більш зрозумілі життєві цикли**: `useEffect` дозволяє групувати пов'язану логіку (наприклад, підписка та відписка) в одному місці, замість розділення по різних методах життєвого циклу класу. \n- **Простіший тест**: Функціональні компоненти з хуками легше тестувати.",
    "additionalQuestions": [
      {
        "id": "react-q23-aq1",
        "question": "Які 'Правила хуків' (Rules of Hooks) потрібно дотримуватися?",
        "answer": "Існує два основні правила: \n1. **Викликайте хуки лише на верхньому рівні** (Top Level): Не викликайте хуки всередині циклів, умов або вкладених функцій. \n2. **Викликайте хуки лише з функцій React**: Викликайте хуки лише з функціональних компонентів React або з власних (custom) хуків."
      },
      {
        "id": "react-q23-aq2",
        "question": "Чи замінюють хуки повністю компоненти-класи?",
        "answer": "Хоча React офіційно не планує видаляти компоненти-класи, хуки є рекомендованим підходом для написання нового коду, оскільки вони пропонують більш простий та потужний спосіб роботи з функціональністю React. Усі нові функції React будуть додаватися в хуки."
      },
      {
        "id": "react-q23-aq3",
        "question": "У чому відмінність між `useCallback` та `useMemo`?",
        "answer": "`useCallback` використовується для мемоізації **функції**, тобто вона повертає мемоізовану версію функції, яка змінюється лише тоді, коли змінюється одна з її залежностей. `useMemo` використовується для мемоізації **значення**, тобто він повертає мемоізоване значення, яке перераховується лише тоді, коли змінюються його залежності."
      }
    ]
  },
  {
    "id": "react-q24",
    "topic": "React",
    "mainQuestion": "Що таке React Portals і коли їх варто використовувати?",
    "mainAnswer": "**React Portals** — це функція, яка дозволяє рендерити дочірні елементи поза DOM-ієрархією батьківського компонента. Це корисно для створення модальних вікон, спливаючих меню, тултипів та інших елементів, які повинні 'вириватися' з поточного контексту DOM, але при цьому зберігати логіку та стан React-компонента. \n**Коли використовувати:** \n- **Модальні вікна**: Коли потрібно відобразити модальне вікно поверх іншого контенту, не порушуючи структуру DOM. \n- **Спливаючі меню/Тултипи**: Коли потрібно розмістити елемент поверх інших елементів без зміни їхнього порядку в DOM. \n- **Контекстні меню**: Для створення контекстних меню, які відкриваються при кліку правою кнопкою миші. \n\n**Приклад використання:** \n```jsx \nimport ReactDOM from 'react-dom'; \nfunction Modal({ children }) { \n  return ReactDOM.createPortal( \n    <div className=\"modal\">{children}</div>, \n    document.getElementById('modal-root') // Цільовий вузол у DOM \n  ); \n} \n``` \nУ цьому прикладі `Modal` рендериться у вузол з ID `modal-root`, який може бути розташований поза ієрархією батьківського компонента.",
    "additionalQuestions": [
      {
        "id": "react-q24-aq1",
        "question": "Чи можна передавати `props` до компонентів, що рендеряться через портали?",
        "answer": "Так, ви можете передавати `props` до компонентів, що рендеряться через портали, так само, як і до звичайних компонентів."
      },
      {
        "id": "react-q24-aq2",
        "question": "Чи впливають портали на CSS-стилі?",
        "answer": "Так, портали рендерять елементи в інше місце в DOM, але вони все ще підпорядковуються CSS-правилам. Ви можете стилізувати їх так само, як і звичайні елементи, але потрібно бути обережним з контекстом стилів (наприклад, якщо використовуються CSS-селектори, які залежать від батьківських елементів)."
      },
      {
        "id": "react-q24-aq3",
        "question": "Чи можна використовувати портали для рендерингу компонентів у різних частинах DOM?",
        "answer": "Так, портали дозволяють рендерити компоненти в будь-якому місці DOM, що робить їх дуже гнучкими для створення UI-елементів, які потребують особливого розташування в DOM."
      }
    ]
  },
  {
    "id": "react-q25",
    "topic": "React",
    "mainQuestion": "Що таке React Context і коли його варто використовувати?",
    "mainAnswer": "**React Context** — це механізм, який дозволяє передавати дані через дерево компонентів без необхідності передавати їх через `props` на кожному рівні. Це особливо корисно для глобальних даних, таких як налаштування теми, мова, автентифікація користувача тощо. \n**Коли використовувати:** \n- **Глобальні налаштування**: Коли потрібно передати налаштування, які використовуються в багатьох компонентах (наприклад, тема, мова). \n- **Дані автентифікації**: Для зберігання інформації про поточного користувача та його статус автентифікації. \n- **Загальні функції**: Коли потрібно передати функції або методи, які використовуються в багатьох компонентах (наприклад, функція для відкриття модального вікна). \n\n**Приклад використання:** \n```jsx \nimport React, { createContext, useContext } from 'react'; \nconst ThemeContext = createContext('light'); // Створення контексту з дефолтним значенням 'light' \nfunction ThemedComponent() { \n  const theme = useContext(ThemeContext); // Використання контексту \n  return <div className={`theme-${theme}`}>Тема: {theme}</div>; \n} \nfunction App() { \n  return ( \n    <ThemeContext.Provider value=\"dark\"> {/* Передача значення контексту */} \n      <ThemedComponent /> \n    </ThemeContext.Provider> \n  ); \n} \n```",
    "additionalQuestions": [
      {
        "id": "react-q25-aq1",
        "question": "Чи можна використовувати Context для управління станом?",
        "answer": "Так, Context може бути використаний для управління станом, але він не є заміною для систем управління станом (наприклад, Redux, Zustand). Context краще підходить для глобальних даних, які не змінюються часто, оскільки часті зміни контексту можуть призводити до непотрібних повторних рендерингів компонентів, які його використовують."
      },
      {
        "id": "react-q25-aq2",
        "question": "Чи можна використовувати кілька контекстів у одному компоненті?",
        "answer": "Так, ви можете використовувати кілька контекстів у одному компоненті, просто імпортуючи та використовуючи їх окремо. Це дозволяє комбінувати різні глобальні дані в одному компоненті."
      },
      {
        "id": "react-q25-aq3",
        "question": "Які є альтернативи React Context для управління глобальним станом?",
        "answer": "Альтернативами React Context для управління глобальним станом є системи управління станом, такі як Redux, Zustand, Recoil, MobX або використання хуків, таких як `useReducer` у поєднанні з Context."
      }
    ]
  },
  {
    "id": "react-q26",
    "topic": "React",
    "mainQuestion": "Що таке React.memo і для чого він використовується?",
    "mainAnswer": "**React.memo** — це вищий порядок компонент (Higher Order Component, HOC), який дозволяє оптимізувати продуктивність функціональних компонентів, запобігаючи їхньому повторному рендерингу, якщо їхні `props` не змінилися. Це корисно для компонентів, які отримують однакові `props` і не потребують повторного рендерингу при кожному оновленні батьківського компонента. \n**Як працює:** \n- `React.memo` порівнює попередні та нові `props` компонента. Якщо `props` не змінилися, компонент не буде перерендерено. \n- Ви можете передати власну функцію порівняння як другий аргумент до `React.memo`, щоб визначити, чи потрібно перерендерювати компонент на основі специфічних умов. \n\n**Приклад використання:** \n```jsx \nimport React from 'react'; \nconst MyComponent = React.memo(({ value }) => { \n  console.log('Рендеринг MyComponent'); \n  return <div>{value}</div>; \n}); \n``` \nУ цьому прикладі `MyComponent` буде перерендерено лише тоді, коли зміниться `value`. Якщо батьківський компонент оновиться з іншими `props`, але `value` залишиться незмінним, `MyComponent` не буде перерендерено.",
    "additionalQuestions": [
      {
        "id": "react-q26-aq1",
        "question": "Чи можна використовувати React.memo з класовими компонентами?",
        "answer": "Ні, `React.memo` призначений лише для функціональних компонентів. Для класових компонентів можна використовувати методи життєвого циклу, такі як `shouldComponentUpdate`, для оптимізації рендерингу."
      },
      {
        "id": "react-q26-aq2",
        "question": "Чи впливає React.memo на продуктивність у всіх випадках, чи є ситуації, коли його не варто використовувати?",
        "answer": "React.memo може покращити продуктивність, але не завжди. Якщо компонент часто отримує нові `props`, або якщо порівняння `props` є дорогим, використання `React.memo` може навіть погіршити продуктивність через додаткові витрати на порівняння. Тому його варто використовувати лише для компонентів, які отримують стабільні `props` і не потребують частого оновлення."
      },
      {
        "id": "react-q26-aq3",
        "question": "Як React.memo взаємодіє з хуками, такими як useState або useEffect?",
        "answer": "`React.memo` не впливає на роботу хуків, таких як `useState` або `useEffect`. Хуки все ще працюватимуть у межах компонента, і їхній стан буде збережено між рендерами. Однак, якщо `props` компонента не змінюються, то компонент не буде перерендерено, що може призвести до того, що хуки не будуть викликані знову."
      }
    ]
  },
  {
    "id": "react-q27",
    "topic": "React",
    "mainQuestion": "Що таке React Suspense і для чого він використовується?",
    "mainAnswer": "**React Suspense** — це функція, яка дозволяє відкладати рендеринг компонентів до тих пір, поки не будуть завантажені необхідні дані або ресурси. Це особливо корисно для асинхронного завантаження даних, таких як запити до API, або для динамічного імпорту компонентів. \n**Основні можливості:** \n- **Асинхронне завантаження даних**: Дозволяє 'захоплювати' стан завантаження та показувати запасний контент (наприклад, спінер) під час очікування на дані. \n- **Динамічний імпорт компонентів**: Дозволяє відкладати завантаження компонентів до моменту їхнього використання, що може зменшити початковий розмір бандлу. \n\n**Приклад використання:** \n```jsx \nimport React, { Suspense, lazy } from 'react'; \nconst LazyComponent = lazy(() => import('./LazyComponent')); // Динамічний імпорт компонента \nfunction App() { \n  return ( \n    <Suspense fallback={<div>Завантаження...</div>}> {/* Запасний контент */} \n      <LazyComponent /> \n    </Suspense> \n  ); \n} \n``` \nУ цьому прикладі `LazyComponent` буде завантажено асинхронно, а поки він завантажується, буде показано текст 'Завантаження...'.",
    "additionalQuestions": [
      {
        "id": "react-q27-aq1",
        "question": "Чи можна використовувати Suspense без React.lazy?",
        "answer": "Так, Suspense можна використовувати з будь-яким асинхронним кодом, який підтримує 'захоплення' стану завантаження. Наприклад, ви можете використовувати його з асинхронними запитами до API, якщо ви створите власний механізм для 'захоплення' стану завантаження. Однак, React.lazy є найбільш поширеним способом використання Suspense."
      },
      {
        "id": "react-q27-aq2",
        "question": "Чи підтримує Suspense серверний рендеринг (SSR)?",
        "answer": "Так, Suspense підтримує серверний рендеринг, але для цього потрібна спеціальна конфігурація та використання `ReactDOMServer.renderToPipeableStream` або `ReactDOMServer.renderToString` з відповідними опціями. Це дозволяє серверу віддавати HTML, який містить запасний контент, поки асинхронні компоненти завантажуються."
      },
      {
        "id": "react-q27-aq3",
        "question": "Які є обмеження при використанні React Suspense?",
        "answer": "Одне з основних обмежень — це те, що Suspense працює лише з асинхронними компонентами або даними, які підтримують 'захоплення' стану завантаження. Крім того, Suspense не може бути використаний для синхронних компонентів або даних, які вже доступні на момент рендерингу."
      }
    ]
  },
  {
    "id": "react-q28",
    "topic": "React",
    "mainQuestion": "Що таке React Server Components і як вони відрізняються від звичайних компонентів?",
    "mainAnswer": "**React Server Components** (RSC) — це новий тип компонентів у React, які дозволяють виконувати рендеринг на сервері. Вони дозволяють розробникам створювати компоненти, які можуть виконувати асинхронні запити до бази даних або API без необхідності передавати дані через клієнтський JavaScript. \n**Основні особливості:** \n- **Рендеринг на сервері**: Компоненти RSC рендеряться на сервері, що дозволяє зменшити обсяг JavaScript, який потрібно завантажити на клієнт. \n- **Асинхронність**: RSC можуть виконувати асинхронні запити до бази даних або API без блокування рендерингу. \n- **Відсутність стану**: RSC не мають стану (state) та життєвого циклу, оскільки вони призначені для рендерингу на сервері. \n\n**Приклад використання:** \n```jsx \n// Це псевдокод, оскільки RSC ще не є стабільною частиною React на момент написання цієї відповіді. \nimport { createServerComponent } from 'react'; \nconst MyServerComponent = createServerComponent(async () => { \n  const data = await fetchDataFromAPI(); // Асинхронний запит до API \n  return <div>{data}</div>; // Рендеринг даних на сервері \n}); \n``` \nУ цьому прикладі `MyServerComponent` виконує асинхронний запит до API та рендерить отримані дані на сервері.",
    "additionalQuestions": [
      {
        "id": "react-q28-aq1",
        "question": "Чи можна використовувати хуки в React Server Components?",
        "answer": "Ні, React Server Components не підтримують хуки, оскільки вони не мають стану (state) та життєвого циклу. Вони призначені лише для рендерингу даних на сервері."
      },
      {
        "id": "react-q28-aq2",
        "question": "Як React Server Components впливають на продуктивність застосунку?",
        "answer": "React Server Components можуть значно покращити продуктивність застосунку, оскільки вони дозволяють зменшити обсяг JavaScript, який потрібно завантажити на клієнт. Це може призвести до швидшого рендерингу та кращого користувацького досвіду, особливо для великих застосунків з багатьма компонентами."
      },
      {
        "id": "react-q28-aq3",
        "question": "Чи можна використовувати React Server Components разом з клієнтськими компонентами?",
        "answer": "Так, React Server Components можуть бути використані разом з клієнтськими компонентами. Ви можете створювати гібридні застосунки, де деякі компоненти рендеряться на сервері, а інші — на клієнті, що дозволяє оптимізувати продуктивність та користувацький досвід."
      }
    ]
  },
  {
    "id": "react-q29",
    "topic": "React",
    "mainQuestion": "Що таке React Strict Mode і для чого він використовується?",
    "mainAnswer": "**React Strict Mode** — це інструмент для виявлення потенційних проблем у React-застосунках. Він не впливає на рендеринг, але активує додаткові перевірки та попередження для компонентів, що допомагає розробникам виявляти небезпечні практики та помилки. \n**Основні можливості:** \n- **Виявлення небезпечних методів життєвого циклу**: Попереджає про використання застарілих методів життєвого циклу, таких як `componentWillMount`, `componentWillReceiveProps` та `componentWillUpdate`. \n- **Перевірка наявності ключів у списках**: Перевіряє, чи всі елементи в масивах мають унікальні ключі. \n- **Виявлення побічних ефектів**: Перевіряє, чи компоненти не мають побічних ефектів у методах рендерингу. \n- **Дублювання викликів методів**: Дублює виклики методів життєвого циклу (наприклад, `render`) для виявлення проблем з чистотою компонентів. \n\n**Приклад використання:** \n```jsx \nimport React from 'react'; \nfunction App() { \n  return ( \n    <React.StrictMode> {/* Обгортання застосунку в Strict Mode */} \n      <MyComponent /> \n    </React.StrictMode> \n  ); \n} \n```",
    "additionalQuestions": [
      {
        "id": "react-q29-aq1",
        "question": "Чи впливає Strict Mode на продуктивність застосунку?",
        "answer": "Strict Mode може незначно вплинути на продуктивність під час розробки, оскільки він дублює виклики методів життєвого циклу для виявлення проблем. Однак у продакшн-збірці ці перевірки вимкнені, тому вони не впливають на продуктивність кінцевого застосунку."
      },
      {
        "id": "react-q29-aq2",
        "question": "Чи можна використовувати Strict Mode з класовими компонентами?",
        "answer": "Так, Strict Mode працює як з функціональними, так і з класовими компонентами. Він перевіряє всі компоненти, незалежно від їхнього типу."
      },
      {
        "id": "react-q29-aq3",
        "question": "Чи можна використовувати Strict Mode в продакшн-збірці?",
        "answer": "Strict Mode призначений для використання лише в режимі розробки. У продакшн-збірці він не має сенсу, оскільки всі перевірки вимкнені. Тому його слід використовувати лише під час розробки для виявлення потенційних проблем."
      }
    ]
  }
]