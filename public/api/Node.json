[
  {
    "id": "node-q01",
    "topic": "Node.js",
    "mainQuestion": "Що таке Node.js та для чого він використовується?",
    "mainAnswer": "Node.js – це кросплатформове середовище виконання JavaScript, побудоване на рушії V8 від Google Chrome. Він дозволяє виконувати JavaScript код поза браузером, переважно для розробки серверних додатків, інструментів командного рядка та настільних програм.",
    "additionalQuestions": [
      {
        "id": "node-q01-aq1",
        "question": "Які основні переваги Node.js?",
        "answer": "Серед основних переваг Node.js – висока продуктивність завдяки асинхронній, подієво-орієнтованій архітектурі, легкість вивчення для JS-розробників, велика екосистема пакетів (npm) та можливість використання JavaScript як для фронтенду, так і для бекенду."
      },
      {
        "id": "node-q01-aq2",
        "question": "Які типові сценарії використання Node.js?",
        "answer": "Node.js часто використовується для створення RESTful API, мікросервісів, чатів у реальному часі (з WebSocket), потокових додатків, інструментів розробки (збірки, автоматизація) та server-side рендерингу."
      },
      {
        "id": "node-q01-aq3",
        "question": "Чи є Node.js однопоточним чи багатопоточним?",
        "answer": "Node.js є однопоточним для виконання коду, що є його ключовою особливістю. Він використовує цикл подій (Event Loop) для обробки асинхронних операцій, що дозволяє йому обробляти велику кількість паралельних з'єднань без використання багатьох потоків."
      }
    ]
  },
  {
    "id": "node-q02",
    "topic": "Node.js",
    "mainQuestion": "Поясніть концепцію Event Loop у Node.js.",
    "mainAnswer": "Event Loop – це фундаментальна частина архітектури Node.js, яка забезпечує неблокуючий I/O (введення/виведення). Він постійно перевіряє чергу подій і виконує зворотні виклики (callbacks) для завершених асинхронних операцій, дозволяючи Node.js обробляти паралельні запити ефективно, не блокуючи основний потік.",
    "additionalQuestions": [
      {
        "id": "node-q02-aq1",
        "question": "Які фази має Event Loop?",
        "answer": "Event Loop має кілька фаз: timers (setTimeout, setInterval), pending callbacks (відкладені callback-и I/O), idle, prepare, poll (виконання I/O callback-ів та перевірка нових I/O подій), check (setImmediate) та close callbacks (обробка закриття)."
      },
      {
        "id": "node-q02-aq2",
        "question": "Чим відрізняються process.nextTick() та setImmediate()?",
        "answer": "process.nextTick() виконується негайно після завершення поточної операції, але перед наступною фазою Event Loop. setImmediate() виконується в окремій фазі Event Loop (check phase) після фази poll."
      },
      {
        "id": "node-q02-aq3",
        "question": "Як Event Loop запобігає блокуванню основного потоку?",
        "answer": "Він виносить трудомісткі операції (наприклад, I/O) до системного ядра або робочих потоків (за допомогою libuv), а потім додає їхні зворотні виклики до черги подій. Основний потік продовжує працювати, а коли операція завершується, Event Loop повертає її результат через callback."
      }
    ]
  },
  {
    "id": "node-q03",
    "topic": "Node.js",
    "mainQuestion": "Що таке npm та для чого він потрібен?",
    "mainAnswer": "npm (Node Package Manager) – це менеджер пакетів за замовчуванням для Node.js. Він використовується для встановлення, керування та публікації пакетів (бібліотек, модулів) JavaScript, що дозволяє розробникам легко обмінюватися кодом і використовувати чужі рішення у своїх проектах.",
    "additionalQuestions": [
      {
        "id": "node-q03-aq1",
        "question": "Яка різниця між залежностями (dependencies) та devDependencies у package.json?",
        "answer": "Залежності (dependencies) – це пакети, необхідні для роботи програми у продакшені. devDependencies – це пакети, які потрібні тільки під час розробки (наприклад, для тестування, збірки, лінтингу)."
      },
      {
        "id": "node-q03-aq2",
        "question": "Що таке package-lock.json і для чого він потрібен?",
        "answer": "package-lock.json – це файл, який автоматично генерується npm і фіксує точні версії всіх встановлених залежностей (включно з підзалежностями). Це забезпечує детерміновану інсталяцію, тобто гарантує, що на різних машинах або в різний час будуть встановлені абсолютно однакові версії пакетів."
      },
      {
        "id": "node-q03-aq3",
        "question": "Як оновити всі пакети у проекті за допомогою npm?",
        "answer": "Для оновлення всіх пакетів можна використовувати команду `npm update`. Для інтерактивного оновлення певних пакетів можна скористатися `npm outdated` для перегляду застарілих пакетів та `npm install <package-name>@latest` для оновлення конкретного пакета."
      }
    ]
  },
  {
    "id": "node-q04",
    "topic": "Node.js",
    "mainQuestion": "Опишіть архітектуру модулів у Node.js.",
    "mainAnswer": "Node.js реалізує CommonJS модульну систему. Кожен файл у Node.js вважається окремим модулем. Для експорту функціоналу з модуля використовується `module.exports` або `exports`, а для імпорту – `require()`. Це дозволяє організовувати код у невеликі, повторно використовувані блоки.",
    "additionalQuestions": [
      {
        "id": "node-q04-aq1",
        "question": "Яка різниця між `module.exports` та `exports`?",
        "answer": "`module.exports` – це об'єкт, який повертається `require()` при імпорті модуля. `exports` – це посилання на `module.exports`. Якщо ви безпосередньо присвоюєте `exports` новий об'єкт, посилання розривається, і `module.exports` не буде змінено. Завжди краще використовувати `module.exports` для експорту одного значення або об'єкта."
      },
      {
        "id": "node-q04-aq2",
        "question": "Як працює механізм кешування модулів у Node.js?",
        "answer": "Node.js кешує завантажені модулі. При першому `require()` модуль компілюється і виконується, а результат кешується. При подальших `require()` того ж модуля повертається кешована версія, що прискорює запуск і запобігає повторному виконанню коду."
      },
      {
        "id": "node-q04-aq3",
        "question": "Чи підтримує Node.js ES Modules (ESM)?",
        "answer": "Так, сучасні версії Node.js підтримують ES Modules. Їх можна використовувати, встановивши `'type': 'module'` у package.json або використовуючи розширення файлу `.mjs`. Це дозволяє використовувати синтаксис `import`/`export`."
      }
    ]
  },
  {
    "id": "node-q05",
    "topic": "Node.js",
    "mainQuestion": "Що таке Express.js і навіщо він потрібен?",
    "mainAnswer": "Express.js – це мінімалістичний і гнучкий фреймворк для веб-додатків Node.js, який надає надійний набір функцій для розробки веб-додатків і API. Він спрощує обробку HTTP-запитів, маршрутизацію, проміжне ПЗ (middleware) і багато іншого.",
    "additionalQuestions": [
      {
        "id": "node-q05-aq1",
        "question": "Що таке Middleware в Express.js?",
        "answer": "Middleware – це функції, які мають доступ до об'єктів запиту (req), відповіді (res) та наступної функції middleware у циклі 'запит-відповідь'. Вони можуть виконувати код, змінювати об'єкти запиту/відповіді, завершувати цикл запиту/відповіді або викликати наступний middleware."
      },
      {
        "id": "node-q05-aq2",
        "question": "Як працює маршрутизація (routing) в Express.js?",
        "answer": "Маршрутизація в Express.js визначає, як додаток реагує на клієнтський запит до певної кінцевої точки (URI) та методу HTTP (GET, POST тощо). Вона використовує методи, такі як `app.get()`, `app.post()`, для асоціації шляхів URL з функціями-обробниками."
      },
      {
        "id": "node-q05-aq3",
        "question": "Назвіть кілька популярних пакетів, які використовуються з Express.js.",
        "answer": "Популярні пакети включають `body-parser` (для розбору тіла запиту), `cors` (для обробки CORS запитів), `helmet` (для безпеки HTTP-заголовків), `mongoose` (для роботи з MongoDB), `passport` (для автентифікації)."
      }
    ]
  },
  {
    "id": "node-q06",
    "topic": "Node.js",
    "mainQuestion": "Поясніть різницю між асинхронним та синхронним кодом у Node.js.",
    "mainAnswer": "Синхронний код виконується послідовно, рядок за рядком. Кожна операція повинна завершитися, перш ніж почнеться наступна, що може призвести до блокування основного потоку. Асинхронний код не блокує основний потік. Операції запускаються у фоновому режимі, а callback-функції викликаються, коли операція завершується, дозволяючи іншим завданням виконуватися паралельно.",
    "additionalQuestions": [
      {
        "id": "node-q06-aq1",
        "question": "Які механізми використовуються для роботи з асинхронністю в Node.js?",
        "answer": "Основними механізмами є зворотні виклики (callbacks), Проміси (Promises) та синтаксис `async/await`."
      },
      {
        "id": "node-q06-aq2",
        "question": "Що таке 'Callback Hell' і як його уникнути?",
        "answer": "'Callback Hell' (або 'піраміда смерті') – це ситуація, коли у вас є багато вкладених callback-функцій, що робить код важким для читання та підтримки. Його можна уникнути за допомогою Промісів (Promisify), `async/await` або іменованих функцій."
      },
      {
        "id": "node-q06-aq3",
        "question": "Коли варто використовувати синхронний код у Node.js?",
        "answer": "Синхронний код варто використовувати лише для неблокуючих операцій, які є критично важливими для негайного виконання (наприклад, читання конфігураційного файлу під час запуску програми), або коли немає альтернативи. Загалом, для операцій I/O завжди краще використовувати асинхронний підхід."
      }
    ]
  },
  {
    "id": "node-q07",
    "topic": "Node.js",
    "mainQuestion": "Що таке буфери (Buffers) у Node.js?",
    "mainAnswer": "Буфери в Node.js – це тимчасові області пам'яті, які дозволяють працювати з бінарними даними безпосередньо. Вони використовуються для обробки потоків даних, таких як читання файлів, мережеві запити, зображення тощо. Об'єкт `Buffer` є глобальним і не потребує імпорту `require('buffer')`.",
    "additionalQuestions": [
      {
        "id": "node-q07-aq1",
        "question": "Наведіть приклад використання Buffer.",
        "answer": "```javascript\nconst buf = Buffer.from('Привіт, світ!');\nconsole.log(buf.toString()); // Привіт, світ!\nconsole.log(buf.length); // 21 (кількість байтів)\nconst anotherBuf = Buffer.alloc(10); // Створює буфер розміром 10 байтів, заповнений нулями\n```"
      },
      {
        "id": "node-q07-aq2",
        "question": "Чим відрізняється `Buffer.from()` від `Buffer.alloc()`?",
        "answer": "`Buffer.from()` створює буфер, заповнений з переданих даних (наприклад, рядок, масив байтів). `Buffer.alloc()` створює буфер вказаного розміру і заповнює його нулями за замовчуванням, що є більш безпечним, ніж `Buffer.allocUnsafe()`."
      },
      {
        "id": "node-q07-aq3",
        "question": "Для чого використовуються буфери в Node.js?",
        "answer": "Буфери використовуються для роботи з двійковими даними в мережевих протоколах (TCP/UDP), файлових системах, криптографічних операціях, обробці зображень та інших бінарних даних."
      }
    ]
  },
  {
    "id": "node-q08",
    "topic": "Node.js",
    "mainQuestion": "Поясніть концепцію потоків (Streams) у Node.js.",
    "mainAnswer": "Потоки (Streams) – це абстрактний інтерфейс у Node.js для роботи з даними, що надходять або відправляються частинами. Вони дозволяють обробляти великі обсяги даних ефективно, не завантажуючи їх повністю у пам'ять, що значно покращує продуктивність та використання ресурсів.",
    "additionalQuestions": [
      {
        "id": "node-q08-aq1",
        "question": "Які існують типи потоків у Node.js?",
        "answer": "Існує чотири основні типи потоків: Readable (для читання даних), Writable (для запису даних), Duplex (для читання та запису, наприклад, сокети) та Transform (для зміни даних під час читання/запису, наприклад, стиснення)."
      },
      {
        "id": "node-q08-aq2",
        "question": "Що таке метод `pipe()` і для чого він використовується?",
        "answer": "Метод `pipe()` використовується для зв'язування вихідного потоку (readable stream) з вхідним потоком (writable stream). Він автоматично керує потоком даних, передаючи їх частинами від одного потоку до іншого, що спрощує роботу з даними і запобігає переповненню буфера."
      },
      {
        "id": "node-q08-aq3",
        "question": "Які переваги використання потоків?",
        "answer": "Переваги включають ефективне використання пам'яті (обробка даних частинами), підвищену продуктивність (дані обробляються, як тільки вони стають доступними) та кращу композиційність коду, оскільки потоки легко поєднуються."
      }
    ]
  },
  {
    "id": "node-q09",
    "topic": "Node.js",
    "mainQuestion": "Як обробляти помилки в асинхронному коді Node.js?",
    "mainAnswer": "Для обробки помилок в асинхронному коді Node.js використовуються різні підходи: перевірка помилок у callback-функціях (традиційний підхід), блоки `try...catch` з `async/await` та обробка відхилених промісів (`.catch()`). Важливо не забувати про обробку неперехоплених винятків за допомогою `process.on('uncaughtException')` та `process.on('unhandledRejection')` для стабільності додатку.",
    "additionalQuestions": [
      {
        "id": "node-q09-aq1",
        "question": "Наведіть приклад обробки помилок за допомогою callback-функцій.",
        "answer": "```javascript\nfs.readFile('/path/to/file.txt', (err, data) => {\n  if (err) {\n    console.error('Помилка читання файлу:', err);\n    return;\n  }\n  console.log(data.toString());\n});\n```"
      },
      {
        "id": "node-q09-aq2",
        "question": "Як обробляти помилки за допомогою `async/await`?",
        "answer": "```javascript\nasync function readFileContent() {\n  try {\n    const data = await fs.promises.readFile('/path/to/file.txt');\n    console.log(data.toString());\n  } catch (error) {\n    console.error('Помилка читання файлу:', error);\n  }\n}\nreadFileContent();\n```"
      },
      {
        "id": "node-q09-aq3",
        "question": "Яка різниця між `uncaughtException` та `unhandledRejection`?",
        "answer": "`uncaughtException` виникає, коли синхронний код викидає помилку, яка не була перехоплена блоком `try...catch`. `unhandledRejection` виникає, коли Promise відхиляється, і для цього відхилення немає обробника `.catch()`."
      }
    ]
  },
  {
    "id": "node-q10",
    "topic": "Node.js",
    "mainQuestion": "Що таке Worker Threads у Node.js?",
    "mainAnswer": "Worker Threads – це функція Node.js, яка дозволяє виконувати інтенсивні для ЦП операції (наприклад, складні обчислення, хешування) у паралельних потоках, не блокуючи основний Event Loop. Це допомагає зберегти реактивність основного потоку для обробки I/O операцій.",
    "additionalQuestions": [
      {
        "id": "node-q10-aq1",
        "question": "Коли варто використовувати Worker Threads?",
        "answer": "Їх варто використовувати, коли потрібно виконувати тривалі, блокуючі або обчислювально-інтенсивні операції, які могли б заблокувати основний потік і уповільнити додаток, особливо серверні, що обробляють багато запитів."
      },
      {
        "id": "node-q10-aq2",
        "question": "Чи Worker Threads використовують окремі процеси?",
        "answer": "Ні, Worker Threads використовують окремі потоки в межах того самого процесу Node.js, а не окремі процеси, як у випадку з модулем `cluster`. Це дозволяє їм ділити деякі ресурси, але кожен потік має власне середовище V8."
      },
      {
        "id": "node-q10-aq3",
        "question": "Як Worker Threads обмінюються даними?",
        "answer": "Вони обмінюються даними через надсилання повідомлень (message passing) за допомогою методів `postMessage()` та `on('message')`. Також можна передавати `SharedArrayBuffer` або `MessageChannel` для більш складних сценаріїв обміну."
      }
    ]
  },
  {
    "id": "node-q11",
    "topic": "Node.js",
    "mainQuestion": "Що таке кластеризація (Clustering) у Node.js?",
    "mainAnswer": "Кластеризація в Node.js дозволяє створювати кілька 'робочих' процесів (workers), які діляться одним і тим же сервером. Кожен робочий процес є окремим екземпляром Node.js, що працює на власному ядрі процесора. Це дозволяє використовувати всі ядра ЦП для масштабування додатку та підвищення його відмовостійкості.",
    "additionalQuestions": [
      {
        "id": "node-q11-aq1",
        "question": "Для чого потрібен модуль `cluster`?",
        "answer": "Модуль `cluster` використовується для створення дочірніх процесів-воркерів, які можуть спільно використовувати серверний порт. Він дозволяє Node.js додатку ефективно використовувати багатоядерні процесори."
      },
      {
        "id": "node-q11-aq2",
        "question": "Яка різниця між `cluster` та `worker_threads`?",
        "answer": "`cluster` створює окремі процеси, кожен зі своїм Event Loop і пам'яттю, що забезпечує кращу відмовостійкість. `worker_threads` створює потоки в одному процесі, які мають доступ до тієї ж пам'яті, що корисно для CPU-інтенсивних обчислень без блокування I/O, але менш відмовостійке."
      },
      {
        "id": "node-q11-aq3",
        "question": "Як кластеризація допомагає у відмовостійкості?",
        "answer": "Якщо один з робочих процесів вийде з ладу, інші продовжать працювати, і майстер-процес може перезапустити збійний воркер, забезпечуючи високу доступність додатку."
      }
    ]
  },
  {
    "id": "node-q12",
    "topic": "Node.js",
    "mainQuestion": "Поясніть, що таке REPL у Node.js.",
    "mainAnswer": "REPL (Read-Eval-Print Loop) – це інтерактивне середовище програмування, яке постачається з Node.js. Воно дозволяє виконувати JavaScript код рядок за рядком, отримувати негайний результат, експериментувати з кодом та перевіряти синтаксис без необхідності створювати та запускати файли.",
    "additionalQuestions": [
      {
        "id": "node-q12-aq1",
        "question": "Як запустити REPL у Node.js?",
        "answer": "Щоб запустити REPL, достатньо ввести `node` у терміналі та натиснути Enter."
      },
      {
        "id": "node-q12-aq2",
        "question": "Які команди можна використовувати в REPL?",
        "answer": "Крім виконання JavaScript коду, можна використовувати такі команди: `.help` (показати всі команди), `.exit` (вийти з REPL), `.save <filename>` (зберегти поточну сесію в файл), `.load <filename>` (завантажити файл у поточну сесію) та інші."
      },
      {
        "id": "node-q12-aq3",
        "question": "Для чого REPL корисний розробнику?",
        "answer": "REPL корисний для швидкого тестування фрагментів коду, експериментів з новими API, відлагодження невеликих проблем та вивчення особливостей Node.js без необхідності постійно перезапускати додаток."
      }
    ]
  },
  {
    "id": "node-q13",
    "topic": "Node.js",
    "mainQuestion": "Як забезпечити безпеку Node.js додатків?",
    "mainAnswer": "Безпека Node.js додатків передбачає захист від поширених вразливостей, таких як ін'єкції (SQL, NoSQL, XSS), CSRF, маніпуляції з даними. Це досягається за допомогою валідації вхідних даних, використання безпечних фреймворків (Express.js з Helmet), оновлення залежностей, автентифікації/авторизації, хешування паролів та надійного керування секретами.",
    "additionalQuestions": [
      {
        "id": "node-q13-aq1",
        "question": "Які NPM-пакети допомагають у забезпеченні безпеки?",
        "answer": "Популярні пакети: `helmet` (для набору HTTP-заголовків, що посилюють безпеку), `cors` (для контролю CORS), `express-rate-limit` (для обмеження кількості запитів), `bcrypt` (для хешування паролів), `passport` (для автентифікації)."
      },
      {
        "id": "node-q13-aq2",
        "question": "Що таке OWASP Top 10 і як це стосується Node.js?",
        "answer": "OWASP Top 10 – це список 10 найкритичніших ризиків безпеки веб-додатків. Node.js додатки, як і будь-які інші, можуть бути вразливими до цих ризиків (наприклад, ін'єкції, broken authentication, sensitive data exposure), тому необхідно враховувати ці рекомендації під час розробки."
      },
      {
        "id": "node-q13-aq3",
        "question": "Чому важливо валідувати вхідні дані на сервері?",
        "answer": "Валідація вхідних даних на сервері критично важлива, оскільки дані з клієнта завжди є ненадійними. Вона запобігає ін'єкціям, переповненням буфера, несанкціонованим операціям та іншим атакам, забезпечуючи цілісність і безпеку даних на стороні сервера."
      }
    ]
  },
  {
    "id": "node-q14",
    "topic": "Node.js",
    "mainQuestion": "Як керувати конфігурацією Node.js додатків?",
    "mainAnswer": "Керування конфігурацією в Node.js передбачає розділення конфігураційних параметрів (наприклад, підключення до бази даних, API-ключі) від коду. Часто використовуються змінні середовища, файли `.env` (з пакетом `dotenv`), або спеціалізовані конфігураційні бібліотеки (наприклад, `config`, `nconf`) для різних середовищ (розробка, тестування, продакшен).",
    "additionalQuestions": [
      {
        "id": "node-q14-aq1",
        "question": "Чому не варто зберігати секрети безпосередньо в коді?",
        "answer": "Зберігання секретів (паролів, API-ключів) безпосередньо в коді є небезпечним, оскільки вони можуть бути легко викрадені через систему контролю версій (Git), компрометацію репозиторію або якщо код потрапить до несанкціонованих осіб."
      },
      {
        "id": "node-q14-aq2",
        "question": "Як використовувати змінні середовища для конфігурації?",
        "answer": "Змінні середовища встановлюються на рівні операційної системи або у скрипті запуску програми (наприклад, `PORT=3000 node app.js`). У Node.js до них можна отримати доступ через об'єкт `process.env` (наприклад, `process.env.PORT`)."
      },
      {
        "id": "node-q14-aq3",
        "question": "Що таке пакет `dotenv` і для чого він потрібен?",
        "answer": "Пакет `dotenv` завантажує змінні середовища з файлу `.env` у `process.env`. Це зручно для локальної розробки, оскільки дозволяє зберігати конфігурацію в корені проекту, не комітячи її в систему контролю версій."
      }
    ]
  },
  {
    "id": "node-q15",
    "topic": "Node.js",
    "mainQuestion": "Як масштабувати Node.js додатки?",
    "mainAnswer": "Масштабування Node.js додатків може бути вертикальним (збільшення ресурсів одного сервера – ЦП, пам'ять) або горизонтальним (додавання більшої кількості серверів/процесів). Горизонтальне масштабування в Node.js досягається за допомогою кластеризації (module `cluster`), розподілу навантаження (load balancing) та мікросервісної архітектури.",
    "additionalQuestions": [
      {
        "id": "node-q15-aq1",
        "question": "Що таке Load Balancing і як він допомагає масштабувати Node.js?",
        "answer": "Load Balancing (балансування навантаження) – це розподіл вхідного мережевого трафіку між кількома серверами або екземплярами додатку. Він допомагає масштабувати Node.js, рівномірно розподіляючи запити між воркерами кластера або окремими серверами, підвищуючи продуктивність і відмовостійкість."
      },
      {
        "id": "node-q15-aq2",
        "question": "Які інструменти використовуються для розгортання та масштабування Node.js?",
        "answer": "Популярні інструменти включають Docker (для контейнеризації), Kubernetes (для оркестрації контейнерів), PM2 (для управління процесами Node.js у продакшені), Nginx (як реверс-проксі та балансувальник навантаження) та хмарні платформи (AWS, Google Cloud, Azure)."
      },
      {
        "id": "node-q15-aq3",
        "question": "Чи є Node.js масштабованим?",
        "answer": "Так, Node.js дуже добре масштабується, особливо для I/O-інтенсивних додатків, завдяки своїй асинхронній, подієво-орієнтованій архітектурі. Його однопотокова природа для виконання JS коду, в поєднанні з Event Loop та можливостями кластеризації/Worker Threads, робить його чудовим вибором для високопродуктивних та масштабованих систем."
      }
    ]
  }
]