[
  {
    "id": "js-q1",
    "topic": "JavaScript",
    "mainQuestion": "Що таке глобальний об'єкт (global object)?",
    "mainAnswer": "Глобальний об'єкт — це об'єкт, який завжди доступний у глобальній області видимості JavaScript. У браузері це об'єкт `window`, а в Node.js — `global`. Він містить глобальні змінні, функції та властивості, доступні з будь-якого місця коду.",
    "additionalQuestions": [
      {
        "id": "js-q1-aq1",
        "question": "Яка головна відмінність між `window` та `global`?",
        "answer": "`window` є глобальним об'єктом у середовищі браузера, що представляє вікно браузера та його вміст, тоді як `global` є глобальним об'єктом у середовищі Node.js, що представляє глобальний простір імен сервера."
      },
      {
        "id": "js-q1-aq2",
        "question": "Чи можна додавати властивості до глобального об'єкта?",
        "answer": "Так, глобальні змінні та функції, оголошені без `var`, `let` або `const` (у нестрогому режимі), стають властивостями глобального об'єкта. Однак це не є рекомендованою практикою."
      },
      {
        "id": "js-q1-aq3",
        "question": "Які типові глобальні властивості або функції ви знаєте?",
        "answer": "`setTimeout()`, `console.log()`, `parseInt()`, `isNaN()`, `Math`, `JSON` - це все глобальні функції або об'єкти, доступні через глобальний об'єкт."
      }
    ]
  },
  {
    "id": "js-q2",
    "topic": "JavaScript",
    "mainQuestion": "Що таке область видимості (scope)?",
    "mainAnswer": "Область видимості (scope) — це механізм, який визначає доступність змінних, функцій та об'єктів у певній частині коду. Вона контролює, де саме в коді ви можете посилатися на ці елементи. В JavaScript існують глобальна, функціональна (Function Scope) та блокова (Block Scope) області видимості.",
    "additionalQuestions": [
      {
        "id": "js-q2-aq1",
        "question": "У чому відмінність між функціональною та блоковою областю видимості?",
        "answer": "Функціональна область видимості означає, що змінні, оголошені за допомогою `var` всередині функції, доступні лише всередині цієї функції. Блокова область видимості (для `let` та `const`) означає, що змінні доступні лише всередині блоку коду (`{}`)."
      },
      {
        "id": "js-q2-aq2",
        "question": "Що таке 'Hoisting'?",
        "answer": "'Hoisting' — це механізм JavaScript, при якому оголошення змінних (оголошених за допомогою `var`) та функцій переміщуються вгору до початку їхньої області видимості під час компіляції, що дозволяє використовувати їх до фактичного оголошення в коді."
      },
      {
        "id": "js-q2-aq3",
        "question": "Який вплив `let` та `const` на hoisting?",
        "answer": "`let` та `const` також піднімаються (hoisted), але не ініціалізуються. Вони перебувають у 'тимчасовій мертвій зоні' (Temporal Dead Zone - TDZ) від початку їхньої області видимості до фактичного оголошення, що запобігає їх використанню до оголошення і викликає помилку."
      }
    ]
  },
  {
    "id": "js-q3",
    "topic": "JavaScript",
    "mainQuestion": "У чому різниця між `var`, `let` та `const`?",
    "mainAnswer": "`var` оголошує змінні з функціональною областю видимості (або глобальною), може бути перевизначений і переоголошений. `let` оголошує змінні з блоковою областю видимості, може бути перевизначений, але не переоголошений в одній області. `const` оголошує константи з блоковою областю видимості, не може бути перевизначений чи переоголошений, його значення не змінюється (для примітивних типів), а для об'єктів — не можна перевизначити посилання, але можна змінювати властивості об'єкта.",
    "additionalQuestions": [
      {
        "id": "js-q3-aq1",
        "question": "Яку ключове слово слід використовувати за замовчуванням і чому?",
        "answer": "За замовчуванням слід використовувати `const`, якщо значення змінної не повинно змінюватися. Якщо змінна повинна бути змінена, тоді використовувати `let`. `var` слід уникати через потенційні проблеми з областю видимості та hoisting."
      },
      {
        "id": "js-q3-aq2",
        "question": "Що означає 'блокова область видимості' для `let` та `const`?",
        "answer": "Це означає, що змінні, оголошені за допомогою `let` або `const`, доступні лише в межах найближчого блоку коду (наприклад, всередині `if` statement, `for` loop, або просто `{}`)."
      },
      {
        "id": "js-q3-aq3",
        "question": "Що станеться, якщо спробувати перепризначити `const` змінну?",
        "answer": "Буде викинута помилка `TypeError: Assignment to constant variable.`"
      }
    ]
  },
  {
    "id": "js-q4",
    "topic": "JavaScript",
    "mainQuestion": "У чому різниця між функціональним виразом (function expression) та оголошенням функції (function declaration)? Який з них використовувати?",
    "mainAnswer": "Оголошення функції (Function Declaration) — це функція, оголошена як окремий оператор (`function myFunction() {}`). Вона піднімається (hoisted), тому її можна викликати до її оголошення. Функціональний вираз (Function Expression) — це функція, яка є частиною виразу, часто присвоюється змінній (`const myFunction = function() {};`). Вона не піднімається і може бути викликана лише після її оголошення. Зазвичай краще використовувати функціональні вирази (особливо стрілкові функції) для більшої передбачуваності та уникнення проблем з hoisting.",
    "additionalQuestions": [
      {
        "id": "js-q4-aq1",
        "question": "Чи можна функціональний вираз бути іменованим?",
        "answer": "Так, функціональний вираз може бути іменованим (`const func = function myName() {};`). Це ім'я буде доступне лише всередині самої функції для рекурсії або налагодження."
      },
      {
        "id": "js-q4-aq2",
        "question": "Що таке 'стрілкові функції' і до якого типу вони належать?",
        "answer": "Стрілкові функції (Arrow Functions) — це більш короткий синтаксис для функціональних виразів (`const func = () => {};`). Вони завжди є анонімними функціональними виразами і не мають власного `this`."
      },
      {
        "id": "js-q4-aq3",
        "question": "Яка перевага використання функціональних виразів у порівнянні з оголошеннями?",
        "answer": "Функціональні вирази запобігають випадковому використанню функції до її оголошення (що може бути проблемою з hoisting) і дозволяють створювати анонімні функції, що часто корисно для колбеків."
      }
    ]
  },
  {
    "id": "js-q5",
    "topic": "JavaScript",
    "mainQuestion": "Що таке лексичне оточення (lexical environment)?",
    "mainAnswer": "Лексичне оточення — це внутрішній, прихований об'єкт, пов'язаний з кожною виконаною функцією або блоком коду в JavaScript. Воно містить інформацію про змінні та функції, які визначені в поточній області видимості, а також посилання на батьківське лексичне оточення. Це те, як JavaScript визначає, які змінні доступні в певному місці коду.",
    "additionalQuestions": [
      {
        "id": "js-q5-aq1",
        "question": "Як лексичне оточення пов'язане з областю видимості?",
        "answer": "Лексичне оточення *реалізує* концепцію області видимості в JavaScript. Кожна область видимості (глобальна, функціональна, блокова) має своє власне лексичне оточення."
      },
      {
        "id": "js-q5-aq2",
        "question": "Чи змінюється лексичне оточення під час виконання коду?",
        "answer": "Ні, лексичне оточення створюється під час *парсингу* (лексичного аналізу) коду і не змінюється під час його виконання. Саме це дозволяє замиканням 'запам'ятовувати' змінні з батьківської області."
      },
      {
        "id": "js-q5-aq3",
        "question": "Що таке 'ланцюжок областей видимості' (scope chain)?",
        "answer": "'Ланцюжок областей видимості' (або 'ланцюжок лексичних оточень') — це послідовність лексичних оточень, яка дозволяє JavaScript шукати змінну: спочатку в поточному оточенні, потім у батьківському, і так далі до глобального."
      }
    ]
  },
  {
    "id": "js-q6",
    "topic": "JavaScript",
    "mainQuestion": "Що таке контекст виконання (execution context)?",
    "mainAnswer": "Контекст виконання — це абстрактна концепція, яка оточує поточний запущений код. Кожного разу, коли JavaScript-код виконується, він робиться в рамках контексту виконання. Це середовище, в якому функція або глобальний код інтерпретується. Кожен контекст виконання має свою власну область видимості (змінні, функції) та власне значення `this`.",
    "additionalQuestions": [
      {
        "id": "js-q6-aq1",
        "question": "Які типи контекстів виконання існують?",
        "answer": "Основні типи: Глобальний контекст виконання (Global Execution Context) — для коду, що знаходиться поза функціями, та Функціональний контекст виконання (Function Execution Context) — для кожної викликаної функції."
      },
      {
        "id": "js-q6-aq2",
        "question": "Що таке 'Стек викликів' (Call Stack)?",
        "answer": "'Стек викликів' — це механізм, який JavaScript-інтерпретатор використовує для відстеження активних контекстів виконання. Коли функція викликається, її контекст виконання додається до стеку, і видаляється, коли функція завершує свою роботу."
      },
      {
        "id": "js-q6-aq3",
        "question": "Які компоненти входять до контексту виконання?",
        "answer": "До контексту виконання входять: Змінна середовище (Variable Environment) — де зберігаються змінні та оголошення функцій, Лексичне середовище (Lexical Environment) — для доступу до змінних батьківського скоупу, та значення `this`."
      }
    ]
  },
  {
    "id": "js-q7",
    "topic": "JavaScript",
    "mainQuestion": "Поясніть замикання (closures).",
    "mainAnswer": "Замикання (closure) — це функція, яка 'пам'ятає' своє лексичне оточення (змінні з батьківської області видимості), навіть якщо зовнішня функція вже завершила своє виконання. Це дозволяє внутрішній функції мати доступ до змінних зовнішньої функції, що робить її дуже потужним інструментом для приховування даних та створення функцій-фабрик.",
    "additionalQuestions": [
      {
        "id": "js-q7-aq1",
        "question": "Наведіть простий приклад замикання.",
        "answer": "`function makeCounter() { let count = 0; return function() { return count++; }; } const counter = makeCounter(); console.log(counter()); // 0 console.log(counter()); // 1`"
      },
      {
        "id": "js-q7-aq2",
        "question": "Які типові сценарії використання замикань?",
        "answer": "Замикання використовуються для приховування даних (data privacy/encapsulation), створення функцій-фабрик, каррінг-функцій, реалізації паттерну 'модуль' та для колбеків в асинхронному коді."
      },
      {
        "id": "js-q7-aq3",
        "question": "Чи може замикання впливати на продуктивність або використання пам'яті?",
        "answer": "Так, оскільки замикання тримає посилання на змінні з батьківської області, це може призвести до того, що ці змінні не будуть прибрані з пам'яті 'збирачем сміття' (garbage collector) так швидко, як могли б. Однак, зазвичай це не є значною проблемою, якщо замикання використовуються розумно."
      }
    ]
  },
  {
    "id": "js-q8",
    "topic": "JavaScript",
    "mainQuestion": "Що таке `this` у JavaScript? Як воно змінює своє значення? Як воно працює зі стрілковими функціями?",
    "mainAnswer": "`this` — це ключове слово, яке посилається на об'єкт, що 'володіє' поточним кодом, або на об'єкт, з яким функція була викликана. Його значення динамічно змінюється залежно від способу виклику функції (глобальний виклик, метод об'єкта, конструктор, явне прив'язування). Стрілкові функції не мають власного `this`; вони успадковують `this` з лексичного контексту (батьківської області видимості), де вони були визначені.",
    "additionalQuestions": [
      {
        "id": "js-q8-aq1",
        "question": "Як `this` поводиться при виклику функції як методу об'єкта?",
        "answer": "Коли функція викликається як метод об'єкта (наприклад, `myObject.myMethod()`), `this` всередині `myMethod` посилається на `myObject`."
      },
      {
        "id": "js-q8-aq2",
        "question": "Що таке 'явна прив'язка' `this`?",
        "answer": "'Явна прив'язка' — це коли значення `this` встановлюється за допомогою методів `call()`, `apply()` або `bind()`."
      },
      {
        "id": "js-q8-aq3",
        "question": "Яка перевага `this` у стрілкових функціях?",
        "answer": "Основна перевага в тому, що стрілкові функції вирішують проблему втрати контексту `this` у колбеках або вкладених функціях, оскільки вони автоматично захоплюють `this` з батьківського лексичного оточення."
      }
    ]
  },
  {
    "id": "js-q9",
    "topic": "JavaScript",
    "mainQuestion": "Поясніть методи `bind`, `call`, `apply`.",
    "mainAnswer": "Ці методи дозволяють явно встановлювати значення `this` для функції. `call()` викликає функцію негайно, передаючи аргументи окремо. `apply()` викликає функцію негайно, передаючи аргументи у вигляді масиву. `bind()` створює нову функцію з прив'язаним `this` (та аргументами), але не викликає її негайно.",
    "additionalQuestions": [
      {
        "id": "js-q9-aq1",
        "question": "Коли краще використовувати `call()` або `apply()` замість `bind()`?",
        "answer": "`call()` або `apply()` краще використовувати, коли вам потрібно викликати функцію негайно з певним контекстом `this` і аргументами. `bind()` використовується, коли вам потрібна нова функція, яку ви зможете викликати пізніше з вже прив'язаним контекстом."
      },
      {
        "id": "js-q9-aq2",
        "question": "Наведіть приклад використання `bind()`.",
        "answer": "`const person = { name: 'Роман', sayHello: function() { console.log(`Привіт, ${this.name}!`); } }; const greet = person.sayHello.bind(person); setTimeout(greet, 1000); // Привіт, Роман!` (Без bind this був би window або undefined у строгому режимі)"
      },
      {
        "id": "js-q9-aq3",
        "question": "Яка головна відмінність у передачі аргументів між `call()` та `apply()`?",
        "answer": "`call()` приймає аргументи як окремі значення (після першого аргументу `thisArg`), тоді як `apply()` приймає аргументи як один масив."
      }
    ]
  },
  {
    "id": "js-q10",
    "topic": "JavaScript",
    "mainQuestion": "Що таке прототип? Поясніть, як працює успадкування в JavaScript?",
    "mainAnswer": "Прототип (prototype) — це об'єкт, до якого JavaScript-об'єкт звертається для успадкування властивостей та методів. Кожен об'єкт в JavaScript має приховане внутрішнє посилання на свій прототип (property `[[Prototype]]`). Успадкування в JavaScript працює через 'прототипний ланцюжок' (prototype chain): коли ви намагаєтеся отримати доступ до властивості об'єкта, а його немає безпосередньо в ньому, JavaScript шукає його в прототипі цього об'єкта, потім у прототипі прототипу, і так далі, доки не знайде властивість або не дійде до `null`.",
    "additionalQuestions": [
      {
        "id": "js-q10-aq1",
        "question": "Як отримати доступ до прототипу об'єкта?",
        "answer": "Доступ можна отримати за допомогою `Object.getPrototypeOf(obj)`, `obj.__proto__` (застаріло, але часто використовується) або `obj.constructor.prototype`."
      },
      {
        "id": "js-q10-aq2",
        "question": "Як створити об'єкт з певним прототипом?",
        "answer": "Можна використовувати `Object.create(protoObject)` або синтаксис класів (`class Child extends Parent {}`) який є синтаксичним цукром над прототипним успадкуванням."
      },
      {
        "id": "js-q10-aq3",
        "question": "Чи є різниця між прототипним та класичним успадкуванням?",
        "answer": "JavaScript використовує прототипне успадкування (поведінкове делегування), тоді як багато інших мов використовують класичне (базоване на класах). Класи в JavaScript (ES6 `class`) — це синтаксичний цукор над існуючою прототипною моделлю успадкування."
      }
    ]
  },
  {
    "id": "js-q11",
    "topic": "JavaScript",
    "mainQuestion": "Поясніть `async`/`await` та Проміси (Promises).",
    "mainAnswer": "Проміси (`Promise`) — це об'єкти, які представляють результат асинхронної операції: успішне завершення (`resolve`) або помилку (`reject`). Вони дозволяють уникнути 'callback hell' (пекла колбеків). `async`/`await` — це синтаксичний цукор (syntactic sugar) над Промісами, який дозволяє писати асинхронний код у більш синхронному, читабельному стилі. Функція, позначена як `async`, завжди повертає Проміс, а оператор `await` 'чекає' на виконання Промісу перед продовженням виконання коду.",
    "additionalQuestions": [
      {
        "id": "js-q11-aq1",
        "question": "Які стани може мати Проміс?",
        "answer": "Проміс може перебувати в трьох станах: `pending` (очікування), `fulfilled` (виконано успішно) та `rejected` (відхилено з помилкою)."
      },
      {
        "id": "js-q11-aq2",
        "question": "Як обробляти помилки в `async`/`await`?",
        "answer": "Помилки в `async`/`await` обробляються за допомогою конструкції `try...catch`, аналогічно синхронному коду."
      },
      {
        "id": "js-q11-aq3",
        "question": "У чому перевага `async`/`await` над ланцюжками `.then()`?",
        "answer": "`async`/`await` робить асинхронний код більш читабельним, схожим на синхронний, дозволяє легше обробляти помилки за допомогою `try...catch` і спрощує налагодження, оскільки стек викликів виглядає більш звично."
      }
    ]
  },
  {
    "id": "js-q12",
    "topic": "JavaScript",
    "mainQuestion": "Що таке Event Loop? Поясніть його.",
    "mainAnswer": "Event Loop (цикл подій) — це фундаментальна частина архітектури виконання JavaScript, яка дозволяє JavaScript (однопотоковому за своєю природою) обробляти асинхронні операції. Він постійно перевіряє чергу колбеків (callback queue) та стек викликів (call stack). Якщо стек викликів порожній (тобто немає синхронного коду, що виконується), Event Loop переміщує першу функцію з черги колбеків у стек викликів для виконання.",
    "additionalQuestions": [
      {
        "id": "js-q12-aq1",
        "question": "Які компоненти складають середовище виконання JavaScript, крім Call Stack та Heap?",
        "answer": "Крім Call Stack (стек викликів) та Heap (купа, де зберігаються об'єкти), ключовими компонентами є Web APIs (для браузера), Callback Queue (черга колбеків) та Event Loop."
      },
      {
        "id": "js-q12-aq2",
        "question": "Як Web APIs взаємодіють з Event Loop?",
        "answer": "Web APIs (наприклад, `setTimeout`, `fetch`, DOM події) виконують асинхронні операції. Після їх завершення, їхні колбеки поміщаються в Callback Queue, звідки Event Loop їх переміщує до Call Stack."
      },
      {
        "id": "js-q12-aq3",
        "question": "Що таке 'Microtask Queue' та як вона пов'язана з Event Loop?",
        "answer": "'Microtask Queue' (черга мікрозавдань) — це окрема черга, яка має вищий пріоритет, ніж звичайна Callback Queue. Проміси, `queueMicrotask` та `MutationObserver` додають завдання до Microtask Queue. Event Loop спочатку обробляє всі завдання з Microtask Queue, а потім переходить до Callback Queue."
      }
    ]
  },
  {
    "id": "js-q13",
    "topic": "JavaScript",
    "mainQuestion": "Які типи даних JS ви знаєте? Як перевірити тип змінної?",
    "mainAnswer": "У JavaScript існує 8 типів даних: **Примітивні:** `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`. **Непримітивні:** `object` (включаючи функції та масиви). Тип змінної можна перевірити за допомогою оператора `typeof` (для примітивів та функцій) або `instanceof` (для об'єктів та класів). Для `null` `typeof` повертає `'object'` (це відома помилка).",
    "additionalQuestions": [
      {
        "id": "js-q13-aq1",
        "question": "У чому відмінність між `null` та `undefined`?",
        "answer": "`undefined` означає, що змінна була оголошена, але їй не було присвоєно значення, або властивість відсутня. `null` означає навмисну відсутність будь-якого об'єктного значення, тобто змінній явно присвоєно 'нічого'."
      },
      {
        "id": "js-q13-aq2",
        "question": "Чому `typeof null` повертає 'object'?",
        "answer": "Це є відомою історичною помилкою в JavaScript, яка збереглася для сумісності. Внутрішньо `null` представлений як нульовий вказівник, і `typeof` помилково інтерпретує його як об'єкт."
      },
      {
        "id": "js-q13-aq3",
        "question": "Як перевірити, чи є змінна масивом?",
        "answer": "Найкращий спосіб — `Array.isArray(variable)`. Також можна використовувати `variable instanceof Array`, але це може дати некоректний результат у багатофреймових середовищах."
      }
    ]
  },
  {
    "id": "js-q14",
    "topic": "JavaScript",
    "mainQuestion": "Що таке строге та нестроге порівняння в JS? У чому їх різниця?",
    "mainAnswer": "Нестроге порівняння (`==`) перевіряє лише значення, допускаючи неявне приведення типів (type coercion) перед порівнянням. Наприклад, `5 == '5'` поверне `true`. Строге порівняння (`===`) перевіряє як значення, так і тип даних, не виконуючи приведення типів. Наприклад, `5 === '5'` поверне `false`. Завжди рекомендується використовувати строге порівняння (`===`) для уникнення неочікуваної поведінки та потенційних помилок.",
    "additionalQuestions": [
      {
        "id": "js-q14-aq1",
        "question": "Наведіть приклад, де нестроге порівняння може призвести до неочікуваних результатів.",
        "answer": "`false == 0` поверне `true`; `'' == 0` поверне `true`; `null == undefined` поверне `true`. Це може спричинити логічні помилки."
      },
      {
        "id": "js-q14-aq2",
        "question": "Чи є випадки, коли нестроге порівняння допустиме?",
        "answer": "Дуже рідко, і зазвичай тільки для перевірки на `null` та `undefined` одночасно (`value == null`), оскільки `null == undefined` є `true`. Але навіть у цьому випадку `value === null || value === undefined` є більш явним."
      },
      {
        "id": "js-q14-aq3",
        "question": "Яке порівняння використовується для об'єктів?",
        "answer": "Для об'єктів (включаючи масиви та функції), як `==`, так і `===` перевіряють, чи посилаються обидві змінні на один і той же об'єкт у пам'яті, а не чи є їхній вміст однаковим. Тобто `[] == []` і `[] === []` обидва повернуть `false`."
      }
    ]
  },
  {
    "id": "js-q15",
    "topic": "JavaScript",
    "mainQuestion": "Що таке тернарний оператор? Коли його доцільно використовувати, а коли ні?",
    "mainAnswer": "Тернарний оператор (`condition ? exprIfTrue : exprIfFalse`) — це скорочена форма умовного оператора `if...else`. Він повертає значення `exprIfTrue`, якщо `condition` є істинним, і `exprIfFalse` в іншому випадку. Доцільно використовувати для простих, коротких умов, що присвоюють значення змінній або повертають його. Не варто використовувати для складних логічних блоків або кількох вкладених умов, оскільки це погіршує читабельність.",
    "additionalQuestions": [
      {
        "id": "js-q15-aq1",
        "question": "Наведіть приклад використання тернарного оператора.",
        "answer": "`const age = 20; const status = age >= 18 ? 'Дорослий' : 'Неповнолітній'; console.log(status); // Дорослий`"
      },
      {
        "id": "js-q15-aq2",
        "question": "Чи можна вкладати тернарні оператори?",
        "answer": "Так, можна, але це швидко робить код важким для читання і розуміння, тому це не рекомендується."
      },
      {
        "id": "js-q15-aq3",
        "question": "У чому головна відмінність тернарного оператора від `if...else`?",
        "answer": "Тернарний оператор є *виразом* (expression) і повертає значення, тоді як `if...else` є *оператором* (statement) і не повертає значення (хоча може виконувати код)."
      }
    ]
  },
  {
    "id": "js-q16",
    "topic": "JavaScript",
    "mainQuestion": "Які логічні оператори ви знаєте? Який результат вони повертають?",
    "mainAnswer": "В JavaScript є три основні логічні оператори: **AND (`&&`)**: повертає перше `falsy` значення або останнє `truthy` значення. **OR (`||`)**: повертає перше `truthy` значення або останнє `falsy` значення. **NOT (`!`)**: перетворює операнд на булеве значення і повертає його протилежне значення (`true` стає `false`, `false` стає `true`).",
    "additionalQuestions": [
      {
        "id": "js-q16-aq1",
        "question": "Що таке 'коротке замикання' (short-circuiting) у логічних операторах?",
        "answer": "'Коротке замикання' означає, що логічні оператори (`&&` та `||`) обчислюють операнди зліва направо і припиняють обчислення, як тільки результат стає очевидним. Наприклад, у `a && b`, якщо `a` є `false`, `b` не обчислюється."
      },
      {
        "id": "js-q16-aq2",
        "question": "Які значення є 'falsy' у JavaScript?",
        "answer": "Значення, які при приведенні до булевого типу стають `false`: `false`, `0`, `-0`, `null`, `undefined`, `NaN`, `''` (порожній рядок)."
      },
      {
        "id": "js-q16-aq3",
        "question": "Для чого може використовуватися оператор `||` (OR) крім логічних перевірок?",
        "answer": "Оператор `||` часто використовується для встановлення значень за замовчуванням: `const value = someVariable || 'default_value';`."
      }
    ]
  },
  {
    "id": "js-q17",
    "topic": "JavaScript",
    "mainQuestion": "Які види JS циклів ви знаєте? У яких сценаріях найкраще використовувати кожен з них?",
    "mainAnswer": "Основні види циклів: **`for`**: для ітерації, коли відома кількість повторень або потрібен доступ до індексу. **`while`**: коли умова перевіряється перед кожним виконанням циклу. **`do...while`**: коли потрібно виконати тіло циклу хоча б один раз, потім перевірити умову. **`for...in`**: для ітерації по перелічуваних властивостях об'єкта (не рекомендується для масивів). **`for...of`**: для ітерації по ітерованих об'єктах (масиви, рядки, Map, Set). **`forEach`**: метод масиву для ітерації по елементах масиву (не переривається).",
    "additionalQuestions": [
      {
        "id": "js-q17-aq1",
        "question": "Чому не рекомендується використовувати `for...in` для ітерації по масивах?",
        "answer": "`for...in` ітерує по ключах (індексах) і властивостях об'єкта, а не по елементах. Він також ітерує по успадкованих властивостях, що може призвести до неочікуваних результатів. Для масивів краще використовувати `for`, `for...of` або `forEach`."
      },
      {
        "id": "js-q17-aq2",
        "question": "Коли `for...of` кращий за `forEach`?",
        "answer": "`for...of` дозволяє використовувати `break`, `continue` та `return` (якщо він знаходиться у функції), що недоступно у `forEach`. Також `for...of` працює з будь-якими ітерованими об'єктами, не лише масивами."
      },
      {
        "id": "js-q17-aq3",
        "question": "Які ще ітераційні методи для масивів ви знаєте, крім `forEach`?",
        "answer": "Також існують `map`, `filter`, `reduce`, `some`, `every`, `find`, `findIndex`, які є більш функціональними та часто кращими для конкретних завдань, ніж загальні цикли."
      }
    ]
  }
]