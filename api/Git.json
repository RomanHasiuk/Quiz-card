[
  {
    "id": "git_001",
    "topic": "Git (Термінал)",
    "mainQuestion": "Що таке Git і для чого він використовується?",
    "mainAnswer": "Git – це розподілена система контролю версій (DVCS) з відкритим вихідним кодом, яка використовується для відстеження змін у вихідному коді під час розробки програмного забезпечення. Вона дозволяє кільком розробникам співпрацювати над одним проєктом, зберігаючи історію змін, дозволяючи повертатися до попередніх версій та керувати конфліктами.",
    "additionalQuestions": [
      {
        "id": "git_001_1",
        "question": "Чим розподілена система відрізняється від централізованої?",
        "answer": "У розподіленій системі (Git) кожен розробник має повну копію всього репозиторію з історією, що дозволяє працювати офлайн та забезпечує більшу стійкість. У централізованій (SVN, CVS) є єдиний сервер, і для роботи потрібне постійне підключення."
      },
      {
        "id": "git_001_2",
        "question": "Які основні переваги Git?",
        "answer": "Швидкість, підтримка нелінійної розробки (гілки), децентралізована природа (кожен має повну копію), ефективне керування великими проєктами, потужні інструменти для злиття та вирішення конфліктів."
      }
    ]
  },
  {
    "id": "git_002",
    "topic": "Git (Термінал)",
    "mainQuestion": "Поясніть основні стани файлів у Git.",
    "mainAnswer": "У Git файли можуть перебувати у трьох основних станах: **Modified (Змінений)** – файл змінено, але зміни ще не додано для коміту; **Staged (Індексований)** – змінений файл додано до області індексування (staging area) і готовий до наступного коміту; **Committed (Зафіксований)** – зміни файлу збережено в локальному репозиторії.",
    "additionalQuestions": [
      {
        "id": "git_002_1",
        "question": "Що таке 'staging area' (область індексування)?",
        "answer": "Staging area (також 'індекс') – це проміжна область між робочою директорією та репозиторієм. Вона дозволяє підготувати конкретні зміни для наступного коміту, групуючи їх логічно."
      },
      {
        "id": "git_002_2",
        "question": "Яка команда використовується для переміщення файлу в Staged стан?",
        "answer": "`git add <filename>` або `git add .` (для всіх змінених/нових файлів)."
      }
    ]
  },
  {
    "id": "git_003",
    "topic": "Git (Термінал)",
    "mainQuestion": "Як створити новий Git репозиторій?",
    "mainAnswer": "Щоб створити новий Git репозиторій у поточній директорії, потрібно виконати команду `git init`. Це ініціалізує порожній Git репозиторій, створюючи приховану папку `.git`, яка буде зберігати всю історію змін.",
    "additionalQuestions": [
      {
        "id": "git_003_1",
        "question": "Чи можна ініціалізувати репозиторій у вже існуючій папці з кодом?",
        "answer": "Так, `git init` можна виконати у будь-якій існуючій папці з проєктом. Git почне відстежувати зміни в цій папці."
      }
    ]
  },
  {
    "id": "git_004",
    "topic": "Git (Термінал)",
    "mainQuestion": "Що таке 'commit' у Git?",
    "mainAnswer": "Коміт (commit) у Git – це 'знімок' стану твого репозиторію в певний момент часу. Це основна одиниця збереження змін. Кожен коміт містить унікальний ідентифікатор (хеш), повідомлення про коміт, автора, дату та посилання на попередній коміт (батьківський).",
    "additionalQuestions": [
      {
        "id": "git_004_1",
        "question": "Яка команда використовується для створення коміту?",
        "answer": "`git commit -m \"Твоє повідомлення про зміни\"`. Прапор `-m` дозволяє одразу вказати повідомлення."
      },
      {
        "id": "git_004_2",
        "question": "Що має містити хороше повідомлення про коміт?",
        "answer": "Хороше повідомлення має бути коротким, чітким та описувати мету змін. Зазвичай починають з дієслова в наказовому способі (наприклад, 'Fix bug', 'Add feature')."
      }
    ]
  },
  {
    "id": "git_005",
    "topic": "Git (Термінал)",
    "mainQuestion": "Як переглянути історію комітів?",
    "mainAnswer": "Щоб переглянути історію комітів у репозиторії, використовується команда `git log`. Вона показує коміти у хронологічному порядку (від найновішого до найстарішого), включаючи їх хеш, автора, дату та повідомлення.",
    "additionalQuestions": [
      {
        "id": "git_005_1",
        "question": "Які корисні опції можна використовувати з `git log`?",
        "answer": "`git log --oneline` (короткий однорядковий вивід), `git log --graph` (графічне відображення гілок), `git log --author=\"Name\"` (фільтр за автором), `git log -p` (зміни в комітах)."
      }
    ]
  },
  {
    "id": "git_006",
    "topic": "Git (Термінал)",
    "mainQuestion": "Що таке гілка (branch) у Git?",
    "mainAnswer": "Гілка (branch) у Git – це легковажний рухомий покажчик на останній коміт у ланцюжку комітів. Вона дозволяє розробникам працювати над новими функціями або виправленнями помилок паралельно, не впливаючи на основну кодову базу. Це створює ізольовані лінії розробки.",
    "additionalQuestions": [
      {
        "id": "git_006_1",
        "question": "Як створити нову гілку та переключитися на неї?",
        "answer": "`git branch <назва_гілки>` для створення, а потім `git checkout <назва_гілки>` для перемикання. Або однією командою: `git checkout -b <назва_гілки>`."
      },
      {
        "id": "git_006_2",
        "question": "Яка гілка є основною за замовчуванням?",
        "answer": "Історично це була `master`, але зараз у більшості проєктів (включаючи GitHub за замовчуванням) використовується `main`."
      }
    ]
  },
  {
    "id": "git_007",
    "topic": "Git (Термінал)",
    "mainQuestion": "Як злити дві гілки в Git?",
    "mainAnswer": "Щоб злити зміни з однієї гілки в іншу, потрібно спочатку переключитися на ту гілку, в яку ти хочеш злити зміни (наприклад, `main`), а потім виконати команду `git merge <назва_гілки_з_якої_зливаємо>`. Git спробує автоматично об'єднати зміни.",
    "additionalQuestions": [
      {
        "id": "git_007_1",
        "question": "Що таке 'merge conflict' і як його вирішити?",
        "answer": "Конфлікт злиття виникає, коли Git не може автоматично об'єднати зміни, тому що один і той же рядок коду був змінений по-різному в обох гілках. Для вирішення потрібно вручну відредагувати конфліктні файли, видалити маркери конфлікту (`<<<<<<<`, `=======`, `>>>>>>>`) та зробити новий коміт."
      },
      {
        "id": "git_007_2",
        "question": "Яка різниця між `git merge` та `git rebase`?",
        "answer": "`git merge` створює новий коміт злиття, зберігаючи історію гілок. `git rebase` переносить коміти однієї гілки на вершину іншої, створюючи лінійну історію, але перезаписуючи історію комітів."
      }
    ]
  },
  {
    "id": "git_008",
    "topic": "Git (Термінал)",
    "mainQuestion": "Що таке `git status`?",
    "mainAnswer": "`git status` – це команда, яка показує поточний стан робочої директорії та області індексування. Вона інформує про: поточну гілку, змінені файли, які ще не додано до індексу, файли, які готові до коміту, та невідстежувані файли.",
    "additionalQuestions": [
      {
        "id": "git_008_1",
        "question": "Для чого корисно використовувати `git status` регулярно?",
        "answer": "`git status` допомагає контролювати, які зміни ти збираєшся закомітити, перевіряти наявність невідстежуваних файлів та швидко орієнтуватися у стані репозиторію."
      }
    ]
  },
  {
    "id": "git_009",
    "topic": "Git (Термінал)",
    "mainQuestion": "Як скасувати зміни в Git?",
    "mainAnswer": "У Git є кілька способів скасувати зміни, залежно від стану файлів: \n* `git restore <filename>` або `git checkout -- <filename>`: скасувати зміни у робочій директорії (повернути до останнього коміту або стану staged). \n* `git reset HEAD <filename>`: вилучити файл з області індексування (unstage). \n* `git reset --hard <commit-hash>`: відкотити репозиторій до певного коміту, видаливши всі наступні зміни (обережно, втрачає історію). \n* `git revert <commit-hash>`: створити новий коміт, який скасовує зміни попереднього коміту (зберігає історію).",
    "additionalQuestions": [
      {
        "id": "git_009_1",
        "question": "Коли варто використовувати `git revert` замість `git reset --hard`?",
        "answer": "`git revert` безпечніше використовувати, коли ви вже 'пушили' зміни у віддалений репозиторій, оскільки він створює новий коміт, що скасовує старі зміни, не переписуючи історію. `git reset --hard` переписує історію і може спричинити проблеми для інших розробників."
      }
    ]
  },
  {
    "id": "git_010",
    "topic": "Git (Термінал)",
    "mainQuestion": "Що таке `git pull` та `git push`?",
    "mainAnswer": "`git pull` використовується для отримання змін з віддаленого репозиторію та їхнього об'єднання з локальною гілкою. По суті, це комбінація `git fetch` (завантаження змін) та `git merge` (злиття). `git push` використовується для відправлення твоїх локальних комітів на віддалений репозиторій, роблячи їх доступними для інших.",
    "additionalQuestions": [
      {
        "id": "git_010_1",
        "question": "Яка різниця між `git fetch` та `git pull`?",
        "answer": "`git fetch` лише завантажує зміни з віддаленого репозиторію до твого локального, але не інтегрує їх у твою поточну робочу гілку. `git pull` робить це автоматично."
      },
      {
        "id": "git_010_2",
        "question": "Що означає `git push -u origin main`?",
        "answer": "`git push` відправляє зміни. `-u` (або `--set-upstream`) встановлює віддалену гілку `origin/main` як upstream для поточної локальної гілки `main`. Це дозволяє в майбутньому просто писати `git push` або `git pull` без вказівки `origin main`."
      }
    ]
  },
  {
    "id": "git_011",
    "topic": "Git (Термінал)",
    "mainQuestion": "Що таке `.gitignore` файл?",
    "mainAnswer": "Файл `.gitignore` – це текстовий файл, який містить список файлів та директорій, які Git повинен ігнорувати і не відстежувати. Він використовується для виключення з репозиторію тимчасових файлів, логів, згенерованих файлів, конфігурацій з конфіденційними даними (наприклад, `node_modules/`, `.env`, `build/`).",
    "additionalQuestions": [
      {
        "id": "git_011_1",
        "question": "Чому важливо використовувати `.gitignore`?",
        "answer": "Він допомагає підтримувати репозиторій чистим, запобігає випадковому додаванню непотрібних файлів, зменшує розмір репозиторію та уникає комітів конфіденційних даних."
      },
      {
        "id": "git_011_2",
        "question": "Де розміщується `.gitignore`?",
        "answer": "Зазвичай `.gitignore` розміщується у кореневій директорії репозиторію, але його можна розміщувати і в піддиректоріях, щоб ігнорувати файли специфічні для цієї директорії."
      }
    ]
  },
  {
    "id": "git_012",
    "topic": "Git (Термінал)",
    "mainQuestion": "Як відновити видалений коміт?",
    "mainAnswer": "Якщо ти випадково видалив коміт, його можна відновити, якщо ти знаєш його хеш. Використовуй команду `git reflog`, щоб переглянути історію всіх дій у репозиторії, включаючи видалені коміти. Потім можна використати `git checkout <хеш_коміту>` або `git reset --hard <хеш_коміту>`, щоб повернутися до цього стану.",
    "additionalQuestions": [
      {
        "id": "git_012_1",
        "question": "Що таке `git reflog`?",
        "answer": "`git reflog` – це журнал всіх змін у HEAD, який дозволяє відстежувати всі переміщення в історії комітів, навіть якщо вони не відображаються в `git log`."
      }
    ]
  }
]