[
  {
    "id": "redux-q1",
    "topic": "Redux",
    "mainQuestion": "Якими є основні засади Редакса і в чому полягають його переваги?",
    "mainAnswer": "Redux — це передбачуваний контейнер стану для JavaScript-застосунків, що допомагає писати послідовний код, який поводиться однаково в різних середовищах (клієнт, сервер, нативний). \n\n**Три основні засади (принципи) Redux:** \n1.  **Єдине джерело істини (Single Source of Truth)**: Весь стан застосунку зберігається в одному об'єкті в єдиному сховищі (Store). Це спрощує відстеження стану та налагодження. \n2.  **Стан доступний лише для читання (State is Read-Only)**: Єдиний спосіб змінити стан — це надіслати дію (Action) — простий JavaScript-об'єкт, що описує, що сталося. Це гарантує, що зміни стану відбуваються передбачувано і централізовано. \n3.  **Зміни виконуються чистими функціями (Changes are Made with Pure Functions)**: Для вказівки, як стан змінюється у відповідь на дії, ви пишете редюсери (Reducers) — чисті функції, які приймають поточний стан та дію, і повертають новий стан. Вони ніколи не мутують поточний стан, а створюють його нову копію. \n\n**Переваги Redux:** \n-   **Передбачуваність стану**: Завдяки трьом принципам, зміни стану легко відстежувати, що значно спрощує налагодження та розуміння поведінки застосунку. \n-   **Легкість тестування**: Редюсери є чистими функціями, що робить їх надзвичайно легкими для тестування. \n-   **Централізоване управління станом**: Весь стан в одному місці, що усуває проблеми з 'prop drilling' для глобальних даних. \n-   **Могутній інструмент для налагодження (Redux DevTools)**: Дозволяє бачити кожну дію, зміну стану, подорожувати в часі по стану (time-travel debugging), що є неймовірно потужним. \n-   **Масштабованість**: Дуже добре підходить для великих і складних застосунків з великою кількістю спільних даних. \n-   **Екосистема**: Велика кількість middleware, розширень та спільнота.",
    "additionalQuestions": [
      {
        "id": "redux-q1-aq1",
        "question": "Що таке 'time-travel debugging' у Redux DevTools?",
        "answer": "'Time-travel debugging' дозволяє відтворювати дії, які були виконані в застосунку, крок за кроком, або навіть 'відкочувати' стан до попереднього моменту. Це надзвичайно корисно для відлагодження складних багажних ситуацій."
      },
      {
        "id": "redux-q1-aq2",
        "question": "Чи є Redux фреймворком?",
        "answer": "Ні, Redux — це бібліотека, а не фреймворк. Він не нав'язує вам певну архітектуру для всього застосунку, а лише надає спосіб керування станом. Він є гнучким і може використовуватися з будь-яким UI-фреймворком або бібліотекою (React, Angular, Vue, тощо)."
      },
      {
        "id": "redux-q1-aq3",
        "question": "Чи обов'язково використовувати Redux для кожного React-застосунку?",
        "answer": "Ні. Для невеликих застосунків або тих, де стан компонентів не є дуже складним або не вимагає багато спільного використання, вбудовані можливості React (наприклад, `useState`, `useContext`, `useReducer`) можуть бути цілком достатніми. Redux додає певну складність, тому його варто використовувати лише тоді, коли переваги переважають накладні витрати."
      }
    ]
  },
  {
    "id": "redux-q2",
    "topic": "Redux",
    "mainQuestion": "Які переваги дає Redux? Які слабкі місця ти бачиш в цьому підході?",
    "mainAnswer": "**Переваги Redux:** \n-   **Прогнозованість**: Стан змінюється передбачувано, оскільки всі зміни проходять через редюсери та дії. \n-   **Централізація стану**: Весь стан в одному місці, що спрощує доступ та відстеження. \n-   **Потужні інструменти для налагодження**: Redux DevTools з 'time-travel debugging' є неперевершеними для розуміння потоку даних та відтворення багів. \n-   **Ізольовані зміни**: Кожна дія викликає нову версію стану, що спрощує ізоляцію змін. \n-   **Екосистема та спільнота**: Велика кількість middleware та активна спільнота. \n-   **Масштабованість**: Добре підходить для великих і складних проектів. \n\n**Слабкі місця (недоліки):** \n-   **Бойлерплейт (Boilerplate)**: Навіть для невеликих змін стану може знадобитися створити дію, константу для типу дії, action creator та додати логіку в редюсер. Це може бути надмірним для простих застосунків. \n-   **Крива навчання**: Концепції Redux (чисті функції, імутабельність, middleware) можуть бути складними для початківців. \n-   **Надмірність для простих застосунків**: Для невеликих проектів додавання Redux може бути зайвим і ускладнити код, замість того, щоб спростити його. \n-   **Оптимізація рендерингу**: Хоча Redux сам по собі не викликає зайвих рендерингів, розробнику все ще потрібно бути обережним з оптимізацією компонентів, щоб уникнути непотрібних рендерингів при зміні стану (наприклад, з `React.memo` або `useSelector` з відповідними селекторами). \n-   **Управління асинхронністю**: Redux сам по собі синхронний. Для асинхронних операцій (наприклад, мережевих запитів) потрібні додаткові бібліотеки (middleware) на кшталт Redux Thunk або Redux Saga, що додає ще одну складність."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q2-aq1",
        "question": "Які сучасні альтернативи Redux і чому вони можуть бути кращими для деяких сценаріїв?",
        "answer": "Сучасні альтернативи: `Zustand`, `Jotai`, `Recoil`, `Valtio`, `React Context API` (+ `useReducer`). Вони часто пропонують менше бойлерплейту, простішу інтеграцію та більш 'React-центричний' підхід (використовуючи хуки) до управління станом, що може бути кращим для менших або середніх застосунків, де не потрібна вся потужність та інструменти Redux."
      },
      {
        "id": "redux-q2-aq2",
        "question": "Чому Redux не є Silver Bullet (універсальним рішенням)?",
        "answer": "Redux не є 'срібною кулею', оскільки, хоча він вирішує проблему централізованого управління станом і передбачуваності, він вводить власні складнощі (бойлерплейт, крива навчання, необхідність middleware для асинхронності). Він найкраще підходить для великих, складних застосунків, де його переваги переважають ці накладні витрати."
      },
      {
        "id": "redux-q2-aq3",
        "question": "Чи можна використовувати Redux і React Context API в одному проекті?",
        "answer": "Так, можна і навіть часто доцільно. Redux можна використовувати для глобального, складного або часто оновлюваного стану, який потребує потужних інструментів налагодження. React Context API можна використовувати для передачі менш критичних даних або даних, які рідко змінюються, наприклад, налаштування теми або дані автентифікованого користувача, щоб уникнути 'prop drilling' для цих конкретних випадків."
      }
    ]
  },
  {
    "id": "redux-q3",
    "topic": "Redux",
    "mainQuestion": "Що таке стан у Редаксі?",
    "mainAnswer": "**Стан (State)** у Redux — це єдиний об'єкт JavaScript, який представляє собою весь стан вашого застосунку. Цей об'єкт зберігається в єдиному сховищі (Store) Redux. \n\n**Ключові характеристики стану Redux:** \n-   **Єдиний об'єкт**: Незалежно від складності застосунку, весь його стан (наприклад, дані користувача, списки товарів, стан UI, тощо) агрегується в одному кореневому об'єкті стану. \n-   **Імутабельний**: Стан ніколи не модифікується безпосередньо. Кожного разу, коли стан змінюється, редюсер (Reducer) повертає **новий об'єкт стану** з оновленими даними. Оригінальний об'єкт стану залишається незмінним. Це дозволяє Redux ефективно відстежувати зміни та забезпечує 'time-travel debugging'. \n-   **Нормалізований (часто)**: Для складних застосунків стан часто нормалізується, тобто дані зберігаються у вигляді об'єктів з ID, а не вкладених структур або дубльованих даних. Це спрощує управління даними та їх оновлення. \n-   **Представляє весь UI**: Стан повинен містити всі дані, необхідні для рендерингу вашого інтерфейсу. \n\n**Приклад об'єкта стану:** \n```json \n{ \n  \"user\": { \n    \"id\": \"123\", \n    \"name\": \"Роман\", \n    \"isLoggedIn\": true \n  }, \n  \"products\": [ \n    { \"id\": \"p1\", \"name\": \"Лаптоп\", \"price\": 1200 }, \n    { \"id\": \"p2\", \"name\": \"Мишка\", \"price\": 25 } \n  ], \n  \"cart\": { \n    \"items\": [\"p1\"], \n    \"totalAmount\": 1200 \n  }, \n  \"ui\": { \n    \"loading\": false, \n    \"error\": null \n  } \n} \n``` \nRedux дозволяє вам легко 'знімати знімки' цього об'єкта стану в будь-який момент часу, що є основою для його потужних інструментів налагодження.",
    "additionalQuestions": [
      {
        "id": "redux-q3-aq1",
        "question": "Чому стан у Redux має бути імутабельним?",
        "answer": "Імутабельність є фундаментальною для Redux, оскільки вона дозволяє: \n1.  **Просто і ефективно виявляти зміни**: Redux (та інші оптимізації, такі як `PureComponent` або `React.memo`) може просто порівняти посилання на об'єкт стану. Якщо посилання змінилося, стан змінився. \n2.  **Функції-редюсери бути чистими**: Чисті функції не мають побічних ефектів і не змінюють своїх аргументів. \n3.  **Time-travel debugging**: Можливість 'подорожувати в часі' по стану завдяки збереженню історії імутабельних знімків стану."
      },
      {
        "id": "redux-q3-aq2",
        "question": "Чи всі дані в React-застосунку повинні бути в Redux state?",
        "answer": "Ні. Лише ті дані, які є 'глобальними' для застосунку або які використовуються багатьма компонентами, або ті, що вимагають централізованого управління та потужних інструментів налагодження. Локальний стан компонентів (наприклад, стан форми, яка використовується лише одним компонентом) зазвичай краще залишати в `useState` або `this.state`."
      },
      {
        "id": "redux-q3-aq3",
        "question": "Як Redux забезпечує, що стан є єдиним джерелом істини?",
        "answer": "Redux забезпечує це, примушуючи всі зміни стану відбуватися через надсилання дій (actions) до єдиного сховища (store). Жоден інший спосіб прямої модифікації стану не допускається, що гарантує, що весь UI відображає лише той стан, який знаходиться в сторі."
      }
    ]
  },
  {
    "id": "redux-q4",
    "topic": "Redux",
    "mainQuestion": "Що таке reducer? Які обов’язкові вимоги до них існують?",
    "mainAnswer": "**Редюсер (Reducer)** у Redux — це чиста функція, яка приймає поточний стан застосунку та дію (Action) як аргументи, і повертає **новий об'єкт стану**. Редюсери є єдиним місцем, де дозволено змінювати стан у Redux. \n\nНазва 'reducer' походить від функції `reduce` у JavaScript (наприклад, `Array.prototype.reduce()`), яка приймає колбек-функцію, що оперує з акумулятором та поточним елементом, повертаючи нове значення акумулятора. У Redux редюсер виконує схожу роль: він 'згортає' дії в новий стан. \n\n**Обов'язкові вимоги до редюсерів:** \n1.  **Чиста функція**: \n    -   Не повинна мати побічних ефектів (наприклад, змінювати зовнішні змінні, виконувати HTTP-запити, читати локальне сховище, мутувати аргументи). \n    -   При тих самих вхідних аргументах (поточний стан та дія) завжди повинна повертати один і той самий вихідний стан. \n2.  **Не мутувати стан**: \n    -   Редюсер повинен повертати **новий об'єкт стану**, а не змінювати безпосередньо переданий `state` або `action`. Для оновлення об'єктів та масивів слід використовувати оператори спред (`...`), `Object.assign`, `concat` та інші методи, що створюють копії. \n3.  **Обробляти будь-яку дію**: \n    -   Редюсер повинен мати логіку `default`, яка повертає поточний `state`, якщо передана дія не відповідає жодному відомому типу дії. Це важливо, оскільки Redux надсилає багато системних дій. \n4.  **Початковий стан**: \n    -   Редюсер повинен повертати початковий стан застосунку, якщо аргумент `state` є `undefined` (це відбувається при першому запуску застосунку). Це зазвичай робиться шляхом призначення значення за замовчуванням параметру `state`. \n\n**Приклад:** \n```javascript \nconst initialState = { count: 0 }; \nfunction counterReducer(state = initialState, action) { \n  switch (action.type) { \n    case 'INCREMENT': \n      return { ...state, count: state.count + 1 }; \n    case 'DECREMENT': \n      return { ...state, count: state.count - 1 }; \n    default: \n      return state; // Завжди повертати поточний стан за замовчуванням \n  } \n} \n```",
    "additionalQuestions": [
      {
        "id": "redux-q4-aq1",
        "question": "Чому редюсери повинні бути чистими функціями?",
        "answer": "Чистота редюсерів забезпечує: \n-   **Прогнозованість**: Той самий вхід завжди дає той самий вихід. \n-   **Легкість тестування**: Їх можна тестувати ізольовано. \n-   **Налагодження**: Спрощує 'time-travel debugging' та відстеження змін. \n-   **Оптимізації**: Дозволяє Redux та іншим бібліотекам ефективно порівнювати стан для оптимізації рендерингу."
      },
      {
        "id": "redux-q4-aq2",
        "question": "Що станеться, якщо редюсер мутує стан?",
        "answer": "Якщо редюсер мутує стан, Redux не зможе виявити, що стан змінився, оскільки посилання на об'єкт стану залишається тим самим. Це призведе до: \n-   UI не буде оновлюватися, навіть якщо дані в стані змінилися. \n-   Порушення 'time-travel debugging'. \n-   Непередбачуваної поведінки та складнощів у налагодженні."
      },
      {
        "id": "redux-q4-aq3",
        "question": "Чи може редюсер виконувати асинхронні операції?",
        "answer": "Ні, редюсер не може і не повинен виконувати асинхронні операції або будь-які побічні ефекти. Редюсер повинен бути строго синхронним і чистим. Асинхронна логіка в Redux обробляється за допомогою middleware (наприклад, Redux Thunk або Redux Saga)."
      }
    ]
  },
  {
    "id": "redux-q5",
    "topic": "Redux",
    "mainQuestion": "Що таке pure function?",
    "mainAnswer": "**Чиста функція (Pure Function)** — це концепція з функціонального програмування, яка описує функцію, що задовольняє двом основним вимогам: \n\n1.  **Детермінованість (Deterministic)**: При одних і тих самих вхідних аргументах функція завжди повертає один і той самий вихідний результат. Її результат залежить лише від її аргументів. \n2.  **Відсутність побічних ефектів (No Side Effects)**: Функція не повинна змінювати жодні дані поза своєю локальною областю видимості, і вона не повинна взаємодіяти із зовнішнім світом (наприклад, змінювати глобальні змінні, виконувати операції вводу/виводу, такі як HTTP-запити, читання/запис до бази даних, вивід на консоль, зміна DOM, генерація випадкових чисел). \n\n**Приклад чистої функції:** \n```javascript \nfunction add(a, b) { \n  return a + b; // Завжди повертає суму a і b, не має побічних ефектів \n} \n``` \n**Приклад нечистої функції:** \n```javascript \nlet total = 0; \nfunction addToTotal(value) { \n  total += value; // Має побічний ефект: змінює зовнішню змінну 'total' \n  return total; \n} \n``` \n**Чому чисті функції важливі в Redux:** \n-   **Прогнозованість**: Легко передбачити, що функція зробить. \n-   **Легкість тестування**: Оскільки вони не залежать від зовнішнього стану і не мають побічних ефектів, їх дуже легко тестувати ізольовано. \n-   **Мемоізація**: Результати чистих функцій можна кешувати, оскільки вони завжди повертатимуть той самий результат для тих самих аргументів. \n-   **Паралельне виконання**: Чисті функції не викликають конфліктів при паралельному виконанні."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q5-aq1",
        "question": "Наведіть приклад побічного ефекту, який робить функцію нечистою.",
        "answer": "Приклади побічних ефектів, які роблять функцію нечистою: \n-   Модифікація глобальної змінної. \n-   Виконання HTTP-запиту до сервера. \n-   Запис у локальне сховище (localStorage). \n-   Зміна DOM-елемента. \n-   Генерація випадкових чисел (оскільки результат не є детермінованим)."
      },
      {
        "id": "redux-q5-aq2",
        "question": "Чому редюсери в Redux повинні бути чистими функціями?",
        "answer": "Редюсери повинні бути чистими функціями, щоб гарантувати передбачуваність стану, полегшити тестування, дозволити використання 'time-travel debugging' у Redux DevTools та забезпечити, що зміни стану відбуваються лише у контрольований та імутабельний спосіб."
      },
      {
        "id": "redux-q5-aq3",
        "question": "Чи може чиста функція приймати об'єкти як аргументи?",
        "answer": "Так, чиста функція може приймати об'єкти як аргументи. Головне правило — вона не повинна мутувати (змінювати) ці об'єкти. Якщо потрібно змінити об'єкт, вона має створити та повернути його нову копію."
      }
    ]
  },
  {
    "id": "redux-q6",
    "topic": "Redux",
    "mainQuestion": "Які елементи стану можна було б виділити для базового функціоналу Google: введення пошукового запиту — отримання результатів — введення нового запиту — отримання нових результатів і т. д.?",
    "mainAnswer": "Для базового функціоналу Google, що включає введення пошукового запиту та отримання результатів, можна було б виділити такі елементи стану в Redux (враховуючи, що вони є глобальними або спільними для різних частин застосунку): \n\n```json \n{ \n  \"search\": { \n    \"query\": \"\", // Рядок поточного пошукового запиту, введеного користувачем \n    \"results\": [], // Масив об'єктів, що представляють результати пошуку \n    \"loading\": false, // Булевий індикатор, чи відбувається завантаження результатів \n    \"error\": null, // Об'єкт або рядок для зберігання інформації про помилку, якщо така виникла \n    \"currentPage\": 1, // Поточна сторінка результатів (для пагінації) \n    \"totalResults\": 0 // Загальна кількість знайдених результатів \n  }, \n  \"ui\": { \n    \"isSearchInputFocused\": false, // Чи сфокусоване поле введення пошуку \n    \"showSearchResultsPanel\": false // Чи відображається панель з результатами пошуку \n  }, \n  \"userPreferences\": { \n    \"safeSearchEnabled\": true, \n    \"language\": \"uk\" \n  } \n  // ...інші можливі глобальні стани, наприклад, user, notifications, etc. \n} \n``` \n\n**Пояснення:** \n-   **`search.query`**: Це вхідні дані від користувача, які впливають на результати. \n-   **`search.results`**: Це дані, отримані з сервера, які відображаються на UI. \n-   **`search.loading`**: Це стан UI, який показує, що відбувається асинхронна операція, і користувач повинен чекати. \n-   **`search.error`**: Важливий для UX, щоб повідомити користувача про проблеми. \n-   **`search.currentPage` / `totalResults`**: Дозволяють керувати пагінацією та відображати інформацію про кількість результатів. \n-   **`ui.*`**: Стан, що стосується лише інтерфейсу (наприклад, чи відкритий якийсь модальний вікно, чи активна певна вкладка), хоча для простих UI-станів часто достатньо `useState` у компонентах."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q6-aq1",
        "question": "Чому `loading` і `error` стани є важливими для асинхронних операцій?",
        "answer": "`loading` індикатор дозволяє показати користувачеві, що відбувається завантаження даних, покращуючи UX. `error` стан дозволяє повідомити користувача про проблеми, що виникли під час запиту, і надати зворотний зв'язок, що є критично важливим для надійних застосунків."
      },
      {
        "id": "redux-q6-aq2",
        "question": "Як би ви розділили цей стан між кількома редюсерами?",
        "answer": "Для такого стану можна створити окремі редюсери, які відповідають за певні частини стану. Наприклад: \n-   `searchReducer` для стану `search`. \n-   `uiReducer` для стану `ui`. \n-   `userPreferencesReducer` для стану `userPreferences`. \nПотім ці редюсери об'єднуються за допомогою функції `combineReducers`."
      },
      {
        "id": "redux-q6-aq3",
        "question": "Чи варто зберігати DOM-елементи або їхні посилання в Redux state?",
        "answer": "Ні, категорично не варто. Redux state повинен містити лише прості JavaScript-об'єкти, масиви та примітиви, які можуть бути серіалізовані (тобто перетворені на JSON-рядки). Зберігання DOM-елементів або посилань на них у стані Redux порушує його принципи, ускладнює серіалізацію, робить стан непередбачуваним і унеможливлює використання Redux DevTools."
      }
    ]
  },
  {
    "id": "redux-q7",
    "topic": "Redux",
    "mainQuestion": "Що таке дії (actions)? Який у загальному випадку вони мають вигляд?",
    "mainAnswer": "**Дія (Action)** у Redux — це простий JavaScript-об'єкт, який описує подію, що сталася в застосунку. Це єдиний спосіб повідомити Redux Store, що вам потрібно змінити стан. \n\nДії є 'посилками' з даними, які ви надсилаєте зі свого застосунку до сховища. \n\n**Обов'язкові властивості дії:** \n-   **`type`**: Рядок-константа (наприклад, `'ADD_TODO'`, `'USER_LOGGED_IN'`), яка **обов'язково** визначає тип дії, що відбулася. Це поле є обов'язковим, і саме за цим типом редюсери визначають, як реагувати на дію. \n\n**Інші властивості:** \n-   **`payload`**: Зазвичай містить будь-які дані, необхідні для оновлення стану. Це може бути число, рядок, об'єкт або масив. Вміст `payload` залежить від конкретної дії. Термін `payload` не є обов'язковим, але є загальноприйнятою конвенцією. \n\n**Загальний вигляд дії:** \n```javascript \n{ \n  type: 'UNIQUE_ACTION_TYPE_STRING', \n  payload: { \n    // Будь-які дані, необхідні для обробки цієї дії в редюсері \n    // Зазвичай це дані, які 'прийшли' в результаті події \n  } \n} \n``` \n\n**Приклади дій:** \n```javascript \n// Дія додавання елемента до списку справ \n{ \n  type: 'ADD_TODO', \n  payload: { \n    id: 1, \n    text: 'Вивчити Redux', \n    completed: false \n  } \n} \n\n// Дія завантаження даних (початок) \n{ \n  type: 'FETCH_USERS_REQUEST' \n} \n\n// Дія завантаження даних (успіх) \n{ \n  type: 'FETCH_USERS_SUCCESS', \n  payload: { \n    users: [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }] \n  } \n} \n``` \nДії є основними будівельними блоками для опису того, що відбувається у вашому застосунку, і Redux Store є єдиним об'єктом, який їх отримує та обробляє.",
    "additionalQuestions": [
      {
        "id": "redux-q7-aq1",
        "question": "Хто створює та надсилає дії?",
        "answer": "Дії створюються за допомогою action creators (функцій, які повертають об'єкти дій), а надсилаються (dispatch) до сховища (store) зазвичай з компонентів React (або з middleware, або з інших частин застосунку) за допомогою методу `store.dispatch(action)`."
      },
      {
        "id": "redux-q7-aq2",
        "question": "Чи обов'язкова властивість `payload` у дії?",
        "answer": "Ні, властивість `payload` не є обов'язковою. Якщо дія просто повідомляє про подію, яка не вимагає додаткових даних для зміни стану (наприклад, `'TOGGLE_MENU'`), то `payload` може бути відсутнім."
      },
      {
        "id": "redux-q7-aq3",
        "question": "Чому тип дії має бути рядковою константою?",
        "answer": "Тип дії має бути рядковою константою, щоб зменшити ймовірність друкарських помилок та забезпечити передбачуваність. Використання констант дозволяє інструментам розробника (Redux DevTools) легше відстежувати дії, а також дозволяє TypeScript краще працювати з типами дій."
      }
    ]
  },
  {
    "id": "redux-q8",
    "topic": "Redux",
    "mainQuestion": "Що таке action creators? Чи обов’язково різні типи дій задавати константами?",
    "mainAnswer": "**Action Creator (Створювач дії)** — це функція, яка просто повертає об'єкт дії (Action). Це зручний спосіб інкапсулювати процес створення дії та гарантувати, що всі дії певного типу будуть мати послідовний вигляд. Вони допомагають уникнути дублювання коду та помилок. \n\n**Приклад Action Creator:** \n```javascript \n// Без Action Creator \n// dispatch({ type: 'ADD_TODO', payload: { id: 1, text: 'Купити хліб' } }); \n\n// З Action Creator \nconst addTodo = (id, text) => ({ \n  type: 'ADD_TODO', \n  payload: { id, text } \n}); \n// dispatch(addTodo(1, 'Купити хліб')); \n``` \n\n**Чи обов'язково різні типи дій задавати константами?** \n**Так, це дуже рекомендована практика**, хоча технічно не є абсолютною вимогою (Redux буде працювати і з рядками напряму). \n\n**Причини використання констант для типів дій:** \n1.  **Запобігання друкарським помилкам**: Якщо ви зробите друкарську помилку в назві константи, JavaScript видасть помилку під час компіляції (або раніше в редакторі), тоді як помилка в рядковому літералі може залишитися непоміченою до моменту виконання. \n2.  **Централізоване управління**: Усі типи дій зібрані в одному місці, що полегшує їх відстеження та підтримку. \n3.  **Автодоповнення та рефакторинг**: IDE може надавати автодоповнення для констант, а також полегшує рефакторинг (зміну назви) без ризику пропустити оновлення в усіх місцях використання. \n4.  **Redux DevTools**: Інструменти розробника краще працюють з чітко визначеними константами. \n\n**Приклад використання констант:** \n```javascript \n// constants.js \nexport const ADD_TODO = 'ADD_TODO'; \nexport const REMOVE_TODO = 'REMOVE_TODO'; \n\n// actions.js \nimport { ADD_TODO, REMOVE_TODO } from './constants'; \nexport const addTodo = (id, text) => ({ \n  type: ADD_TODO, \n  payload: { id, text } \n}); \nexport const removeTodo = (id) => ({ \n  type: REMOVE_TODO, \n  payload: { id } \n}); \n\n// reducer.js \nimport { ADD_TODO, REMOVE_TODO } from './constants'; \nfunction todosReducer(state = [], action) { \n  switch (action.type) { \n    case ADD_TODO: \n      return [...state, action.payload]; \n    case REMOVE_TODO: \n      return state.filter(todo => todo.id !== action.payload.id); \n    default: \n      return state; \n  } \n} \n```",
    "additionalQuestions": [
      {
        "id": "redux-q8-aq1",
        "question": "Яка роль `payload` в об'єкті дії?",
        "answer": "`payload` (корисне навантаження) — це загальноприйнята конвенція для назви властивості, яка містить дані, необхідні для того, щоб редюсер міг обробити дію та оновити стан. Це можуть бути будь-які дані: ідентифікатори, рядки, числа, об'єкти, масиви тощо."
      },
      {
        "id": "redux-q8-aq2",
        "question": "Чи обов'язково мати окремі файли для констант, action creators та редюсерів?",
        "answer": "Це загальноприйнята структура файлів у великих Redux-застосунках для кращої організації та відокремлення відповідальності. Однак для менших проектів або в рамках концепції 'ducks' (яка групує редюсер, action creators та типи дій в одному файлі) це не обов'язково."
      },
      {
        "id": "redux-q8-aq3",
        "question": "Яка перевага використання action creators над безпосереднім створенням об'єктів дій?",
        "answer": "Action creators централізують логіку створення дій, забезпечують послідовний формат дій, дозволяють легко додавати чи змінювати поля дії в майбутньому без зміни логіки в місцях виклику, а також полегшують тестування та інтеграцію з middleware (наприклад, Redux Thunk)."
      }
    ]
  },
  {
    "id": "redux-q9",
    "topic": "Redux",
    "mainQuestion": "Чому не можна змінювати окремі елементи стану, а треба оновлювати весь об’єкт стану? Як написати код у редюсері, що додаватиме до масиву `items` у стані рядок `'new item'`?",
    "mainAnswer": "**Чому не можна змінювати окремі елементи стану (мутувати)?** \nУ Redux стан є **імутабельним**. Це означає, що ви ніколи не повинні прямо змінювати об'єкт стану або його властивості. Натомість, при кожній зміні ви повинні створювати **нову копію об'єкта стану** з необхідними оновленнями. \n\n**Причини цього:** \n1.  **Виявлення змін**: Redux (та оптимізації в React, такі як `PureComponent` або `React.memo`) порівнює об'єкти за посиланням. Якщо ви мутуєте об'єкт, посилання на нього залишається тим самим, і Redux не побачить, що стан змінився, що призведе до того, що UI не буде оновлюватися. \n2.  **Time-travel debugging**: Для можливості 'подорожувати в часі' по стану, Redux зберігає історію знімків стану. Це можливо лише якщо кожен знімок є імутабельним і не залежить від попередніх змін. \n3.  **Чистота редюсерів**: Редюсери є чистими функціями, які не мають побічних ефектів, включаючи мутацію своїх аргументів. \n4.  **Прогнозованість**: Імутабельність робить потік даних більш передбачуваним і спрощує відлагодження, запобігаючи несподіваним побічним ефектам. \n\n**Як написати код у редюсері, що додаватиме до масиву `items` у стані рядок `'new item'`?** \nПрипустимо, ваш початковий стан виглядає так: \n```javascript \nconst initialState = { \n  user: { name: 'Роман' }, \n  items: ['apple', 'banana'] \n}; \n``` \nЩоб додати `'new item'` до масиву `items` без мутації, ви повинні створити нові копії всіх об'єктів/масивів на шляху до `items`. Використовуйте оператор спред (`...`): \n\n```javascript \nfunction myReducer(state = initialState, action) { \n  switch (action.type) { \n    case 'ADD_NEW_ITEM': \n      return { \n        ...state, // Копіюємо всі властивості об'єкта state \n        items: [...state.items, 'new item'] // Створюємо новий масив items \n      }; \n    default: \n      return state; \n  } \n} \n``` \n**Пояснення:** \n-   `...state`: Створює поверхневу копію кореневого об'єкта `state`. \n-   `items: [...state.items, 'new item']`: Створює **новий масив**, який включає всі елементи старого `state.items` та новий елемент `'new item'`. Цей новий масив замінює старий `items` у новій копії стану. \n\nТаким чином, оригінальний об'єкт `state` та його масив `items` залишаються незмінними, а редюсер повертає абсолютно новий об'єкт стану з оновленими `items`.",
    "additionalQuestions": [
      {
        "id": "redux-q9-aq1",
        "question": "Які методи JavaScript допомагають працювати з імутабельними масивами?",
        "answer": "Для імутабельного оновлення масивів використовують: \n-   `[...oldArray, newItem]` (додати елемент) \n-   `oldArray.filter(item => item.id !== id)` (видалити елемент) \n-   `oldArray.map(item => item.id === id ? { ...item, updatedProp: newValue } : item)` (оновлення елемента) \n-   `oldArray.slice()` (поверхнева копія)"
      },
      {
        "id": "redux-q9-aq2",
        "question": "Які методи JavaScript допомагають працювати з імутабельними об'єктами?",
        "answer": "Для імутабельного оновлення об'єктів використовують: \n-   `{ ...oldObject, newProp: value }` (додати/змінити властивість) \n-   `Object.assign({}, oldObject, { newProp: value })` (те ж саме, але менш сучасний синтаксис) \nДля видалення властивості: `{ ...oldObject, [keyToDelete]: undefined }` або використання деструктуризації: `const { [keyToDelete], ...rest } = oldObject; return rest;`."
      },
      {
        "id": "redux-q9-aq3",
        "question": "Яка бібліотека допомагає писати 'мутуючий' код, який насправді генерує імутабельні оновлення?",
        "answer": "Бібліотека **Immer** дозволяє писати більш простий, 'мутуючий' код у редюсерах, а вона сама дбає про створення імутабельних копій. Це значно зменшує бойлерплейт і ризик помилок. Наприклад, з Immer: `return produce(state, draft => { draft.items.push('new item'); });`."
      }
    ]
  },
  {
    "id": "redux-q10",
    "topic": "Redux",
    "mainQuestion": "Що таке сховище (store)? Які в нього є методи і події?",
    "mainAnswer": "**Сховище (Store)** — це об'єкт, який є єдиним джерелом істини для всього стану вашого Redux-застосунку. Всі зміни стану проходять через сховище. Це центральний вузол Redux-архітектури. \n\nСховище створюється за допомогою функції `createStore` з Redux (або `configureStore` з Redux Toolkit) і є лише один `store` на застосунок. \n\n**Основні методи сховища:** \n1.  **`getState()`**: \n    -   **Призначення:** Повертає поточний повний об'єкт стану Redux. \n    -   **Використання:** `const currentState = store.getState();` \n2.  **`dispatch(action)`**: \n    -   **Призначення:** Єдиний спосіб змінити стан у Redux. Ви надсилаєте об'єкт дії до сховища. Коли дія надсилається, Redux передає її поточний стан та дію до редюсера, який обчислює новий стан. \n    -   **Використання:** `store.dispatch({ type: 'INCREMENT' });` \n3.  **`subscribe(listener)`**: \n    -   **Призначення:** Дозволяє підписатися на зміни стану. Функція `listener` (слухач) буде викликана щоразу, коли стан зміниться. \n    -   **Використання:** `const unsubscribe = store.subscribe(() => { console.log('Стан змінився:', store.getState()); });` \n    -   Повертає функцію `unsubscribe`, яку можна викликати для відписки: `unsubscribe();` \n\n**Події сховища (внутрішні, не прямі методи для виклику):** \nХоча Redux Store не має 'подій' у традиційному сенсі (на кшталт `EventEmitter`), метод `subscribe` по суті є механізмом підписки на внутрішню подію 'зміна стану'. Коли стан змінюється, Redux автоматично викликає всі підписані слухачі. \n\n**Важливо:** У React-Redux (бібліотека для інтеграції Redux з React) ви рідко використовуєте `store.subscribe` напряму, оскільки `react-redux` (зокрема хуки `useSelector` або функція `connect`) автоматично керує підписками для ваших компонентів.",
    "additionalQuestions": [
      {
        "id": "redux-q10-aq1",
        "question": "Як Redux Toolkit спрощує створення сховища?",
        "answer": "Redux Toolkit надає функцію `configureStore`, яка значно спрощує налаштування сховища. Вона автоматично включає Redux DevTools, додає `redux-thunk` middleware (для асинхронних дій) та об'єднує редюсери, зменшуючи бойлерплейт."
      },
      {
        "id": "redux-q10-aq2",
        "question": "Чи можна мати кілька сховищ у Redux-застосунку?",
        "answer": "Технічно можна, але це **категорично не рекомендується** і є антипатерном у Redux. Основний принцип Redux — 'єдине джерело істини' (Single Source of Truth), що означає, що весь стан застосунку повинен знаходитися в одному сховищі. Наявність кількох сховищ руйнує передбачуваність, ускладнює налагодження та управління станом."
      },
      {
        "id": "redux-q10-aq3",
        "question": "У чому перевага `dispatch` над прямою зміною стану?",
        "answer": "`dispatch` забезпечує, що всі зміни стану відбуваються через стандартизований, відстежуваний та передбачуваний механізм. Це дозволяє Redux DevTools відстежувати кожну дію, застосовувати middleware, перевіряти стан та забезпечувати його імутабельність. Пряма зміна стану обходить усі ці механізми, призводячи до непередбачуваної поведінки."
      }
    ]
  }
]