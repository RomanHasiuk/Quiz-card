[
  {
    "id": "css-q18",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між `display: none`, `visibility: hidden` та `opacity: 0`?",
    "mainAnswer": "`display: none` повністю видаляє елемент з документа, він не займає місця і не взаємодіє з подіями. `visibility: hidden` приховує елемент, але він все ще займає своє місце в макеті та може впливати на інші елементи, але не взаємодіє з подіями. `opacity: 0` робить елемент повністю прозорим, він залишається на місці, займає простір, взаємодіє з подіями, але візуально невидимий.",
    "additionalQuestions": [
      {
        "id": "css-q18-aq1",
        "question": "Який метод кращий для приховування елемента, якщо потрібно зберегти його місце в макеті?",
        "answer": "`visibility: hidden` або `opacity: 0`."
      },
      {
        "id": "css-q18-aq2",
        "question": "Який метод впливає на SEO та доступність?",
        "answer": "`display: none` повністю приховує елемент від скрін-рідерів та пошукових систем. `visibility: hidden` та `opacity: 0` приховують візуально, але контент все ще доступний для скрін-рідерів та обробляється пошуковими системами."
      },
      {
        "id": "css-q18-aq3",
        "question": "Який метод дозволяє анімувати проявлення/зникнення?",
        "answer": "`visibility: hidden` (з `transition` на `visibility: visible`) та `opacity: 0` (з `transition` на `opacity: 1`) можуть бути анімовані, на відміну від `display: none`."
      }
    ]
  },
  {
    "id": "css-q19",
    "topic": "CSS",
    "mainQuestion": "Що таке 'візуально прихований' фрагмент коду (visually hidden snippet)?",
    "mainAnswer": "'Візуально прихований' фрагмент коду CSS — це набір правил, який дозволяє приховати елемент візуально з екрана, але зберегти його доступним для скрін-рідерів та інших допоміжних технологій. Це досягається шляхом зменшення розміру елемента до 1px на 1px, обрізання вмісту, видалення видимих меж та переміщення його за межі екрану.",
    "additionalQuestions": [
      {
        "id": "css-q19-aq1",
        "question": "Наведіть приклад використання 'візуально прихованого' фрагмента.",
        "answer": "Використовується для приховування текстових міток для іконок, додаткових пояснень для елементів форм або навігаційних посилань 'Skip to main content' для покращення доступності."
      },
      {
        "id": "css-q19-aq2",
        "question": "Які CSS-властивості зазвичай входять у 'візуально прихований' фрагмент?",
        "answer": "Типові властивості: `position: absolute;`, `width: 1px;`, `height: 1px;`, `margin: -1px;`, `padding: 0;`, `overflow: hidden;`, `clip: rect(0 0 0 0);`, `white-space: nowrap;`, `border: 0;`."
      },
      {
        "id": "css-q19-aq3",
        "question": "У чому відмінність від `display: none` для доступності?",
        "answer": "На відміну від `display: none`, який повністю приховує елемент від усіх, 'візуально прихований' фрагмент робить елемент невидимим *візуально*, але доступним для скрін-рідерів, що є критично важливим для інклюзивного дизайну."
      }
    ]
  },
  {
    "id": "css-q20",
    "topic": "CSS",
    "mainQuestion": "Перелічіть усі способи центрування елементів горизонтально та вертикально. Окремо для `inline` та `block` елементів.",
    "mainAnswer": "Горизонтальне центрування: **Блоковий елемент:** `margin: 0 auto;`. **Inline/inline-block:** `text-align: center;` на батьківському елементі. **Flexbox:** `justify-content: center;` на контейнері. **Grid:** `justify-items: center;` або `justify-self: center;`. \nВертикальне центрування: **Блоковий елемент (з відомою висотою):** `position: absolute; top: 50%; transform: translateY(-50%);`. **Inline/inline-block (один рядок):** `line-height` = `height`. **Flexbox:** `align-items: center;` на контейнері. **Grid:** `align-items: center;` або `align-self: center;`. **Застарілі:** `vertical-align` (для inline), `table-cell`.",
    "additionalQuestions": [
      {
        "id": "css-q20-aq1",
        "question": "Який спосіб центрування вважається найгнучкішим і сучасним?",
        "answer": "Flexbox та CSS Grid є найбільш гнучкими та сучасними способами центрування як горизонтально, так і вертикально, для різних типів елементів."
      },
      {
        "id": "css-q20-aq2",
        "question": "Як центрувати `block` елемент горизонтально без Flexbox/Grid?",
        "answer": "Для блокового елемента з фіксованою або максимальною шириною використовується `margin: 0 auto;`."
      },
      {
        "id": "css-q20-aq3",
        "question": "Чи можна центрувати текст всередині `div` за допомогою `margin: 0 auto;`?",
        "answer": "Ні, `margin: 0 auto;` центрує сам блоковий елемент. Щоб центрувати *текст* всередині блокового елемента, використовується `text-align: center;`."
      }
    ]
  },
  {
    "id": "css-q21",
    "topic": "CSS",
    "mainQuestion": "Що таке Flexbox?",
    "mainAnswer": "Flexbox (Flexible Box Layout module) — це одномірна система макета CSS, яка дозволяє легко вирівнювати та розподіляти простір між елементами в контейнері, навіть якщо їхній розмір невідомий або динамічний. Він ідеально підходить для створення складних компонентів та навігації.",
    "additionalQuestions": [
      {
        "id": "css-q21-aq1",
        "question": "Яка головна відмінність Flexbox від Grid?",
        "answer": "Flexbox є одномірним (працює або по рядку, або по стовпцю), тоді як CSS Grid є двомірним (працює одночасно по рядках і стовпцях)."
      },
      {
        "id": "css-q21-aq2",
        "question": "Які основні поняття Flexbox?",
        "answer": "Основні поняття: flex-контейнер (батьківський елемент), flex-елементи (дочірні елементи), main axis (головна вісь) та cross axis (поперечна вісь)."
      },
      {
        "id": "css-q21-aq3",
        "question": "Яка CSS властивість активує Flexbox для елемента?",
        "answer": "Властивість `display: flex;` на батьківському елементі робить його flex-контейнером."
      }
    ]
  },
  {
    "id": "css-q22",
    "topic": "CSS",
    "mainQuestion": "Як ми можемо змінити порядок елементів у Flexbox?",
    "mainAnswer": "Порядок елементів у Flexbox можна змінити за допомогою властивості `order` на flex-елементах. Елементи з меншим значенням `order` відображаються раніше. За замовчуванням `order` дорівнює `0`.",
    "additionalQuestions": [
      {
        "id": "css-q22-aq1",
        "question": "Чи впливає `order` на DOM-порядок?",
        "answer": "Ні, властивість `order` впливає лише на візуальний порядок відображення елементів у Flexbox, не змінюючи їхнього порядку в DOM-дереві. Це важливо для доступності та SEO."
      },
      {
        "id": "css-q22-aq2",
        "question": "Які значення може приймати властивість `order`?",
        "answer": "`order` приймає цілі числа, включаючи від'ємні. Елементи з меншим значенням відображаються раніше."
      },
      {
        "id": "css-q22-aq3",
        "question": "Навіщо може знадобитися змінювати порядок елементів у Flexbox?",
        "answer": "Це корисно для адаптивного дизайну, коли потрібно змінити візуальне розташування елементів на різних розмірах екрана, або для логічного упорядкування контенту без зміни HTML-структури."
      }
    ]
  },
  {
    "id": "css-q23",
    "topic": "CSS",
    "mainQuestion": "Як працює `margin: auto` у Flexbox?",
    "mainAnswer": "У Flexbox, `margin: auto` на flex-елементі поглинає весь доступний простір у напрямку осі, на якій він застосований. Якщо застосовано `margin: auto` з одного боку, воно розсуне елемент до відповідного краю. Якщо з двох протилежних боків (наприклад, `margin-left: auto; margin-right: auto;` або просто `margin: auto;`), воно центрує елемент по цій осі.",
    "additionalQuestions": [
      {
        "id": "css-q23-aq1",
        "question": "Як `margin: auto` відрізняється в Flexbox порівняно зі звичайним блоковим елементом?",
        "answer": "У звичайному блоковому елементі `margin: auto` центрує його лише горизонтально. У Flexbox `margin: auto` може центрувати елемент як горизонтально, так і вертикально, залежно від `flex-direction` та осі, де застосовано `auto`."
      },
      {
        "id": "css-q23-aq2",
        "question": "Як центрувати елемент вертикально за допомогою `margin: auto` у Flexbox?",
        "answer": "Якщо `flex-direction: row;`, то `margin-top: auto; margin-bottom: auto;` (або `margin: auto 0;`) на flex-елементі вирівняє його вертикально. Якщо `flex-direction: column;`, то `margin: auto;` центрує його вертикально."
      },
      {
        "id": "css-q23-aq3",
        "question": "Чи може `margin: auto` працювати з кількома Flex-елементами одночасно?",
        "answer": "Так. Якщо `margin: auto` застосовано до кількох елементів, вони рівномірно розподілять між собою доступний простір."
      }
    ]
  },
  {
    "id": "css-q24",
    "topic": "CSS",
    "mainQuestion": "Що означають `object-fit: cover` та `object-fit: contain`?",
    "mainAnswer": "Властивість `object-fit` використовується для управління тим, як вміст `<img>` або `<video>` елемента масштабується та обрізається відповідно до розмірів контейнера. `cover`: вміст масштабується, щоб повністю заповнити контейнер, обрізаючи частини, які виходять за межі. Зберігає співвідношення сторін. `contain`: вміст масштабується, щоб поміститися всередині контейнера повністю, зберігаючи співвідношення сторін. Може залишати порожні області (літербокси).",
    "additionalQuestions": [
      {
        "id": "css-q24-aq1",
        "question": "Яке значення `object-fit` є типовим за замовчуванням?",
        "answer": "За замовчуванням `object-fit` має значення `fill`, яке розтягує або стискає вміст, щоб повністю заповнити контейнер, ігноруючи співвідношення сторін."
      },
      {
        "id": "css-q24-aq2",
        "question": "Коли краще використовувати `object-fit: cover`?",
        "answer": "`object-fit: cover` ідеально підходить для фонових зображень або банерів, коли потрібно, щоб зображення повністю заповнювало область, навіть якщо деякі частини обрізаються."
      },
      {
        "id": "css-q24-aq3",
        "question": "Коли краще використовувати `object-fit: contain`?",
        "answer": "`object-fit: contain` краще використовувати, коли важливо показати все зображення без обрізки, наприклад, для логотипів, іконок або галереї зображень, де простір навколо зображення допустимий."
      }
    ]
  },
  {
    "id": "css-q25",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між векторною та растровою графікою?",
    "mainAnswer": "Растрова графіка (наприклад, JPG, PNG, GIF) складається з сітки пікселів. Вона втрачає якість при масштабуванні. Векторна графіка (наприклад, SVG) складається з математичних формул, що описують лінії, криві та фігури. Вона зберігає якість при будь-якому масштабуванні і має менший розмір файлу.",
    "additionalQuestions": [
      {
        "id": "css-q25-aq1",
        "question": "Для яких цілей краще використовувати растрову графіку?",
        "answer": "Растрову графіку краще використовувати для фотографій, складних зображень з великою кількістю кольорів та деталей, або коли потрібна реалістична текстура."
      },
      {
        "id": "css-q25-aq2",
        "question": "Для яких цілей краще використовувати векторну графіку?",
        "answer": "Векторну графіку ідеально використовувати для логотипів, іконок, ілюстрацій, діаграм, шрифтів та будь-яких елементів, які повинні виглядати чітко на будь-якому розмірі екрана."
      },
      {
        "id": "css-q25-aq3",
        "question": "Які формати файлів для векторної та растрової графіки поширені у вебі?",
        "answer": "Растрові: `.jpg`, `.png`, `.gif`, `.webp`, `.avif`. Векторні: `.svg`."
      }
    ]
  },
  {
    "id": "css-q26",
    "topic": "CSS",
    "mainQuestion": "Поясніть різні види трансформацій (transforms) у CSS.",
    "mainAnswer": "CSS Transforms дозволяють змінювати розмір, обертати, нахиляти та переміщувати елементи в 2D або 3D просторі, не впливаючи на інші елементи в документі. Основні функції: `translate()` (переміщення), `rotate()` (обертання), `scale()` (зміна розміру), `skew()` (нахил). Вони можуть бути застосовані індивідуально або комбіновано.",
    "additionalQuestions": [
      {
        "id": "css-q26-aq1",
        "question": "У чому перевага використання `transform` для анімації переміщення над `top`/`left`?",
        "answer": "`transform` виконується на GPU (графічному процесорі), що забезпечує більш плавну та продуктивну анімацію, оскільки не викликає перемальовування (repaint) або перекомпонування (reflow) макета, на відміну від `top`/`left`."
      },
      {
        "id": "css-q26-aq2",
        "question": "Що таке `transform-origin`?",
        "answer": "`transform-origin` дозволяє визначити точку, навколо якої відбуваються трансформації (наприклад, центр обертання або масштабування). За замовчуванням це центр елемента."
      },
      {
        "id": "css-q26-aq3",
        "question": "Чи можуть `transform` властивості впливати на потік документа?",
        "answer": "Ні, `transform` не впливає на потік документа. Елемент лише візуально змінюється, але його початкове місце в макеті залишається незмінним, тому він не посуне сусідні елементи."
      }
    ]
  },
  {
    "id": "css-q27",
    "topic": "CSS",
    "mainQuestion": "Що таке `transition` у CSS3? Поясніть синтаксис.",
    "mainAnswer": "CSS `transition` дозволяє плавно змінювати значення CSS-властивостей протягом певного періоду часу, створюючи анімаційні ефекти без використання JavaScript. Синтаксис: `transition: [property] [duration] [timing-function] [delay];`.",
    "additionalQuestions": [
      {
        "id": "css-q27-aq1",
        "question": "Наведіть приклад використання `transition`.",
        "answer": "`button { background-color: blue; transition: background-color 0.3s ease-in-out; } button:hover { background-color: red; }` - плавна зміна кольору фону при наведенні."
      },
      {
        "id": "css-q27-aq2",
        "question": "Які значення може приймати `timing-function`?",
        "answer": "Типові значення: `ease` (повільно на початку і в кінці), `linear` (рівномірно), `ease-in` (повільно на початку), `ease-out` (повільно в кінці), `ease-in-out` (повільно на початку і в кінці). Можна використовувати `cubic-bezier()` для кастомних функцій."
      },
      {
        "id": "css-q27-aq3",
        "question": "Чи можна анімувати всі CSS-властивості за допомогою `transition`?",
        "answer": "Ні, не всі. Можна анімувати лише властивості, які мають 'проміжні стани' (тобто числові значення, кольори, розміри, позиції). Властивості на кшталт `display` або `visibility` не можуть бути плавно анімовані безпосередньо."
      }
    ]
  },
  {
    "id": "css-q28",
    "topic": "CSS",
    "mainQuestion": "Що таке `animation` у CSS3? Поясніть синтаксис.",
    "mainAnswer": "CSS `animation` дозволяє створювати складніші анімації з кількома кроками (ключовими кадрами) та більшим контролем над їхнім виконанням, на відміну від простих `transition`. Синтаксис: `@keyframes animation-name { from { ... } to { ... } }` та `element { animation: [name] [duration] [timing-function] [delay] [iteration-count] [direction] [fill-mode] [play-state]; }`.",
    "additionalQuestions": [
      {
        "id": "css-q28-aq1",
        "question": "У чому головна відмінність між `transition` та `animation`?",
        "answer": "`transition` - це проста анімація між двома станами (наприклад, при наведенні курсора). `animation` - дозволяє створювати складні анімації з кількома ключовими кадрами, циклічним повторенням та більшим контролем над часом."
      },
      {
        "id": "css-q28-aq2",
        "question": "Що таке `@keyframes`?",
        "answer": "`@keyframes` — це правило CSS, яке визначає послідовність анімації, задаючи стилі в конкретних точках (відсотках) її виконання."
      },
      {
        "id": "css-q28-aq3",
        "question": "Які властивості `animation` контролюють повторення та напрямок анімації?",
        "answer": "`animation-iteration-count` (скільки разів повторити) та `animation-direction` (нормально, зворотньо, поперемінно) контролюють повторення та напрямок."
      }
    ]
  },
  {
    "id": "css-q29",
    "topic": "CSS",
    "mainQuestion": "Які властивості кращі для анімацій? Чому `transform` та `opacity` є кращими?",
    "mainAnswer": "Для анімацій краще використовувати властивості, які не викликають 'reflow' (перекомпонування) та 'repaint' (перемальовування) браузером, а натомість використовують GPU для 'compositing'. `transform` (переміщення, обертання, масштабування) та `opacity` (прозорість) є кращими, оскільки вони відносно дешеві з точки зору продуктивності, оскільки впливають лише на композицію шарів і не змушують браузер перераховувати макет сторінки.",
    "additionalQuestions": [
      {
        "id": "css-q29-aq1",
        "question": "Які CSS-властивості варто уникати для анімацій через продуктивність?",
        "answer": "Варто уникати анімації властивостей, які впливають на макет (`width`, `height`, `margin`, `padding`, `top`, `left`) або на 'paint' (`color`, `background-color`, `box-shadow`) без певних оптимізацій, оскільки вони викликають дорогі операції reflow/repaint."
      },
      {
        "id": "css-q29-aq2",
        "question": "Що означає 'reflow' та 'repaint' у браузері?",
        "answer": "'Reflow' (або 'layout') — це перерахунок розташування та розмірів усіх елементів на сторінці. 'Repaint' — це перемальовування пікселів елементів. Обидві операції є ресурсоємними і можуть призвести до 'лагів' в анімації."
      },
      {
        "id": "css-q29-aq3",
        "question": "Як `will-change` властивість допомагає оптимізувати анімації?",
        "answer": "`will-change` є підказкою для браузера, що певна властивість елемента буде змінена в майбутньому (наприклад, анімована), дозволяючи браузеру заздалегідь виконати деякі оптимізації, такі як перенесення елемента на окремий шар GPU."
      }
    ]
  },
  {
    "id": "css-q30",
    "topic": "CSS",
    "mainQuestion": "Як писати ефективний CSS? Поясніть загальні правила, технології, методології.",
    "mainAnswer": "Ефективний CSS — це читабельний, підтримуваний, масштабований та продуктивний код. Загальні правила: використання семантичного HTML, мінімізація вкладеності селекторів, використання коротких властивостей, зменшення використання `!important`. Технології: препроцесори (Sass, Less), PostCSS, CSS-змінні. Методології: BEM, OOCSS, SMACSS, CSS Modules, Styled Components — вони допомагають організувати код та уникнути конфліктів.",
    "additionalQuestions": [
      {
        "id": "css-q30-aq1",
        "question": "Які переваги використання CSS-препроцесорів?",
        "answer": "Препроцесори додають функціонал, якого немає в чистому CSS (змінні, міксини, вкладеність, функції), що робить код більш організованим, читабельним та легким для підтримки."
      },
      {
        "id": "css-q30-aq2",
        "question": "Що таке 'CSS-in-JS'?",
        "answer": "'CSS-in-JS' — це підхід, при якому CSS пишеться безпосередньо в JavaScript-коді, що забезпечує інкапсуляцію стилів для компонентів та динамічну генерацію стилів."
      },
      {
        "id": "css-q30-aq3",
        "question": "Чому мінімізація вкладеності селекторів є важливою для продуктивності?",
        "answer": "Більш вкладені (складні) селектори вимагають від браузера більше часу для обчислення їхньої специфічності та застосування стилів, що може уповільнювати рендеринг сторінки. Простіші селектори працюють швидше."
      }
    ]
  },
  {
    "id": "css-q31",
    "topic": "CSS",
    "mainQuestion": "Що таке методології CSS?",
    "mainAnswer": "Методології CSS — це набори правил та принципів для організації та структурування CSS-коду у великих проектах. Їхня мета — забезпечити читабельність, підтримуваність, масштабованість та уникнення конфліктів стилів, особливо при роботі в команді.",
    "additionalQuestions": [
      {
        "id": "css-q31-aq1",
        "question": "Наведіть кілька прикладів популярних методологій CSS.",
        "answer": "BEM (Block, Element, Modifier), OOCSS (Object-Oriented CSS), SMACSS (Scalable and Modular Architecture for CSS), ITCSS (Inverted Triangle CSS)."
      },
      {
        "id": "css-q31-aq2",
        "question": "Які переваги використання методології CSS?",
        "answer": "Покращена організація коду, легша підтримка, зменшення конфліктів, полегшення співпраці в команді, можливість повторного використання компонентів."
      },
      {
        "id": "css-q31-aq3",
        "question": "Чи є недоліки у використанні методологій CSS?",
        "answer": "Деякі методології можуть бути занадто багатослівними (наприклад, BEM з довгими іменами класів) або мати круту криву навчання для нових розробників."
      }
    ]
  },
  {
    "id": "css-q32",
    "topic": "CSS",
    "mainQuestion": "Поясніть методологію BEM.",
    "mainAnswer": "BEM (Block, Element, Modifier) — це методологія іменування класів CSS, яка допомагає створювати модульний, повторно використовуваний та масштабований код. Вона розділяє інтерфейс на незалежні блоки (Block), їхні складові частини (Element) та стани/варіації (Modifier). Наприклад: `block__element--modifier`.",
    "additionalQuestions": [
      {
        "id": "css-q32-aq1",
        "question": "Що таке 'Блок' у BEM?",
        "answer": "Блок — це незалежний, функціонально завершений компонент інтерфейсу, який можна використовувати повторно (наприклад, `header`, `button`, `form`)."
      },
      {
        "id": "css-q32-aq2",
        "question": "Що таке 'Елемент' у BEM?",
        "answer": "Елемент — це частина Блоку, яка не має самостійного значення і не може використовуватися поза контекстом свого Блоку (наприклад, `header__logo`, `button__icon`, `form__input`)."
      },
      {
        "id": "css-q32-aq3",
        "question": "Що таке 'Модифікатор' у BEM?",
        "answer": "Модифікатор — це сутність, яка визначає зовнішній вигляд або поведінку Блоку або Елемента (наприклад, `button--primary`, `form--disabled`, `header__logo--small`)."
      }
    ]
  },
  {
    "id": "css-q33",
    "topic": "CSS",
    "mainQuestion": "Що таке Stylelint? Коли його використовувати?",
    "mainAnswer": "Stylelint — це потужний, сучасний 'лінтинг' (linting) інструмент для CSS, Sass, Less та інших препроцесорів. Він допомагає виявляти помилки, дотримуватися стандартів кодування, забезпечувати послідовність стилів та запобігати антипатернам. Його варто використовувати у будь-якому проекті для забезпечення високої якості та єдності CSS-коду.",
    "additionalQuestions": [
      {
        "id": "css-q33-aq1",
        "question": "Які переваги використання лінтерів, таких як Stylelint?",
        "answer": "Лінтери покращують якість коду, запобігають помилкам, підтримують єдиний стиль кодування в команді, допомагають дотримуватися кращих практик та забезпечують швидший зворотний зв'язок розробникам."
      },
      {
        "id": "css-q33-aq2",
        "question": "Чи можна інтегрувати Stylelint у процес збірки проекту?",
        "answer": "Так, Stylelint можна інтегрувати в системи збірки (наприклад, Webpack, Gulp, Rollup) або системи контролю версій (через pre-commit хуки), щоб автоматично перевіряти код перед його комітом."
      },
      {
        "id": "css-q33-aq3",
        "question": "Чи підтримує Stylelint кастомні правила?",
        "answer": "Так, Stylelint дозволяє створювати власні правила або використовувати плагіни для розширення його функціоналу відповідно до унікальних потреб проекту."
      }
    ]
  },
  {
    "id": "css-q34",
    "topic": "CSS",
    "mainQuestion": "Що таке вендорні префікси (vendor prefixes)?",
    "mainAnswer": "Вендорні префікси — це префікси, які додаються до експериментальних або нестандартних CSS-властивостей, щоб дозволити браузерам реалізувати або тестувати ці властивості до того, як вони стануть частиною офіційного стандарту. Наприклад: `-webkit-` для Chrome/Safari, `-moz-` для Firefox, `-ms-` для Internet Explorer, `-o-` для Opera.",
    "additionalQuestions": [
      {
        "id": "css-q34-aq1",
        "question": "Чи потрібно вручну додавати вендорні префікси?",
        "answer": "Ні, вручну додавати не рекомендується. Використовують інструменти, такі як Autoprefixer (з PostCSS), які автоматично додають потрібні префікси на основі вказаних версій браузерів."
      },
      {
        "id": "css-q34-aq2",
        "question": "Чи потрібні вендорні префікси у сучасному вебі?",
        "answer": "Вони потрібні все рідше, оскільки більшість сучасних CSS-властивостей вже стандартизовані. Однак для деяких нових або експериментальних властивостей вони все ще можуть бути потрібні для підтримки старих браузерів."
      },
      {
        "id": "css-q34-aq3",
        "question": "Яка головна проблема використання вендорних префіксів?",
        "answer": "Головна проблема полягає в тому, що вони збільшують обсяг CSS-коду, вимагають оновлення та можуть призвести до фрагментації, якщо розробники забувають про них або не використовують автоматичні інструменти."
      }
    ]
  }
]