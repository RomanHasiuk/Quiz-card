[
  {
    "id": "ts-q1",
    "topic": "TypeScript",
    "mainQuestion": "Що таке TypeScript і яка його мета?",
    "mainAnswer": "TypeScript — це надмножина JavaScript з відкритим вихідним кодом, розроблена Microsoft, яка компілюється в чистий JavaScript. Його основна мета — додати статичну типізацію до JavaScript, що дозволяє виявляти помилки типу на етапі компіляції (до запуску коду), а не під час виконання. Це покращує масштабованість, читабельність, підтримуваність коду та надає кращу підтримку для інструментів розробки (наприклад, автодоповнення, рефакторинг).",
    "additionalQuestions": [
      {
        "id": "ts-q1-aq1",
        "question": "У чому головна перевага TypeScript над JavaScript?",
        "answer": "Головна перевага — це статична типізація, яка дозволяє виявляти багато помилок на етапі розробки, перш ніж код потрапить до продакшну. Це робить код більш надійним та зручним для рефакторингу."
      },
      {
        "id": "ts-q1-aq2",
        "question": "Чи є TypeScript мовою, що інтерпретується, чи компілюється?",
        "answer": "TypeScript є мовою, що компілюється. Він компілюється (або транспілюється) в JavaScript, який потім вже інтерпретується браузерами або Node.js."
      },
      {
        "id": "ts-q1-aq3",
        "question": "Чи потрібно вивчати JavaScript перед TypeScript?",
        "answer": "Так, оскільки TypeScript є надмножиною JavaScript, глибоке розуміння JavaScript є фундаментальним. TypeScript додає до JavaScript нові функції, але базовий синтаксис та концепції залишаються тими ж."
      }
    ]
  },
  {
    "id": "ts-q2",
    "topic": "TypeScript",
    "mainQuestion": "Як працювати з масивами в TypeScript?",
    "mainAnswer": "У TypeScript масиви можуть бути типізовані, щоб вказати тип елементів, які вони містять. Це забезпечує безпеку типу. Існує два основних способи типізувати масив: \n1. **`ElementType[]`**: Найпоширеніший спосіб. Наприклад, `let numbers: number[] = [1, 2, 3];` \n2. **`Array<ElementType>` (генеричний тип)**: Еквівалентний першому. Наприклад, `let names: Array<string> = ['Roman', 'Maria'];` \nTypeScript також підтримує кортежі (tuples) — масиви фіксованої довжини, де кожен елемент має свій визначений тип: `let person: [string, number] = ['Dmytro', 6];`",
    "additionalQuestions": [
      {
        "id": "ts-q2-aq1",
        "question": "Що станеться, якщо спробувати додати елемент неправильного типу до типізованого масиву?",
        "answer": "TypeScript видасть помилку компіляції, що не дозволить додати елемент неправильного типу до масиву."
      },
      {
        "id": "ts-q2-aq2",
        "question": "У чому відмінність між масивом та кортежем?",
        "answer": "Масив має змінну довжину і всі елементи одного типу (або об'єднання типів), тоді як кортеж має фіксовану довжину, і кожен елемент на конкретній позиції має свій визначений тип."
      },
      {
        "id": "ts-q2-aq3",
        "question": "Як оголосити масив, який може містити як рядки, так і числа?",
        "answer": "Використовуйте об'єднаний тип (union type): `let mixedArray: (string | number)[] = ['hello', 123, 'world'];`"
      }
    ]
  },
  {
    "id": "ts-q3",
    "topic": "TypeScript",
    "mainQuestion": "Як працювати з об'єктами в TypeScript? Що таке інтерфейс (interface)?",
    "mainAnswer": "У TypeScript об'єкти типізуються за допомогою анонімних об'єктних типів або за допомогою **інтерфейсів** та **аліасів типів (type aliases)**. \n**Інтерфейс** — це потужний засіб для визначення 'контрактів' форми об'єктів. Він дозволяє описати структуру об'єкта, вказуючи імена та типи його властивостей, а також методи. Інтерфейси покращують читабельність коду, дозволяють перевикористовувати визначення типів та забезпечують перевірку типу на етапі компіляції. \nПриклад інтерфейсу: `interface User { name: string; age: number; isActive?: boolean; }` \nПриклад використання: `let roman: User = { name: 'Roman', age: 30, isActive: true };`",
    "additionalQuestions": [
      {
        "id": "ts-q3-aq1",
        "question": "У чому різниця між `interface` та `type` (аліасом типу) для опису об'єктів?",
        "answer": "Обидва можуть використовуватися для опису форми об'єктів. `interface` може бути 'відкритим' (тобто можна оголосити декілька інтерфейсів з одним іменем, і вони об'єднаються), і він краще підходить для оголошення форм об'єктів, які будуть розширюватися. `type` більш гнучкий, може використовуватися для об'єднань, кортежів, примітивних типів і не об'єднується. Зазвичай для об'єктних типів перевага надається `interface` через його розширюваність."
      },
      {
        "id": "ts-q3-aq2",
        "question": "Як зробити властивість об'єкта необов'язковою?",
        "answer": "Для цього використовується `?` після імені властивості: `interface Product { name: string; price: number; description?: string; }`. Властивість `description` стає необов'язковою."
      },
      {
        "id": "ts-q3-aq3",
        "question": "Чи можна інтерфейс розширювати інший інтерфейс?",
        "answer": "Так, інтерфейси можуть розширювати інші інтерфейси за допомогою ключового слова `extends`, що дозволяє успадковувати властивості та методи: `interface Admin extends User { role: string; }`."
      }
    ]
  },
  {
    "id": "ts-q4",
    "topic": "TypeScript",
    "mainQuestion": "Що таке `enum` і як він реалізований у TypeScript?",
    "mainAnswer": "`enum` (перелічення) — це особливий тип даних у TypeScript, який дозволяє визначити набір іменованих констант. Він робить код більш читабельним, надаючи осмислені імена замість \"магічних\" чисел або рядків. `enum` може бути числовим (за замовчуванням значення починаються з 0 і інкрементуються) або рядковим. \nПриклад числового `enum`: `enum Direction { Up, Down, Left, Right }` \nПриклад рядкового `enum`: `enum Status { Success = 'SUCCESS', Error = 'ERROR' }`",
    "additionalQuestions": [
      {
        "id": "ts-q4-aq1",
        "question": "Коли варто використовувати `enum`, а коли просто набір констант?",
        "answer": "`enum` варто використовувати, коли у вас є пов'язаний набір значень, які є семантично значущими. Для простих, поодиноких констант краще використовувати `const` змінні. Сучасніші підходи часто віддають перевагу об'єктам з `as const` або 'union types' замість `enum` для кращої сумісності з JavaScript та tree-shaking."
      },
      {
        "id": "ts-q4-aq2",
        "question": "Чи можна отримати строкове значення з числового `enum`?",
        "answer": "Так, числовий `enum` є двонаправленим. Ви можете отримати ім'я властивості за його числовим значенням: `enum MyEnum { A = 1 }; console.log(MyEnum[1]); // 'A'`."
      },
      {
        "id": "ts-q4-aq3",
        "question": "Які переваги та недоліки `enum`?",
        "answer": "Переваги: покращує читабельність, надає строгу перевірку типу. Недоліки: генерує додатковий JavaScript-код під час компіляції, не підтримує tree-shaking для числових `enum`, що може збільшити розмір бандлу."
      }
    ]
  },
  {
    "id": "ts-q5",
    "topic": "TypeScript",
    "mainQuestion": "Що таке об'єднані типи (union types)?",
    "mainAnswer": "Об'єднані типи (Union Types) у TypeScript дозволяють змінній або параметру функції мати значення одного з кількох можливих типів. Вони позначаються вертикальною рискою (`|`). Це дає гнучкість, дозволяючи працювати з даними, які можуть бути різних, але чітко визначених типів, водночас зберігаючи переваги строгої типізації. \nПриклад: `let id: number | string; // id може бути числом або рядком`",
    "additionalQuestions": [
      {
        "id": "ts-q5-aq1",
        "question": "Як звузити об'єднаний тип (type narrowing)?",
        "answer": "Звуження типу відбувається за допомогою перевірок типу (type guards), таких як `typeof`, `instanceof`, `in` або інших умовних перевірок. Наприклад, `if (typeof id === 'string') { /* id тепер гарантовано рядок */ }`."
      },
      {
        "id": "ts-q5-aq2",
        "question": "Чи можна використовувати об'єднані типи з літеральними типами?",
        "answer": "Так, дуже часто. Наприклад, `type Direction = 'up' | 'down' | 'left' | 'right';`. Це дозволяє обмежити змінну лише певними строковими значеннями."
      },
      {
        "id": "ts-q5-aq3",
        "question": "Яка різниця між об'єднаним типом та `any`?",
        "answer": "Об'єднаний тип є безпечним, оскільки він дозволяє лише строго визначені типи. `any` є динамічним і фактично вимикає перевірку типу для цієї змінної, що може призвести до помилок під час виконання."
      }
    ]
  },
  {
    "id": "ts-q6",
    "topic": "TypeScript",
    "mainQuestion": "Що таке універсальні та неможливі типи?",
    "mainAnswer": "**Універсальний тип (`any`)**: Це гнучкий, але небезпечний тип, який фактично відключає перевірку типу для змінної. Змінній типу `any` можна присвоїти значення будь-якого типу, і TypeScript не буде перевіряти її використання, що може призвести до помилок під час виконання. Використання `any` слід уникати, якщо це можливо. \n**Неможливий тип (`never`)**: Це тип, який представляє значення, яке ніколи не відбудеться. Він використовується для функцій, які ніколи не повертають результат (наприклад, функція, яка завжди викидає помилку або містить нескінченний цикл). `never` є підтипом *кожного* іншого типу, але *жоден* тип не є підтипом `never` (крім самого `never`).",
    "additionalQuestions": [
      {
        "id": "ts-q6-aq1",
        "question": "Коли може бути корисним тип `any`?",
        "answer": "`any` може бути корисним при міграції існуючого JavaScript-коду на TypeScript, при роботі з бібліотеками без визначень типів або коли ви свідомо хочете відмовитися від перевірки типу для конкретної змінної (але це має бути винятком)."
      },
      {
        "id": "ts-q6-aq2",
        "question": "Наведіть приклад використання типу `never`.",
        "answer": "`function error(message: string): never { throw new Error(message); }` або для перевірки повноти в операторах `switch`: `function exhaustiveCheck(param: never) { console.log(param); }`"
      },
      {
        "id": "ts-q6-aq3",
        "question": "Яка різниця між `void` та `never`?",
        "answer": "`void` означає, що функція повертає `undefined` або не має явного `return` значення. `never` означає, що функція *ніколи* не завершує виконання успішно (наприклад, завжди викидає помилку або виконується нескінченно)."
      }
    ]
  },
  {
    "id": "ts-q7",
    "topic": "TypeScript",
    "mainQuestion": "Що таке явні та виведені типи (explicit and inferred types)?",
    "mainAnswer": "**Явні типи (Explicit Types)**: Це коли ви *явно* вказуєте тип змінної, параметра функції або значення за допомогою синтаксису анотації типу. \nПриклад: `let age: number = 30;` \n**Виведені типи (Inferred Types)**: Це коли TypeScript *автоматично визначає* тип змінної або значення на основі її початкового присвоєння або способу використання, без необхідності явного зазначення. Це забезпечує безпеку типів, не вимагаючи надмірної деталізації. \nПриклад: `let name = 'Roman'; // TypeScript виведе тип `string` \n`const numbers = [1, 2, 3]; // TypeScript виведе тип `number[]``",
    "additionalQuestions": [
      {
        "id": "ts-q7-aq1",
        "question": "Коли краще використовувати явні типи, а коли покладатися на виведення типів?",
        "answer": "Зазвичай краще покладатися на виведення типів, коли TypeScript може достовірно визначити тип, щоб уникнути надмірності коду. Явні типи варто використовувати для: параметрів функцій, повернених значень складних функцій, змінних, які ініціалізуються пізніше, або коли ви хочете забезпечити певну форму контракту."
      },
      {
        "id": "ts-q7-aq2",
        "question": "Що таке 'виведення контексту' (contextual typing)?",
        "answer": "'Виведення контексту' — це коли TypeScript виводить тип значення, базуючись на контексті, в якому воно використовується. Наприклад, тип колбек-функції може бути виведений з сигнатури функції, до якої вона передається."
      },
      {
        "id": "ts-q7-aq3",
        "question": "Що станеться, якщо зміна зі виведеним типом буде пізніше ініціалізована значенням іншого типу?",
        "answer": "Якщо виведена змінна була ініціалізована одним типом, а пізніше ви спробуєте присвоїти їй значення іншого типу, TypeScript видасть помилку компіляції. Наприклад: `let count = 0; count = 'five'; // Помилка компіляції: Type 'string' is not assignable to type 'number'.`"
      }
    ]
  }
]