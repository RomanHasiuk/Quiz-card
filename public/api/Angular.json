[
  {
    "id": "angular-q1",
    "topic": "Angular",
    "mainQuestion": "Що таке Angular і які його основні переваги?",
    "mainAnswer": "Angular – це фронтенд-фреймворк з відкритим вихідним кодом, розроблений Google для побудови динамічних односторінкових додатків (SPA). Його основні переваги включають: використання TypeScript, модульність (компоненти, модулі, сервіси), двостороннє зв'язування даних, потужний CLI, велика екосистема та підтримка Google.",
    "additionalQuestions": [
      {
        "id": "angular-q1-aq1",
        "question": "Чим Angular відрізняється від інших фреймворків, таких як React чи Vue?",
        "answer": "Angular є повноцінним фреймворком (opinionated), який надає готові рішення для багатьох аспектів розробки (маршрутизація, управління станом). React – це бібліотека для побудови UI, яка вимагає додавання інших бібліотек для повноцінної розробки. Vue знаходиться десь посередині, будучи більш гнучким, ніж Angular, але більш 'ready-to-use', ніж React."
      },
      {
        "id": "angular-q1-aq2",
        "question": "Яка роль TypeScript в Angular?",
        "answer": "TypeScript є основною мовою розробки в Angular. Він надає статичну типізацію, що допомагає виявляти помилки на етапі розробки, покращує читабельність коду та надає кращу підтримку інструментів розробки (IDE)."
      },
      {
        "id": "angular-q1-aq3",
        "question": "Які типові сценарії використання Angular?",
        "answer": "Angular ідеально підходить для розробки великих, складних корпоративних додатків, SPA з великою кількістю бізнес-логіки, панелей адміністратора, мобільних додатків (за допомогою Ionic) та інших високопродуктивних веб-додатків."
      }
    ]
  },
  {
    "id": "angular-q2",
    "topic": "Angular",
    "mainQuestion": "Поясніть архітектуру Angular-додатку. Які його основні будівельні блоки?",
    "mainAnswer": "Архітектура Angular-додатку базується на компонентах (Components), модулях (NgModules), сервісах (Services) та ін'єкції залежностей (Dependency Injection). Компоненти відповідають за UI, модулі організовують код, сервіси містять бізнес-логіку та доступ до даних, а ін'єкція залежностей забезпечує легке керування цими сервісами.",
    "additionalQuestions": [
      {
        "id": "angular-q2-aq1",
        "question": "Що таке компоненти в Angular?",
        "answer": "Компоненти – це основні будівельні блоки Angular-додатку, які контролюють окремі частини UI. Кожен компонент складається з класу TypeScript (бізнес-логіка), HTML-шаблону (розмітка) та CSS-стилів (оформлення)."
      },
      {
        "id": "angular-q2-aq2",
        "question": "Яка роль NgModules?",
        "answer": "NgModules (модулі Angular) – це контейнери для групування логічно пов'язаних компонентів, сервісів та інших модулів. Вони допомагають організувати додаток, покращують його масштабованість і дозволяють ліниве завантаження (lazy loading) функціональності."
      },
      {
        "id": "angular-q2-aq3",
        "question": "Поясніть концепцію ін'єкції залежностей (DI) в Angular.",
        "answer": "DI – це шаблон проектування, при якому об'єкти (залежності) надаються компонентам або іншим об'єктам, замість того, щоб ці об'єкти створювали залежності самостійно. В Angular DI використовується для надання сервісів компонентам, що робить код більш тестованим, гнучким та легким для підтримки."
      }
    ]
  },
  {
    "id": "angular-q3",
    "topic": "Angular",
    "mainQuestion": "Що таке зв'язування даних (Data Binding) в Angular і які його типи ви знаєте?",
    "mainAnswer": "Зв'язування даних – це механізм, який дозволяє синхронізувати дані між моделлю (компонентом) і представленням (шаблоном). Angular підтримує кілька типів зв'язування даних: інтерполяція (Interpolation), зв'язування властивостей (Property Binding), зв'язування подій (Event Binding) та двостороннє зв'язування (Two-way Binding).",
    "additionalQuestions": [
      {
        "id": "angular-q3-aq1",
        "question": "Поясніть різницю між зв'язуванням властивостей та інтерполяцією.",
        "answer": "Інтерполяція `{{ ... }}` використовується для виведення текстових значень властивостей в шаблон. Зв'язування властивостей `[property]=expression` використовується для встановлення значень властивостей HTML-елементів або директив."
      },
      {
        "id": "angular-q3-aq2",
        "question": "Що таке двостороннє зв'язування даних і як воно реалізується в Angular?",
        "answer": "Двостороннє зв'язування дозволяє автоматично синхронізувати дані між моделлю і представленням в обох напрямках. Якщо користувач змінює дані в UI, вони оновлюються в моделі, і навпаки. В Angular воно реалізується за допомогою директиви `ngModel` (зазвичай в контексті форм) або за допомогою 'banana in a box' синтаксису `[(ngModel)]`."
      },
      {
        "id": "angular-q3-aq3",
        "question": "Коли варто використовувати зв'язування подій (Event Binding)?",
        "answer": "Зв'язування подій `(event)=expression` використовується для реагування на події DOM (наприклад, `click`, `submit`, `input`). Воно дозволяє викликати метод компонента, коли відбувається певна подія."
      }
    ]
  },
  {
    "id": "angular-q4",
    "topic": "Angular",
    "mainQuestion": "Опишіть життєвий цикл компонента в Angular. Назвіть основні хуки життєвого циклу.",
    "mainAnswer": "Життєвий цикл компонента в Angular – це послідовність подій, які відбуваються від створення компонента до його знищення. Angular надає хуки (lifecycle hooks), які дозволяють виконувати код на різних етапах цього циклу. Основні хуки: `ngOnChanges`, `ngOnInit`, `ngDoCheck`, `ngAfterContentInit`, `ngAfterContentChecked`, `ngAfterViewInit`, `ngAfterViewChecked`, `ngOnDestroy`.",
    "additionalQuestions": [
      {
        "id": "angular-q4-aq1",
        "question": "Яка різниця між `ngOnInit` і конструктором компонента?",
        "answer": "Конструктор компонента використовується в першу чергу для ін'єкції залежностей. `ngOnInit` викликається після того, як Angular ініціалізував усі прив'язані властивості (inputs) компонента, що робить його ідеальним місцем для ініціалізації даних або виконання логіки, яка залежить від вхідних даних."
      },
      {
        "id": "angular-q4-aq2",
        "question": "Коли використовується `ngOnDestroy`?",
        "answer": "`ngOnDestroy` викликається безпосередньо перед тим, як Angular знищить компонент. Це ідеальне місце для очищення ресурсів, таких як відписки від Observable, відключення від подій або очищення таймерів, щоб запобігти витокам пам'яті."
      },
      {
        "id": "angular-q4-aq3",
        "question": "Що таке `ngOnChanges` і коли він спрацьовує?",
        "answer": "`ngOnChanges` викликається, коли Angular виявляє зміни в даних, що прив'язані до вхідних властивостей компонента (`@Input()`). Він отримує об'єкт `SimpleChanges`, який містить поточні та попередні значення змінених властивостей."
      }
    ]
  },
  {
    "id": "angular-q5",
    "topic": "Angular",
    "mainQuestion": "Поясніть концепцію маршрутизації (Routing) в Angular. Як вона працює?",
    "mainAnswer": "Маршрутизація в Angular дозволяє навігацію між різними 'сторінками' або 'видами' в односторінковому додатку без перезавантаження сторінки. Вона реалізується за допомогою `RouterModule` та визначення маршрутів, які зіставляють URL-шляхи з компонентами. `<router-outlet>` використовується для відображення відповідного компонента.",
    "additionalQuestions": [
      {
        "id": "angular-q5-aq1",
        "question": "Що таке `RouterLink` та `RouterOutlet`?",
        "answer": "`RouterLink` – це директива, яка використовується в HTML-шаблонах для створення посилань, що дозволяють навігацію між маршрутами. `RouterOutlet` – це директива-плейсхолдер, куди Angular динамічно завантажує компонент, який відповідає поточному маршруту."
      },
      {
        "id": "angular-q5-aq2",
        "question": "Як передавати дані між маршрутами (компонентами) при навігації?",
        "answer": "Дані можуть передаватися кількома способами: через параметри маршруту (params), через query-параметри (queryParams), через state об'єкт, або використовуючи сервіси."
      },
      {
        "id": "angular-q5-aq3",
        "question": "Що таке 'Lazy Loading' (ліниве завантаження) модулів у контексті маршрутизації?",
        "answer": "Ліниве завантаження дозволяє завантажувати Angular-модулі лише тоді, коли вони потрібні (наприклад, коли користувач переходить на певний маршрут). Це допомагає зменшити початковий розмір bundle-файлу додатку та покращити час завантаження."
      }
    ]
  },
  {
    "id": "angular-q6",
    "topic": "Angular",
    "mainQuestion": "Що таке сервіси (Services) і для чого вони використовуються в Angular?",
    "mainAnswer": "Сервіси в Angular – це класи, які містять певну бізнес-логіку або функціональність, призначену для спільного використання різними компонентами. Вони часто використовуються для роботи з даними (отримання, надсилання), валідації, аутентифікації тощо. Сервіси реєструються за допомогою механізму ін'єкції залежностей.",
    "additionalQuestions": [
      {
        "id": "angular-q6-aq1",
        "question": "Як забезпечити, щоб сервіс був доступний по всьому додатку?",
        "answer": "Щоб сервіс був доступний по всьому додатку (singleton), його потрібно зареєструвати в кореневому модулі (`AppModule`) або за допомогою `providedIn: 'root'` в декораторі `@Injectable()`."
      },
      {
        "id": "angular-q6-aq2",
        "question": "Яка роль декоратора `@Injectable()`?",
        "answer": "`@Injectable()` – це декоратор, який позначає клас як сервіс, який може бути ін'єктований в інші класи (компоненти, інші сервіси). Він також вказує, як цей сервіс має бути 'наданий' (provided) в інжекторі Angular."
      },
      {
        "id": "angular-q6-aq3",
        "question": "Чи можна ін'єктувати сервіси в інші сервіси?",
        "answer": "Так, можна. Це поширена практика для створення більш модульної та організованої бізнес-логіки. Сервіс A може ін'єктувати Сервіс B, щоб використовувати його функціональність."
      }
    ]
  },
  {
    "id": "angular-q7",
    "topic": "Angular",
    "mainQuestion": "Поясніть, що таке RxJS та Observable в Angular. Наведіть приклад використання.",
    "mainAnswer": "RxJS (Reactive Extensions for JavaScript) – це бібліотека для реактивного програмування, яка використовує Observables для роботи з асинхронними даними та подіями. Observable – це джерело даних, яке може випромінювати нуль або більше значень з часом. В Angular Observables часто використовуються для HTTP-запитів, обробки подій та управління станом.",
    "additionalQuestions": [
      {
        "id": "angular-q7-aq1",
        "question": "Яка різниця між Promise та Observable?",
        "answer": "Promise повертає одне значення (успіх або помилку) і завершується. Observable може випромінювати багато значень з часом (потік даних), підтримує скасування (cancellable) та має потужні оператори для трансформації даних."
      },
      {
        "id": "angular-q7-aq2",
        "question": "Назвіть кілька поширених операторів RxJS.",
        "answer": "Поширені оператори: `map`, `filter`, `debounceTime`, `switchMap`, `takeUntil`, `merge`, `combineLatest`. Вони дозволяють трансформувати, фільтрувати, об'єднувати або контролювати потік даних з Observable."
      },
      {
        "id": "angular-q7-aq3",
        "question": "Що таке 'підписка' (subscription) на Observable і чому вона важлива?",
        "answer": "Підписка на Observable (`.subscribe()`) активує виконання Observable і починає отримувати значення. Важливо завжди відписуватися від Observable, коли вони більше не потрібні (наприклад, у `ngOnDestroy`), щоб запобігти витокам пам'яті."
      }
    ]
  },
  {
    "id": "angular-q8",
    "topic": "Angular",
    "mainQuestion": "Що таке директиви (Directives) в Angular? Які їх типи існують?",
    "mainAnswer": "Директиви в Angular – це класи, які додають поведінку або змінюють DOM-елементи. Існує три основні типи директив: Компоненти (Component Directives), Структурні директиви (Structural Directives) та Атрибутивні директиви (Attribute Directives).",
    "additionalQuestions": [
      {
        "id": "angular-q8-aq1",
        "question": "Поясніть різницю між структурними та атрибутивними директивами.",
        "answer": "Структурні директиви (`*ngIf`, `*ngFor`, `*ngSwitchCase`) змінюють структуру DOM, додаючи або видаляючи елементи. Атрибутивні директиви (`ngClass`, `ngStyle`) змінюють вигляд або поведінку існуючого елемента, атрибута або іншого компонента."
      },
      {
        "id": "angular-q8-aq2",
        "question": "Наведіть приклад використання `*ngIf` та `*ngFor`.",
        "answer": "`*ngIf` використовується для умовного рендерингу елементів: `<div *ngIf=\"isValid\">Content</div>`. `*ngFor` використовується для ітерації по колекції та рендерингу елементів для кожного елемента колекції: `<li *ngFor=\"let item of items\">{{ item.name }}</li>`."
      },
      {
        "id": "angular-q8-aq3",
        "question": "Чи можна створити власну директиву?",
        "answer": "Так, Angular дозволяє створювати власні атрибутивні та структурні директиви, використовуючи декоратор `@Directive()`."
      }
    ]
  },
  {
    "id": "angular-q9",
    "topic": "Angular",
    "mainQuestion": "Як працює механізм виявлення змін (Change Detection) в Angular?",
    "mainAnswer": "Angular використовує механізм виявлення змін для синхронізації стану моделі з представленням. Він перевіряє, чи змінилися дані, які використовуються в шаблоні, і оновлює DOM, якщо це необхідно. За замовчуванням, Angular використовує стратегію `Default` (Zone.js), яка запускає перевірку при більшості асинхронних подій.",
    "additionalQuestions": [
      {
        "id": "angular-q9-aq1",
        "question": "Що таке `Zone.js` і яка його роль у виявленні змін?",
        "answer": "`Zone.js` – це бібліотека, яка перехоплює асинхронні події (такі як HTTP-запити, таймери, події DOM) і сповіщає Angular про те, що потенційно відбулися зміни, які вимагають перевірки. Це дозволяє Angular автоматично запускати цикл виявлення змін."
      },
      {
        "id": "angular-q9-aq2",
        "question": "Що таке стратегія `OnPush` для виявлення змін і коли її варто використовувати?",
        "answer": "Стратегія `OnPush` вказує Angular, що компонент повинен бути перевірений на зміни лише тоді, коли його вхідні властивості змінилися (за допомогою посилальної рівності), або коли компонент явно викликає `markForCheck()` або `detectChanges()`. Це може значно покращити продуктивність великих додатків, зменшуючи кількість перевірок."
      },
      {
        "id": "angular-q9-aq3",
        "question": "Як вручну запустити виявлення змін?",
        "answer": "Можна використовувати `ChangeDetectorRef` та його методи `detectChanges()` для примусового запуску виявлення змін для поточного компонента та його дочірніх елементів, або `markForCheck()` для позначення компонента як 'брудного', що змусить Angular перевірити його при наступному циклі виявлення змін."
      }
    ]
  },
  {
    "id": "angular-q10",
    "topic": "Angular",
    "mainQuestion": "Опишіть, як працювати з HTTP-запитами в Angular.",
    "mainAnswer": "Для роботи з HTTP-запитами в Angular використовується `HttpClient` з модуля `HttpClientModule`. Він надає методи для виконання GET, POST, PUT, DELETE запитів та повертає `Observable` об'єкти, що дозволяє легко обробляти асинхронні відповіді та використовувати оператори RxJS.",
    "additionalQuestions": [
      {
        "id": "angular-q10-aq1",
        "question": "Як обробляти помилки HTTP-запитів?",
        "answer": "Помилки обробляються за допомогою оператора `catchError` з RxJS. Можна перехопити помилку, виконати певну логіку (наприклад, вивести повідомлення користувачу) і повернути новий Observable або кинути помилку далі."
      },
      {
        "id": "angular-q10-aq2",
        "question": "Що таке HTTP-інтерцептори (interceptors) і для чого вони використовуються?",
        "answer": "HTTP-інтерцептори – це механізм в Angular, який дозволяє перехоплювати та модифікувати HTTP-запити та відповіді глобально. Вони ідеально підходять для додавання токенів авторизації, обробки помилок, логування або кешування."
      },
      {
        "id": "angular-q10-aq3",
        "question": "Як додати заголовки (headers) до HTTP-запиту?",
        "answer": "Заголовки можна додати, передаючи об'єкт `HttpHeaders` у опції методу HTTP-запиту, наприклад: `this.http.get(url, { headers: new HttpHeaders({ 'Authorization': 'Bearer token' }) })`."
      }
    ]
  },
  {
    "id": "angular-q11",
    "topic": "Angular",
    "mainQuestion": "Які способи управління станом (State Management) існують в Angular?",
    "mainAnswer": "В Angular існує кілька підходів до управління станом, від простих до складних: використання сервісів для спільного стану, бібліотеки для управління станом (наприклад, NgRx, Akita, NGXS), або ж використання RxJS-Observable та Subject у сервісах.",
    "additionalQuestions": [
      {
        "id": "angular-q11-aq1",
        "question": "Коли варто використовувати NgRx?",
        "answer": "NgRx – це реалізація архітектури Redux для Angular. Його варто використовувати у великих, складних додатках, де потрібно централізоване, передбачуване та відстежуване управління станом, а також для додатків з багатьма асинхронними операціями."
      },
      {
        "id": "angular-q11-aq2",
        "question": "Поясніть основні концепції NgRx (Store, Actions, Reducers, Effects, Selectors).",
        "answer": "Store – єдине джерело істини для стану. Actions – об'єкти, які описують, що сталося. Reducers – чисті функції, які приймають поточний стан і дію, повертаючи новий стан. Effects – обробляють побічні ефекти (наприклад, HTTP-запити). Selectors – чисті функції для отримання даних зі Store."
      },
      {
        "id": "angular-q11-aq3",
        "question": "Чи завжди потрібна складна бібліотека для управління станом в Angular?",
        "answer": "Ні, не завжди. Для невеликих або середніх додатків часто достатньо використовувати сервіси з RxJS `BehaviorSubject` або `ReplaySubject` для управління простим станом. Складні бібліотеки, такі як NgRx, додають значну кількість бойлерплейт-коду та криву навчання."
      }
    ]
  },
  {
    "id": "angular-q12",
    "topic": "Angular",
    "mainQuestion": "Що таке форми (Forms) в Angular і які їх типи ви знаєте?",
    "mainAnswer": "Форми в Angular дозволяють збирати дані від користувача та перевіряти їх. Існує два основні підходи до створення форм: Темплатно-керовані форми (Template-driven Forms) та Реактивні форми (Reactive Forms).",
    "additionalQuestions": [
      {
        "id": "angular-q12-aq1",
        "question": "У чому відмінність між Темплатно-керованими та Реактивними формами?",
        "answer": "Темплатно-керовані форми простіші для створення простих форм, логіка валідації та структура форми визначаються безпосередньо в шаблоні за допомогою директив. Реактивні форми використовують програмний підхід, де форма будується в класі TypeScript, надаючи більший контроль, гнучкість та легкість тестування, особливо для складних форм."
      },
      {
        "id": "angular-q12-aq2",
        "question": "Як виконувати валідацію форм в Angular?",
        "answer": "Валідація в Angular може бути виконана за допомогою вбудованих валідаторів (наприклад, `Validators.required`, `Validators.email`, `Validators.minLength`) або за допомогою створення власних кастомних валідаторів."
      },
      {
        "id": "angular-q12-aq3",
        "question": "Що таке `FormControl`, `FormGroup` та `FormArray` у Реактивних формах?",
        "answer": "`FormControl` представляє окремий елемент форми (наприклад, поле введення). `FormGroup` групує кілька `FormControl` або інших `FormGroup` в одну форму. `FormArray` дозволяє керувати динамічними списками елементів форми."
      }
    ]
  },
  {
    "id": "angular-q13",
    "topic": "Angular",
    "mainQuestion": "Як оптимізувати продуктивність Angular-додатку?",
    "mainAnswer": "Оптимізація продуктивності Angular-додатків включає кілька технік: використання стратегії виявлення змін `OnPush`, ліниве завантаження модулів, відписка від Observable, оптимізація розміру bundle (Tree Shaking, AOT Compilation), віртуалізація списків, використання трек-функції в `*ngFor` та оптимізація HTTP-запитів.",
    "additionalQuestions": [
      {
        "id": "angular-q13-aq1",
        "question": "Що таке AOT Compilation і чому вона важлива для продуктивності?",
        "answer": "AOT (Ahead-of-Time) Compilation – це компіляція шаблонів та компонентів Angular на етапі збірки (перед тим, як код буде виконаний в браузері), а не в рантаймі (JIT). Це покращує продуктивність завантаження, оскільки браузер отримує вже скомпільований код, і зменшує розмір bundle, оскільки компілятор не потрібно включати в бандл."
      },
      {
        "id": "angular-q13-aq2",
        "question": "Як `trackBy` функція допомагає оптимізувати продуктивність `*ngFor`?",
        "answer": "Без `trackBy`, Angular перемальовує весь список елементів при кожній зміні даних. `trackBy` дозволяє Angular ідентифікувати унікальні елементи в списку, що дозволяє йому перемальовувати лише ті елементи, які дійсно змінилися, додалися або були видалені, що значно покращує продуктивність."
      },
      {
        "id": "angular-q13-aq3",
        "question": "Які інструменти можна використовувати для аналізу продуктивності Angular-додатку?",
        "answer": "Для аналізу продуктивності можна використовувати вбудовані інструменти розробника браузера (Performance tab, Network tab), а також спеціалізовані розширення для браузера, такі як Augury (для Angular)."
      }
    ]
  },
  {
    "id": "angular-q14",
    "topic": "Angular",
    "mainQuestion": "Що таке пайпи (Pipes) в Angular і для чого вони використовуються?",
    "mainAnswer": "Пайпи в Angular – це функції, які трансформують дані для відображення в шаблоні. Вони дозволяють форматувати дані (наприклад, дати, числа, валюти) без зміни самих даних у компоненті. Приклади вбудованих пайпів: `DatePipe`, `CurrencyPipe`, `UpperCasePipe`, `LowerCasePipe`, `DecimalPipe`.",
    "additionalQuestions": [
      {
        "id": "angular-q14-aq1",
        "question": "Як створити власний кастомний пайп?",
        "answer": "Для створення власного пайпу потрібно створити клас, що реалізує інтерфейс `PipeTransform`, і помітити його декоратором `@Pipe()` з унікальним ім'ям. Метод `transform()` буде містити логіку перетворення даних."
      },
      {
        "id": "angular-q14-aq2",
        "question": "Яка різниця між чистими (Pure) та нечистими (Impure) пайпами?",
        "answer": "Чисті пайпи перераховуються лише тоді, коли їх вхідні значення змінюються (за допомогою посилальної рівності). Нечисті пайпи перераховуються при кожному циклі виявлення змін, незалежно від того, чи змінилися їх вхідні значення. Чисті пайпи є більш продуктивними."
      },
      {
        "id": "angular-q14-aq3",
        "question": "Наведіть приклад використання вбудованого пайпа.",
        "answer": "Приклад: `{{ birthday | date:'shortDate' }}` або `{{ price | currency:'USD':true:'1.2-2' }}`. Це дозволяє компактно форматувати дані прямо в HTML."
      }
    ]
  },
  {
    "id": "angular-q15",
    "topic": "Angular",
    "mainQuestion": "Як тестувати Angular-додатки? Які інструменти використовуються?",
    "mainAnswer": "Angular-додатки можна тестувати на різних рівнях: юніт-тести, інтеграційні тести, наскрізні (end-to-end) тести. Для юніт- та інтеграційних тестів зазвичай використовуються Jasmine (фреймворк для тестування) та Karma (тест-раннер). Для E2E-тестів – Cypress або Protractor (старий, зараз менш популярний).",
    "additionalQuestions": [
      {
        "id": "angular-q15-aq1",
        "question": "У чому полягає перевага юніт-тестування компонентів в Angular?",
        "answer": "Юніт-тестування дозволяє перевірити окремі частини коду (наприклад, методи компонента, сервісу) ізольовано, без залежностей від інших частин системи. Це допомагає швидко виявляти помилки, покращує якість коду та полегшує рефакторинг."
      },
      {
        "id": "angular-q15-aq2",
        "question": "Що таке TestBed в Angular?",
        "answer": "`TestBed` – це утиліта, що надається Angular для конфігурування та створення тестового середовища для компонентів, сервісів та модулів. Вона дозволяє оголошувати компоненти, імпортувати модулі, надавати залежності для тестування."
      },
      {
        "id": "angular-q15-aq3",
        "question": "Коли варто використовувати наскрізні (E2E) тести?",
        "answer": "E2E-тести перевіряють весь додаток від початку до кінця, імітуючи взаємодію реального користувача з UI. Їх варто використовувати для перевірки критичних бізнес-сценаріїв та потоків користувача, щоб переконатися, що весь додаток працює як єдине ціле."
      }
    ]
  }
]