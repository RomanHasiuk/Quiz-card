[
  {
    "id": "redux-q11",
    "topic": "Redux",
    "mainQuestion": "Які є два способи задати початковий стан у Redux? Як саме з технічного погляду працює спосіб задати початковий стан у коді редюсера?",
    "mainAnswer": "Існує два основні способи задати початковий стан у Redux: \n\n1.  **Задання початкового стану у коді редюсера (рекомендований спосіб)**: \n    -   Це найпоширеніший і рекомендований спосіб. Ви надаєте параметру `state` у функції редюсера значення за замовчуванням. \n    -   **Як працює з технічного погляду**: Коли Redux створює сховище, він виконує перше 'диспетчеризування' спеціальної дії (`@@redux/INIT` або подібної) з `state`, встановленим на `undefined`. Кожен редюсер отримує цю дію, і оскільки `state` є `undefined`, він використовує своє значення за замовчуванням (яке ви вказали), щоб повернути початковий стан для своєї ділянки. Таким чином, весь об'єкт стану збирається з початкових значень, визначених у кожному редюсері. \n    -   **Приклад:** \n        ```javascript \n        const initialState = { count: 0, message: 'Привіт' }; \n        function counterReducer(state = initialState, action) { \n          // ... логіка редюсера \n          return state; \n        } \n        ``` \n\n2.  **Передача початкового стану як другий аргумент у `createStore` (або `preloadedState` у `configureStore`):** \n    -   Ви можете передати об'єкт початкового стану безпосередньо у функцію `createStore` (або `preloadedState` у `configureStore` Redux Toolkit). \n    -   **Коли використовувати:** Це корисно для гідратації стану з локального сховища або з серверного рендерингу (коли ви хочете відновити стан, який був збережений або згенерований на сервері). \n    -   **Приклад (з `createStore`):** \n        ```javascript \n        import { createStore } from 'redux'; \n        import rootReducer from './reducers'; \n        const preloadedStateFromLocalStorage = { \n          count: 5, \n          message: 'Відновлено з LocalStorage' \n        }; \n        const store = createStore(rootReducer, preloadedStateFromLocalStorage); \n        ``` \n\n**Комбінація:** Якщо ви надаєте початковий стан через `createStore`/`preloadedState`, існуючі значення у вашому об'єкті початкового стану **перевизначать** початкові стани, визначені в редюсерах. Будь-які частини стану, які не були надані через `preloadedState`, отримають свої початкові значення з редюсерів.",
    "additionalQuestions": [
      {
        "id": "redux-q11-aq1",
        "question": "Чому важливо, щоб редюсери повертали початковий стан, коли `state` є `undefined`?",
        "answer": "Це критично важливо, тому що Redux викликає кожен редюсер при ініціалізації сховища з `state = undefined`. Якщо редюсер не обробляє цей випадок і не повертає своє початкове значення, стан залишиться `undefined`, що призведе до помилок у застосунку."
      },
      {
        "id": "redux-q11-aq2",
        "question": "У чому перевага задання початкового стану в редюсері над передачею його в `createStore`?",
        "answer": "Перевага в тому, що кожен редюсер самодостатній і чітко визначає початковий стан для своєї частини даних. Це покращує модульність та дозволяє легше комбінувати редюсери. Використання `createStore` для початкового стану зазвичай резервується для ситуацій відновлення стану, а не для його початкового визначення."
      },
      {
        "id": "redux-q11-aq3",
        "question": "Чи можна змінити початковий стан після створення сховища?",
        "answer": "Ні, початковий стан (як його визначають редюсери) не можна змінити після створення сховища. Стан змінюється лише через надсилання дій та обробку їх редюсерами, які повертають нові об'єкти стану."
      }
    ]
  },
  {
    "id": "redux-q12",
    "topic": "Redux",
    "mainQuestion": "Як об’єднати два редюсери, що опікуються різними ділянками стану, в один?",
    "mainAnswer": "У Redux використовується функція **`combineReducers`** (з бібліотеки `redux`) для об'єднання кількох незалежних редюсерів в один кореневий редюсер. Кожен з цих 'дочірніх' редюсерів відповідає за управління певною ділянкою загального стану. \n\n`combineReducers` приймає об'єкт, де ключі відповідають назвам властивостей у вашому кореневому стані, а значення — це відповідні редюсери. \n\n**Приклад:** \nПрипустимо, у вас є два окремі редюсери: \n\n1.  **`userReducer.js`**: Керує частиною стану, пов'язаною з користувачем. \n    ```javascript \n    // userReducer.js \n    const initialUserState = { name: '', email: '', isLoggedIn: false }; \n    function userReducer(state = initialUserState, action) { \n      switch (action.type) { \n        case 'LOGIN': \n          return { ...state, name: action.payload.name, isLoggedIn: true }; \n        case 'LOGOUT': \n          return { ...initialUserState }; \n        default: \n          return state; \n      } \n    } \n    export default userReducer; \n    ``` \n\n2.  **`productReducer.js`**: Керує частиною стану, пов'язаною з товарами. \n    ```javascript \n    // productReducer.js \n    const initialProductState = { list: [], loading: false }; \n    function productReducer(state = initialProductState, action) { \n      switch (action.type) { \n        case 'FETCH_PRODUCTS_REQUEST': \n          return { ...state, loading: true }; \n        case 'FETCH_PRODUCTS_SUCCESS': \n          return { ...state, loading: false, list: action.payload.products }; \n        default: \n          return state; \n      } \n    } \n    export default productReducer; \n    ``` \n\n**Об'єднання редюсерів у `rootReducer.js`:** \n```javascript \n// rootReducer.js \nimport { combineReducers } from 'redux'; \nimport userReducer from './userReducer'; \nimport productReducer from './productsReducer'; \n\nconst rootReducer = combineReducers({ \n  user: userReducer,    // `state.user` буде керуватися `userReducer` \n  products: productReducer // `state.products` буде керуватися `productReducer` \n}); \n\nexport default rootReducer; \n``` \n\n**Як це працює з технічного погляду:** \n-   Коли `rootReducer` отримує дію, `combineReducers` перебирає всі 'дочірні' редюсери, викликаючи кожен з них з відповідною частиною поточного стану та тією самою дією. \n-   Кожен дочірній редюсер повертає свій новий фрагмент стану. \n-   `combineReducers` потім збирає ці нові фрагменти в єдиний новий об'єкт кореневого стану. \n\nТаким чином, `combineReducers` дозволяє логічно розділити ваш стан та логіку його оновлення, зберігаючи при цьому єдине джерело істини.",
    "additionalQuestions": [
      {
        "id": "redux-q12-aq1",
        "question": "Яка структура стану буде після об'єднання цих редюсерів?",
        "answer": "Після об'єднання, кореневий стан буде виглядати так: \n```json \n{ \n  \"user\": { /* стан від userReducer */ }, \n  \"products\": { /* стан від productReducer */ } \n} \n``` \nтобто, ключі, які ви передали в `combineReducers`, стануть ключами верхнього рівня у вашому глобальному Redux-стані."
      },
      {
        "id": "redux-q12-aq2",
        "question": "Чи потрібно, щоб кожен редюсер у `combineReducers` мав унікальні типи дій?",
        "answer": "Ні, не обов'язково. Різні редюсери можуть реагувати на один і той самий тип дії. Наприклад, дія `'USER_LOGGED_IN'` може оновлювати `userReducer` (встановлюючи `isLoggedIn: true`) і одночасно `uiReducer` (приховуючи модальне вікно входу). Це є перевагою Redux, дозволяючи одній події впливати на кілька частин стану."
      },
      {
        "id": "redux-q12-aq3",
        "question": "Чи можна використовувати `combineReducers` для вкладених редюсерів?",
        "answer": "Так, `combineReducers` можна використовувати рекурсивно. Ви можете об'єднати групу редюсерів, а потім цей об'єднаний редюсер включити в інший `combineReducers`, щоб створити більш складну, ієрархічну структуру стану."
      }
    ]
  },
  {
    "id": "redux-q13",
    "topic": "Redux",
    "mainQuestion": "Що таке презентаційні компоненти та компоненти-обгортки?",
    "mainAnswer": "У контексті React та Redux, часто використовується архітектурний патерн, що розділяє компоненти на дві категорії: **презентаційні (чисті) компоненти** та **контейнерні (або компоненти-обгортки)**. Цей поділ вперше запропонував Ден Абрамов, творець Redux. \n\n1.  **Презентаційні компоненти (Presentational Components / Pure Components / Dumb Components)**: \n    -   **Що це:** Компоненти, які відповідають виключно за **UI (як виглядає)**. \n    -   **Залежності:** Отримують усі дані та функції зворотного виклику через `props`. \n    -   **Стан:** Зазвичай не мають власного стану (або мають мінімальний локальний UI-стан, який не впливає на інші частини застосунку). \n    -   **Дії:** Не надсилають дії Redux напряму. Вони викликають функції-колбеки, передані через props, які, у свою чергу, можуть викликати дії. \n    -   **Приклад:** Кнопки, поля вводу, картки товарів, списки. Вони часто є функціональними компонентами. \n    -   **Чому:** Легко тестуються, багаторазово використовуються, оскільки не залежать від джерела даних. \n\n2.  **Контейнерні компоненти (Container Components / Smart Components / Components-Wrappers)**: \n    -   **Що це:** Компоненти, які відповідають за **логіку та дані (як працює)**. \n    -   **Залежності:** Отримують дані з Redux Store, надсилають дії до Redux Store. \n    -   **Стан:** Зазвичай не мають власного візуального стану, але керують станом своїх презентаційних дітей. \n    -   **Дії:** Відповідають за надсилання дій Redux. \n    -   **Приклад:** Компонент, який отримує список користувачів з Redux Store і передає його презентаційному компоненту `UserList`. \n    -   **Чому:** Відокремлюють логіку від UI, що робить застосунок більш структурованим та легким для підтримки. Часто створюються за допомогою функції `connect` з `react-redux` або за допомогою хуків `useSelector` та `useDispatch`. \n\n**Сучасний підхід (з хуками):** \nПісля появи React Hooks (особливо `useSelector` та `useDispatch`), межа між презентаційними та контейнерними компонентами стала менш чіткою, оскільки функціональні компоненти можуть легко 'підключатися' до Redux Store без необхідності обгортання. Однак, базовий принцип розділення відповідальності (один компонент відповідає за UI, інший за дані) все ще залишається цінним.",
    "additionalQuestions": [
      {
        "id": "redux-q13-aq1",
        "question": "Який тип компонентів легше тестувати і чому?",
        "answer": "Презентаційні компоненти легше тестувати, оскільки вони є 'чистими' у тому сенсі, що вони повністю залежать від своїх пропсів і не мають побічних ефектів або залежностей від Redux Store. Їх можна тестувати ізольовано, передаючи різні набори пропсів і перевіряючи, як вони рендеряться."
      },
      {
        "id": "redux-q13-aq2",
        "question": "Чи може презентаційний компонент мати власний стан?",
        "answer": "Так, може. Презентаційний компонент може мати свій власний локальний UI-стан, який не впливає на інші частини застосунку (наприклад, стан відкритого/закритого модального вікна, стан введеного тексту в інпуті, якщо він не надсилається до Redux). Важливо, щоб цей стан не був даними, які вимагають глобального доступу або синхронізації з Redux."
      },
      {
        "id": "redux-q13-aq3",
        "question": "Як хуки вплинули на цей архітектурний патерн?",
        "answer": "Хуки, такі як `useSelector` та `useDispatch`, дозволяють будь-якому функціональному компоненту безпосередньо підключатися до Redux Store. Це означає, що вам більше не потрібно явно створювати окремі 'компоненти-обгортки' за допомогою `connect`. Функціональний компонент може бути одночасно 'розумним' (маючи доступ до Redux) і 'тупим' (будучи чистим у плані рендерингу від пропсів). Це робить архітектуру більш плоскою і часто зменшує бойлерплейт."
      }
    ]
  },
  {
    "id": "redux-q14",
    "topic": "Redux",
    "mainQuestion": "Які параметри приймає та що повертає функція `connect`?",
    "mainAnswer": "Функція **`connect`** з бібліотеки `react-redux` — це Higher-Order Component (HOC), який використовується для підключення React-компонентів до Redux Store. Вона 'обгортає' ваш React-компонент і надає йому доступ до даних зі стану Redux та/або дозволяє йому надсилати дії. \n\n**`connect` приймає до чотирьох аргументів, але найчастіше використовуються перші два:** \n\n1.  **`mapStateToProps(state, [ownProps])`**: \n    -   **Призначення:** Функція, яка визначає, які дані зі **стану Redux** (перший аргумент `state`) компонент потребує як `props`. \n    -   **Що повертає:** Об'єкт, ключі якого стануть пропсами для вашого компонента, а значення — даними зі стану Redux. \n    -   **`ownProps` (необов'язковий):** Другий аргумент `mapStateToProps` — це пропси, які були передані самому компоненту-обгортці. Ви можете використовувати їх для фільтрації даних зі стану Redux. \n\n2.  **`mapDispatchToProps(dispatch, [ownProps])`**: \n    -   **Призначення:** Функція або об'єкт, яка визначає, які **дії** (Action Creators) компонент може викликати (dispatch) як `props`. \n    -   **Що повертає:** \n        -   Якщо це **функція**, вона повинна повернути об'єкт, де ключі стануть пропсами для вашого компонента, а значення — функціями, які викликають `dispatch` для певних дій. \n        -   Якщо це **об'єкт**, кожен його метод буде автоматично 'обгорнутий' у `dispatch` і переданий як `prop`. \n    -   **`dispatch` (перший аргумент):** Сама функція `dispatch` зі сховища Redux. \n    -   **`ownProps` (необов'язковий):** Аналогічно `mapStateToProps`, дозволяє використовувати пропси обгортки для створення функцій dispatch. \n\n3.  **`mergeProps(stateProps, dispatchProps, ownProps)` (необов'язковий)**: \n    -   Функція, яка дозволяє об'єднати результати `mapStateToProps`, `mapDispatchToProps` та `ownProps` в єдиний об'єкт пропсів, який буде переданий вашому компоненту. Використовується рідко. \n\n4.  **`options` (необов'язковий)**: \n    -   Об'єкт конфігурації для тонкого налаштування поведінки `connect` (наприклад, `pure: false` для відключення оптимізації). \n\n**Що повертає функція `connect`?** \n`connect` — це функція, яка повертає іншу функцію. Ця друга функція вже приймає ваш React-компонент як аргумент і повертає **новий, 'підключений' компонент-обгортку (Higher-Order Component)**. \n\n**Приклад використання:** \n```jsx \nimport { connect } from 'react-redux'; \nimport { addTodo, removeTodo } from './actions'; \n\nfunction MyComponent({ todos, addTodo, userProp }) { \n  return ( \n    <div> \n      <h1>{userProp}</h1> \n      {todos.map(todo => <p key={todo.id}>{todo.text}</p>)} \n      <button onClick={() => addTodo(Date.now(), 'Нове завдання')}>Додати</button> \n    </div> \n  ); \n} \n\nconst mapStateToProps = (state, ownProps) => ({ \n  todos: state.todos, \n  userProp: ownProps.someValueFromParent // Доступ до props обгортки \n}); \n\nconst mapDispatchToProps = { \n  // Це об'єкт action creators, react-redux автоматично оберне їх у dispatch \n  addTodo, \n  removeTodo \n}; \n\n// Підключаємо компонент до Redux Store \nexport default connect(mapStateToProps, mapDispatchToProps)(MyComponent); \n``` \n**Важливо:** У сучасних React-Redux застосунках з функціональними компонентами, замість `connect` частіше використовуються хуки `useSelector` та `useDispatch`, оскільки вони простіші та не вимагають HOC.",
    "additionalQuestions": [
      {
        "id": "redux-q14-aq1",
        "question": "Яка головна відмінність між `mapStateToProps` та `mapDispatchToProps`?",
        "answer": "`mapStateToProps` відповідає за **читання даних** зі стану Redux та передачу їх як пропсів компоненту. `mapDispatchToProps` відповідає за **модифікацію стану** Redux шляхом надсилання дій, надаючи компоненту функції-колбеки як пропси, які викликають `dispatch`."
      },
      {
        "id": "redux-q14-aq2",
        "question": "Чи обов'язково використовувати обидва `mapStateToProps` та `mapDispatchToProps`?",
        "answer": "Ні. Ви можете передати `null` або `undefined` замість будь-якої з цих функцій, якщо ваш компонент потребує лише читання стану, або лише надсилання дій. Наприклад, `connect(mapStateToProps, null)(MyComponent)` дозволить лише читати стан, а `connect(null, mapDispatchToProps)(MyComponent)` дозволить лише надсилати дії."
      },
      {
        "id": "redux-q14-aq3",
        "question": "Чому `connect` є HOC (Higher-Order Component)?",
        "answer": "`connect` є HOC, тому що він приймає React-компонент як аргумент і повертає новий React-компонент. Це дозволяє додати додаткову логіку (управління підпискою на Redux Store, передача пропсів зі стану, обгортання action creators) до вихідного компонента без його модифікації."
      }
    ]
  },
  {
    "id": "redux-q15",
    "topic": "Redux",
    "mainQuestion": "Яке призначення функцій `mapStateToProps` та `mapDispatchToProps` і в чому полягає різниця між ними?",
    "mainAnswer": "Функції **`mapStateToProps`** та **`mapDispatchToProps`** є ключовими для підключення React-компонентів до Redux Store за допомогою функції `connect` з бібліотеки `react-redux`. Вони слугують для різних, але взаємодоповнюючих цілей. \n\n1.  **`mapStateToProps(state, [ownProps])`**: \n    -   **Призначення (Mapping State to Props):** Ця функція відповідає за те, щоб взяти потрібні частини зі **стану Redux** (перший аргумент `state`) і 'змапувати' їх як **пропси** для вашого React-компонента. Вона визначає, які дані з глобального стану Redux компонент потребує для рендерингу. \n    -   **Що повертає:** Об'єкт, де ключі стануть назвами пропсів, а значення — даними, витягнутими зі стану Redux. \n    -   **Приклад:** Якщо вам потрібен лічильник зі стану `state.counter.value`, ви повернете `{ count: state.counter.value }`. Компонент отримає `props.count`. \n\n2.  **`mapDispatchToProps(dispatch, [ownProps])`**: \n    -   **Призначення (Mapping Dispatch to Props):** Ця функція (або об'єкт) відповідає за те, щоб 'змапувати' **дії** (Action Creators) та функцію `dispatch` як **пропси** для вашого React-компонента. Вона дозволяє компоненту викликати зміни стану в Redux Store. \n    -   **Що повертає:** Об'єкт, де ключі стануть назвами пропсів (зазвичай, це функції-колбеки), а значення — функціями, які при виклику надсилають дії до Redux Store. \n    -   **Приклад (як функція):** Якщо вам потрібна функція для збільшення лічильника, ви повернете `{ increment: () => dispatch({ type: 'INCREMENT' }) }`. Компонент отримає `props.increment()`. \n    -   **Приклад (як об'єкт):** `mapDispatchToProps` також може бути об'єктом з action creators, і `react-redux` автоматично оберне їх у `dispatch`. `{ increment, decrement }`. \n\n--- \n\n**Основна різниця між `mapStateToProps` та `mapDispatchToProps`:** \n\n-   **`mapStateToProps`**: Фокусується на **отриманні даних** (`state`) з Redux Store. Вона лише **читає** стан. \n-   **`mapDispatchToProps`**: Фокусується на **модифікації даних** (`dispatch`) у Redux Store. Вона дозволяє компоненту **відправляти дії** для зміни стану. \n\nПростими словами: `mapStateToProps` відповідає на питання \"*які дані мені потрібні?*\", а `mapDispatchToProps` — \"*що я можу зробити, щоб змінити дані?*\"."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q15-aq1",
        "question": "Чому `mapStateToProps` та `mapDispatchToProps` повертають об'єкти з пропсами, а не мутують стан компонента напряму?",
        "answer": "Вони повертають об'єкти з пропсами, щоб дотримуватися реактивного підходу React: компоненти рендеряться на основі пропсів та стану. Цей механізм дозволяє `react-redux` ефективно оновлювати компоненти лише тоді, коли необхідні дані зі стану Redux дійсно змінилися, оптимізуючи рендеринг за допомогою поверхневого порівняння пропсів."
      },
      {
        "id": "redux-q15-aq2",
        "question": "Коли `mapStateToProps` викликається?",
        "answer": "`mapStateToProps` викликається щоразу, коли Redux Store оновлюється. Якщо об'єкт, який вона повертає, відрізняється від попереднього об'єкта пропсів (за поверхневим порівнянням), `react-redux` ініціює повторний рендеринг підключеного компонента."
      },
      {
        "id": "redux-q15-aq3",
        "question": "Коли `mapDispatchToProps` викликається?",
        "answer": "Якщо `mapDispatchToProps` є функцією, вона викликається лише один раз при створенні підключеного компонента (або при зміні `ownProps` та якщо вона залежить від них). Якщо це об'єкт, він також обробляється один раз при створенні компонента. Функції, які вона повертає, викликаються пізніше, коли компонент відправляє дії."
      }
    ]
  },
  {
    "id": "redux-q16",
    "topic": "Redux",
    "mainQuestion": "Як передати параметр із props, що передали компоненту-обгортці, презентаційному компоненту, який він обгортає?",
    "mainAnswer": "При використанні патерну контейнерного/презентаційного компонента з `connect` з `react-redux`, пропси, передані компоненту-обгортці (контейнерному компоненту), автоматично передаються і презентаційному компоненту, який він обгортає. \n\nРозглянемо приклад: \n\n```jsx \n// 1. Презентаційний компонент (Dumb Component) \n// Він просто отримує пропси і рендерить їх \nfunction UserDetails({ userId, userName, userEmail, onEditUser }) { \n  return ( \n    <div> \n      <h2>Деталі користувача {userId}</h2> \n      <p>Ім'я: {userName}</p> \n      <p>Email: {userEmail}</p> \n      <button onClick={() => onEditUser(userId)}>Редагувати</button> \n    </div> \n  ); \n} \n\n// 2. Контейнерний компонент (Smart Component / Wrapper) \n// Це файл, де ви підключаєте UserDetails до Redux \nimport { connect } from 'react-redux'; \nimport { fetchUserDetails, updateUser } from './actions'; \n\n// mapStateToProps отримує `ownProps` як другий аргумент \nconst mapStateToProps = (state, ownProps) => { \n  // ownProps тут це пропси, передані <ConnectedUserDetails userId={123} /> \n  const userId = ownProps.userId; \n  const user = state.users[userId]; // Припустимо, у вас є нормалізований стан users \n  return { \n    userId: userId, // Передаємо userId назад у UserDetails \n    userName: user ? user.name : 'N/A', \n    userEmail: user ? user.email : 'N/A' \n  }; \n}; \n\n// mapDispatchToProps також отримує `ownProps` як другий аргумент, \n// але часто це не потрібно, якщо action creator не залежить від них \nconst mapDispatchToProps = { \n  // Припустимо, що updateUser action creator приймає ID користувача \n  onEditUser: (userId) => updateUser(userId) // або просто updateUser, якщо логіка в action creator \n}; \n\n// Створюємо підключений компонент \nconst ConnectedUserDetails = connect(mapStateToProps, mapDispatchToProps)(UserDetails); \n\nexport default ConnectedUserDetails; \n\n// 3. Використання ConnectedUserDetails у батьківському компоненті \n// Тут ми передаємо параметр 'userId' компоненту-обгортці \nfunction App() { \n  return ( \n    <div> \n      <ConnectedUserDetails userId={123} /> \n      <ConnectedUserDetails userId={456} /> \n    </div> \n  ); \n} \n``` \n\n**Пояснення:** \n-   Коли ви використовуєте `connect(mapStateToProps, mapDispatchToProps)(MyComponent)`, функція `connect` створює новий компонент-обгортку. \n-   Будь-які пропси, які ви передаєте цьому **компоненту-обгортці** (наприклад, `userId={123}` у `<ConnectedUserDetails userId={123} />`), стають доступними як другий аргумент (`ownProps`) у функціях `mapStateToProps` та `mapDispatchToProps`. \n-   Ви можете використовувати ці `ownProps` всередині `mapStateToProps` для вибору специфічних даних зі стану Redux (як у прикладі з `state.users[userId]`). \n-   Важливо, що всі пропси, які були передані обгортці (`ownProps`), а також ті, що були змаповані з Redux за допомогою `mapStateToProps` та `mapDispatchToProps`, об'єднуються і передаються як єдиний об'єкт пропсів безпосередньо до вашого **презентаційного компонента** (`UserDetails` у цьому прикладі). Тобто, `UserDetails` отримує `userId`, `userName`, `userEmail` та `onEditUser` як свої пропси.",
    "additionalQuestions": [
      {
        "id": "redux-q16-aq1",
        "question": "Як це працює з хуками `useSelector` та `useDispatch`?",
        "answer": "З хуками це ще простіше. Ви просто передаєте пропс напряму функціональному компоненту. Наприклад: \n```jsx \nfunction UserDetails({ userId }) { \n  const user = useSelector(state => state.users[userId]); // userId використовується безпосередньо в useSelector \n  const dispatch = useDispatch(); \n  const handleEdit = () => { dispatch(updateUser(userId)); }; \n  return (...); \n} \n// Використання: <UserDetails userId={123} /> \n``` \nТут `userId` є просто пропсом компонента `UserDetails`, і його можна використовувати безпосередньо в хуках."
      },
      {
        "id": "redux-q16-aq2",
        "question": "Чи є різниця в продуктивності при використанні `ownProps` в `mapStateToProps`?",
        "answer": "Використання `ownProps` в `mapStateToProps` саме по собі не є проблемою продуктивності. Проте, якщо `mapStateToProps` виконує дорогі обчислення на основі `ownProps`, і ці `ownProps` часто змінюються, це може призвести до надмірних повторних обчислень. У таких випадках можна використовувати `reselect` для мемоізації селекторів."
      },
      {
        "id": "redux-q16-aq3",
        "question": "Чи можу я змінювати `ownProps` всередині `mapStateToProps` або `mapDispatchToProps`?",
        "answer": "Ні, ви не повинні змінювати `ownProps` всередині цих функцій, оскільки вони є частиною вхідних даних. Ці функції мають бути чистими: вони приймають вхідні дані і повертають новий об'єкт пропсів. Зміна `ownProps` може призвести до непередбачуваної поведінки."
      }
    ]
  },
  {
    "id": "redux-q17",
    "topic": "Redux",
    "mainQuestion": "Як користуватися провайдером з `react-redux`? Чому він потрібен?",
    "mainAnswer": "**Провайдер (Provider)** — це компонент з бібліотеки `react-redux`, який є критично важливим для інтеграції Redux Store з вашим React-застосунком. \n\n**Як користуватися:** \nВи обгортаєте весь ваш React-застосунок (або ту частину, яка має доступ до Redux Store) у компонент `<Provider>`, передаючи йому ваш Redux Store як пропс `store`. \n\n```jsx \n// index.js або App.js \nimport React from 'react'; \nimport ReactDOM from 'react-dom/client'; \nimport { Provider } from 'react-redux'; \nimport { createStore } from 'redux'; \nimport rootReducer from './reducers'; \nimport App from './App'; \n\n// 1. Створюємо Redux Store \nconst store = createStore(rootReducer); \n\n// 2. Обгортаємо кореневий компонент застосунку у Provider \nconst root = ReactDOM.createRoot(document.getElementById('root')); \nroot.render( \n  <React.StrictMode> \n    <Provider store={store}> \n      <App /> \n    </Provider> \n  </React.StrictMode> \n); \n``` \n\n**Чому він потрібен?** \n`Provider` використовує **React Context API** \"під капотом\", щоб зробити Redux Store доступним для всіх підключених компонентів у дереві компонентів, не передаючи його явно як пропс через кожен рівень (уникаючи 'prop drilling'). \n\n**Основні причини його необхідності:** \n1.  **Доступ до Store**: `Provider` робить Redux Store доступним для всіх дочірніх компонентів, які підключаються до Redux за допомогою `connect` або хуків `useSelector`/`useDispatch`. Без нього ці компоненти не зможуть знайти Store і не зможуть отримувати дані або надсилати дії. \n2.  **Управління підписками**: `Provider` керує життєвим циклом підписок на Redux Store. Він гарантує, що підключені компоненти коректно підписуються на зміни стану і відписуються, коли вони розмонтовуються, запобігаючи витокам пам'яті. \n3.  **Оптимізація продуктивності**: Завдяки Context API, `Provider` дозволяє `react-redux` ефективно оптимізувати оновлення. Він гарантує, що лише ті компоненти, які дійсно потребують оновлення через зміну даних зі стану, будуть перерендерені. \n\nПо суті, `Provider` є мостом між Redux Store та вашим React-компонентами, надаючи їм необхідні механізми для взаємодії зі станом централізованого сховища.",
    "additionalQuestions": [
      {
        "id": "redux-q17-aq1",
        "question": "Що таке 'prop drilling' і як `Provider` його уникає?",
        "answer": "'Prop drilling' (або 'прокидання пропсів') — це ситуація, коли дані або колбеки передаються через багато рівнів компонентів у дереві, хоча проміжні компоненти самі ці пропси не використовують. `Provider` уникає цього, роблячи Store доступним через React Context API, дозволяючи будь-якому вкладеному компоненту 'підключитися' до Store без отримання пропсів від батьківських компонентів."
      },
      {
        "id": "redux-q17-aq2",
        "question": "Чи можна мати кілька провайдерів у застосунку?",
        "answer": "Так, технічно можливо, але це дуже рідко потрібно і зазвичай є ознакою проблем з архітектурою. Кожен `Provider` буде надавати свій власний Redux Store дочірньому дереву. Це може бути використано, наприклад, для мікро-фронтендів або в дуже специфічних ситуаціях, але для типового застосунку завжди рекомендується один `Provider` з одним Redux Store."
      },
      {
        "id": "redux-q17-aq3",
        "question": "Чи можна використовувати `Provider` без `connect` або хуків Redux?",
        "answer": "Ви можете використовувати `Provider` з `store` пропсом, але без `connect`, `useSelector` або `useDispatch` ваші компоненти не зможуть взаємодіяти з цим `store`. `Provider` сам по собі лише робить Store доступним через контекст; компоненти все ще потребують механізму (як `connect` або хуки), щоб отримати доступ до цього контексту і взаємодіяти з Store."
      }
    ]
  },
  {
    "id": "redux-q18",
    "topic": "Redux",
    "mainQuestion": "Де б ти викликав асинхроний запит до сервера через Redux?",
    "mainAnswer": "У Redux, асинхронні запити до сервера (або будь-які інші побічні ефекти) зазвичай не викликаються безпосередньо у редюсерах або компонентах (якщо це не дуже простий, локальний запит). Для управління асинхронністю в Redux використовуються **Middleware (проміжне програмне забезпечення)**. \n\nНайпоширеніші місця для виклику асинхронних запитів: \n\n1.  **Redux Thunk (за допомогою `redux-thunk` middleware)**: \n    -   **Що це:** Дозволяє вам писати action creators, які повертають не об'єкти дій, а **функції**. Ці функції отримують `dispatch` та `getState` як аргументи. \n    -   **Де викликати запит:** Всередині цих функцій (т. зв. 'thunks'). Ви відправляєте одну дію на початок запиту, виконуєте асинхронну логіку (наприклад, `fetch` або `axios`), а потім відправляєте іншу дію залежно від результату (успіх чи помилка). \n    -   **Приклад:** \n        ```javascript \n        // actions.js \n        export const fetchPostsRequest = () => ({ type: 'FETCH_POSTS_REQUEST' }); \n        export const fetchPostsSuccess = (posts) => ({ type: 'FETCH_POSTS_SUCCESS', payload: posts }); \n        export const fetchPostsFailure = (error) => ({ type: 'FETCH_POSTS_FAILURE', payload: error }); \n\n        export const fetchPosts = () => { \n          return async (dispatch, getState) => { \n            dispatch(fetchPostsRequest()); // Відправляємо дію про початок запиту \n            try { \n              const response = await fetch('/api/posts'); \n              const data = await response.json(); \n              dispatch(fetchPostsSuccess(data)); // Відправляємо дію про успіх \n            } catch (error) { \n              dispatch(fetchPostsFailure(error.message)); // Відправляємо дію про помилку \n            } \n          }; \n        }; \n        ``` \n        Компонент просто викликає `dispatch(fetchPosts())`. \n\n2.  **Redux Saga (за допомогою `redux-saga` middleware)**: \n    -   **Що це:** Більш потужна і складна бібліотека для управління побічними ефектами, яка використовує ES6 Generators для більш декларативного та контрольованого управління асинхронними потоками. \n    -   **Де викликати запит:** Запити викликаються всередині 'саг' (генераторних функцій), які слухають певні дії, виконують асинхронні операції та надсилають нові дії. \n    -   **Коли використовувати:** Для складних асинхронних потоків, які включають скасування, дебаунсинг, троттлінг, конкурентні запити тощо. \n\n3.  **Redux Observable (за допомогою `redux-observable` middleware)**: \n    -   **Що це:** Використовує RxJS Observables для управління побічними ефектами. \n    -   **Де викликати запит:** Всередині 'епіків' (epic) — функцій, які приймають потік дій і повертають потік дій. \n\n4.  **Redux Toolkit `createAsyncThunk`**: \n    -   **Що це:** Вбудована функція в Redux Toolkit, яка значно спрощує створення асинхронних 'thunks', автоматично генеруючи дії `pending`, `fulfilled` та `rejected`. \n    -   **Приклад:** \n        ```javascript \n        // features/posts/postsSlice.js (з Redux Toolkit) \n        import { createAsyncThunk } from '@reduxjs/toolkit'; \n\n        export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => { \n          const response = await fetch('/api/posts'); \n          const data = await response.json(); \n          return data; \n        }); \n        ``` \n        Це генерує `fetchPosts.pending`, `fetchPosts.fulfilled` та `fetchPosts.rejected` дії, які можна обробляти в редюсері. \n\n**Ніколи не викликайте асинхронні запити безпосередньо у редюсерах**, оскільки вони повинні бути чистими функціями, без побічних ефектів.",
    "additionalQuestions": [
      {
        "id": "redux-q18-aq1",
        "question": "Чому не можна робити асинхронні запити у редюсерах?",
        "answer": "Редюсери повинні бути чистими функціями, що означає відсутність побічних ефектів та детермінованість. Асинхронні операції (як HTTP-запити) є побічними ефектами: вони не детерміновані (результат може змінюватися) і можуть викликати затримки. Їх виконання в редюсері порушить передбачуваність стану, унеможливить 'time-travel debugging' та призведе до невідповідності стану."
      },
      {
        "id": "redux-q18-aq2",
        "question": "У чому різниця між Redux Thunk та Redux Saga?",
        "answer": "`Redux Thunk` є простішим middleware, який дозволяє відправляти функції замість об'єктів дій. Він підходить для більшості простих асинхронних операцій. \n`Redux Saga` є більш потужним і складним, використовує Generators (і спеціальні 'effects') для управління асинхронними потоками. Він краще підходить для складних сценаріїв, де потрібні такі можливості, як скасування запитів, обробка 'race conditions', троттлінг, дебаунсинг тощо."
      },
      {
        "id": "redux-q18-aq3",
        "question": "Як Redux Toolkit допомагає з асинхронними запитами?",
        "answer": "Redux Toolkit значно спрощує асинхронні запити за допомогою функції `createAsyncThunk`. Вона дозволяє легко створювати thunks, які автоматично відправляють три типи дій (`pending`, `fulfilled`, `rejected`) для обробки різних стадій асинхронної операції. Це зменшує бойлерплейт та стандартизує підхід до асинхронності в Redux."
      }
    ]
  },
  {
    "id": "redux-q19",
    "topic": "Redux",
    "mainQuestion": "Що таке middlewares в Redux? Які middleware ти використовував на проектах?",
    "mainAnswer": "**Middleware (Проміжне програмне забезпечення)** у Redux — це спеціальні функції, які надають третю сторону розширення для `dispatch` функції сховища. Вони розташовуються між відправкою дії (dispatching an action) та її досягненням редюсера. \n\nПо суті, middleware перехоплює дії, які надсилаються, і може робити з ними що завгодно: \n-   Виконувати асинхронні операції (наприклад, мережеві запити). \n-   Логувати дії та стан. \n-   Перетворювати дії. \n-   Виконувати умовну логіку. \n-   Зупиняти або модифікувати дію перед її надсиланням до редюсера. \n\nВони дозволяють додавати функціональність (побічні ефекти) до Redux Store, не порушуючи принципів чистих редюсерів. \n\n**Як працює Middleware:** \n`dispatch` є єдиним способом відправки дій у Redux. Без middleware, `dispatch` просто надсилає дію до редюсера. З middleware, `dispatch` спочатку надсилає дію через ланцюжок middleware. Кожне middleware може обробити дію, а потім передати її наступному middleware в ланцюжку, або зупинити ланцюжок. \n\n**Приклади `middlewares`, які я використовував на проектах:** \n\n1.  **`redux-thunk`**: \n    -   **Призначення:** Дозволяє писати action creators, які повертають функції (thunks) замість об'єктів дій. Це дозволяє виконувати асинхронні операції (наприклад, мережеві запити) і відправляти кілька дій (наприклад, `REQUEST`, `SUCCESS`, `FAILURE`) протягом одного асинхронного потоку. \n    -   **Використання:** Найпоширеніший вибір для простих асинхронних операцій завдяки своїй простоті. \n\n2.  **`redux-saga`**: \n    -   **Призначення:** Більш потужна і складна бібліотека для управління побічними ефектами, яка використовує ES6 Generators. Дозволяє писати 'саги' для декларативного управління асинхронними потоками, обробки 'race conditions', скасування запитів тощо. \n    -   **Використання:** Для великих проектів зі складною асинхронною логікою, яка вимагає більшого контролю та тестування. \n\n3.  **`redux-logger`**: \n    -   **Призначення:** Логує всі дії та зміни стану у консолі розробника. Дуже корисний для налагодження. \n    -   **Використання:** Виключно в режимі розробки, щоб отримати візуальне представлення потоку даних. \n\n4.  **`redux-persist`**: \n    -   **Призначення:** Дозволяє зберігати стан Redux у локальному сховищі (localStorage, AsyncStorage тощо) і 'гідратувати' його при перезавантаженні застосунку. \n    -   **Використання:** Для збереження стану користувача, кошика покупок, налаштувань тощо, щоб вони були доступні після оновлення сторінки."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q19-aq1",
        "question": "Як підключити middleware до Redux Store?",
        "answer": "Middleware підключаються до Redux Store при його створенні за допомогою функції `applyMiddleware` з Redux. \n```javascript \nimport { createStore, applyMiddleware } from 'redux'; \nimport thunk from 'redux-thunk'; \nimport logger from 'redux-logger'; \nimport rootReducer from './reducers'; \n\nconst store = createStore( \n  rootReducer, \n  applyMiddleware(thunk, logger) \n); \n``` \nЯкщо ви використовуєте Redux Toolkit, то `configureStore` автоматично включає `redux-thunk` та `redux-dev-tools` за замовчуванням."
      },
      {
        "id": "redux-q19-aq2",
        "question": "Яка послідовність виконання middleware?",
        "answer": "Middleware виконуються в тому порядку, в якому вони передаються в `applyMiddleware`. Якщо ви передаєте `applyMiddleware(thunk, logger)`, спочатку буде виконаний `thunk`, потім `logger`, а вже потім дія дійде до редюсера. Порядок може бути важливим, наприклад, `redux-logger` краще розміщувати останнім, щоб він логував дії після їх обробки іншими middleware."
      },
      {
        "id": "redux-q19-aq3",
        "question": "Чи можна написати власне middleware?",
        "answer": "Так, Redux надає API для написання власних middleware. Це дозволяє розробникам додавати кастомну логіку до потоку Redux, що є потужним інструментом для розширення функціональності Redux Store відповідно до потреб застосунку."
      }
    ]
  },
  {
    "id": "redux-q20",
    "topic": "Redux",
    "mainQuestion": "Що таке thunk? Як його писати і підключати?",
    "mainAnswer": "**Thunk (функція-санкція)** в контексті Redux — це функція, яка повертається `action creator` замість звичайного об'єкта дії. Ця функція не є 'чистою' і може містити побічні ефекти (наприклад, асинхронні запити, логіка, яка залежить від поточного стану). \n\n**Призначення Thunk:** \nЗвичайні Redux редюсери є синхронними та чистими функціями, вони не можуть виконувати побічні ефекти. Thunks дозволяють обробляти асинхронну логіку (як-от мережеві запити, затримки за допомогою `setTimeout`) та інші побічні ефекти поза редюсерами, перш ніж чистий об'єкт дії буде надісланий до редюсера. \n\n**Як він працює:** \n1.  `action creator` повертає функцію (thunk) замість об'єкта дії. \n2.  Ця функція `thunk` отримує два аргументи: `dispatch` (функція для надсилання інших дій) та `getState` (функція для отримання поточного стану Redux). \n3.  Всередині `thunk` ви можете виконувати асинхронні операції, а потім, залежно від результату, `dispatch` інші дії, які вже є чистими об'єктами і будуть оброблені редюсерами. \n\n**Як писати thunk:** \n```javascript \n// actionTypes.js \nexport const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST'; \nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS'; \nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE'; \n\n// actions.js \nimport { FETCH_DATA_REQUEST, FETCH_DATA_SUCCESS, FETCH_DATA_FAILURE } from './actionTypes'; \n\n// Action Creators, що повертають об'єкти дій \nexport const fetchDataRequest = () => ({ type: FETCH_DATA_REQUEST }); \nexport const fetchDataSuccess = (data) => ({ type: FETCH_DATA_SUCCESS, payload: data }); \nexport const fetchDataFailure = (error) => ({ type: FETCH_DATA_FAILURE, payload: error }); \n\n// Thunk - Action Creator, що повертає функцію \nexport const fetchSomeData = () => { \n  return async (dispatch, getState) => { \n    dispatch(fetchDataRequest()); // 1. Відправляємо дію про початок запиту \n    try { \n      // 2. Виконуємо асинхронну операцію (наприклад, мережевий запит) \n      const response = await fetch('[https://api.example.com/data](https://api.example.com/data)'); \n      const data = await response.json(); \n      dispatch(fetchDataSuccess(data)); // 3. Відправляємо дію про успіх з даними \n    } catch (error) { \n      dispatch(fetchDataFailure(error.message)); // 3. Відправляємо дію про помилку \n    } \n    // Можна також отримати стан: \n    // const currentUserId = getState().user.id; \n  }; \n}; \n``` \n\n**Як підключати `redux-thunk` middleware:** \n`redux-thunk` є окремою бібліотекою, яку потрібно встановити (`npm install redux-thunk` або `yarn add redux-thunk`) та застосувати до вашого Redux Store. \n\n```javascript \n// store.js \nimport { createStore, applyMiddleware } from 'redux'; \nimport { thunk } from 'redux-thunk'; // Імпортуємо thunk \nimport rootReducer from './reducers'; \n\nconst store = createStore( \n  rootReducer, \n  applyMiddleware(thunk) // Застосовуємо thunk як middleware \n); \n\nexport default store; \n``` \n\n**З Redux Toolkit:** \nЯкщо ви використовуєте Redux Toolkit, `redux-thunk` вже включений за замовчуванням при використанні `configureStore`, і ви можете писати thunks за допомогою `createAsyncThunk`, який значно спрощує цей процес.",
    "additionalQuestions": [
      {
        "id": "redux-q20-aq1",
        "question": "Які переваги `redux-thunk`?",
        "answer": "`redux-thunk` є простим, легким для вивчення та розуміння. Він не додає багато бойлерплейту і є достатнім для більшості асинхронних операцій у застосунку. Його легко інтегрувати та тестувати."
      },
      {
        "id": "redux-q20-aq2",
        "question": "Коли варто розглянути альтернативи `redux-thunk` (наприклад, Redux Saga)?",
        "answer": "Варто розглянути альтернативи, якщо ваш застосунок має дуже складні асинхронні потоки, які вимагають: \n-   Скасування запитів. \n-   Обробку 'race conditions' (коли кілька запитів конкурують). \n-   Троттлінг або дебаунсинг дій. \n-   Паттерни, такі як 'fork/join' асинхронних операцій. \n-   Більш декларативний спосіб опису побічних ефектів."
      },
      {
        "id": "redux-q20-aq3",
        "question": "Чи може thunk відправити інший thunk?",
        "answer": "Так, thunk може відправити (dispatch) інший thunk. Це дозволяє створювати ланцюжки асинхронних операцій або організовувати більш складну логіку, де одна асинхронна дія запускає іншу."
      }
    ]
  }
]