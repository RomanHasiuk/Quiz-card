[
  {
    "id": "redux-q1",
    "topic": "Redux",
    "mainQuestion": "Якими є основні засади Редакса і в чому полягають його переваги?",
    "mainAnswer": "Redux — це передбачуваний контейнер стану для JavaScript-застосунків, що допомагає писати послідовний код, який поводиться однаково в різних середовищах (клієнт, сервер, нативний). \n\n**Три основні засади (принципи) Redux:** \n1.  **Єдине джерело істини (Single Source of Truth)**: Весь стан застосунку зберігається в одному об'єкті в єдиному сховищі (Store). Це спрощує відстеження стану та налагодження. \n2.  **Стан доступний лише для читання (State is Read-Only)**: Єдиний спосіб змінити стан — це надіслати дію (Action) — простий JavaScript-об'єкт, що описує, що сталося. Це гарантує, що зміни стану відбуваються передбачувано і централізовано. \n3.  **Зміни виконуються чистими функціями (Changes are Made with Pure Functions)**: Для вказівки, як стан змінюється у відповідь на дії, ви пишете редюсери (Reducers) — чисті функції, які приймають поточний стан та дію, і повертають новий стан. Вони ніколи не мутують поточний стан, а створюють його нову копію. \n\n**Переваги Redux:** \n-   **Передбачуваність стану**: Завдяки трьом принципам, зміни стану легко відстежувати, що значно спрощує налагодження та розуміння поведінки застосунку. \n-   **Легкість тестування**: Редюсери є чистими функціями, що робить їх надзвичайно легкими для тестування. \n-   **Централізоване управління станом**: Весь стан в одному місці, що усуває проблеми з 'prop drilling' для глобальних даних. \n-   **Могутній інструмент для налагодження (Redux DevTools)**: Дозволяє бачити кожну дію, зміну стану, подорожувати в часі по стану (time-travel debugging), що є неймовірно потужним. \n-   **Масштабованість**: Дуже добре підходить для великих і складних застосунків з великою кількістю спільних даних. \n-   **Екосистема**: Велика кількість middleware, розширень та спільнота.",
    "additionalQuestions": [
      {
        "id": "redux-q1-aq1",
        "question": "Що таке 'time-travel debugging' у Redux DevTools?",
        "answer": "'Time-travel debugging' дозволяє відтворювати дії, які були виконані в застосунку, крок за кроком, або навіть 'відкочувати' стан до попереднього моменту. Це надзвичайно корисно для відлагодження складних багажних ситуацій."
      },
      {
        "id": "redux-q1-aq2",
        "question": "Чи є Redux фреймворком?",
        "answer": "Ні, Redux — це бібліотека, а не фреймворк. Він не нав'язує вам певну архітектуру для всього застосунку, а лише надає спосіб керування станом. Він є гнучким і може використовуватися з будь-яким UI-фреймворком або бібліотекою (React, Angular, Vue, тощо)."
      },
      {
        "id": "redux-q1-aq3",
        "question": "Чи обов'язково використовувати Redux для кожного React-застосунку?",
        "answer": "Ні. Для невеликих застосунків або тих, де стан компонентів не є дуже складним або не вимагає багато спільного використання, вбудовані можливості React (наприклад, `useState`, `useContext`, `useReducer`) можуть бути цілком достатніми. Redux додає певну складність, тому його варто використовувати лише тоді, коли переваги переважають накладні витрати."
      }
    ]
  },
  {
    "id": "redux-q2",
    "topic": "Redux",
    "mainQuestion": "Які переваги дає Redux? Які слабкі місця ти бачиш в цьому підході?",
    "mainAnswer": "**Переваги Redux:** \n-   **Прогнозованість**: Стан змінюється передбачувано, оскільки всі зміни проходять через редюсери та дії. \n-   **Централізація стану**: Весь стан в одному місці, що спрощує доступ та відстеження. \n-   **Потужні інструменти для налагодження**: Redux DevTools з 'time-travel debugging' є неперевершеними для розуміння потоку даних та відтворення багів. \n-   **Ізольовані зміни**: Кожна дія викликає нову версію стану, що спрощує ізоляцію змін. \n-   **Екосистема та спільнота**: Велика кількість middleware та активна спільнота. \n-   **Масштабованість**: Добре підходить для великих і складних проектів. \n\n**Слабкі місця (недоліки):** \n-   **Бойлерплейт (Boilerplate)**: Навіть для невеликих змін стану може знадобитися створити дію, константу для типу дії, action creator та додати логіку в редюсер. Це може бути надмірним для простих застосунків. \n-   **Крива навчання**: Концепції Redux (чисті функції, імутабельність, middleware) можуть бути складними для початківців. \n-   **Надмірність для простих застосунків**: Для невеликих проектів додавання Redux може бути зайвим і ускладнити код, замість того, щоб спростити його. \n-   **Оптимізація рендерингу**: Хоча Redux сам по собі не викликає зайвих рендерингів, розробнику все ще потрібно бути обережним з оптимізацією компонентів, щоб уникнути непотрібних рендерингів при зміні стану (наприклад, з `React.memo` або `useSelector` з відповідними селекторами). \n-   **Управління асинхронністю**: Redux сам по собі синхронний. Для асинхронних операцій (наприклад, мережевих запитів) потрібні додаткові бібліотеки (middleware) на кшталт Redux Thunk або Redux Saga, що додає ще одну складність."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q2-aq1",
        "question": "Які сучасні альтернативи Redux і чому вони можуть бути кращими для деяких сценаріїв?",
        "answer": "Сучасні альтернативи: `Zustand`, `Jotai`, `Recoil`, `Valtio`, `React Context API` (+ `useReducer`). Вони часто пропонують менше бойлерплейту, простішу інтеграцію та більш 'React-центричний' підхід (використовуючи хуки) до управління станом, що може бути кращим для менших або середніх застосунків, де не потрібна вся потужність та інструменти Redux."
      },
      {
        "id": "redux-q2-aq2",
        "question": "Чому Redux не є Silver Bullet (універсальним рішенням)?",
        "answer": "Redux не є 'срібною кулею', оскільки, хоча він вирішує проблему централізованого управління станом і передбачуваності, він вводить власні складнощі (бойлерплейт, крива навчання, необхідність middleware для асинхронності). Він найкраще підходить для великих, складних застосунків, де його переваги переважають ці накладні витрати."
      },
      {
        "id": "redux-q2-aq3",
        "question": "Чи можна використовувати Redux і React Context API в одному проекті?",
        "answer": "Так, можна і навіть часто доцільно. Redux можна використовувати для глобального, складного або часто оновлюваного стану, який потребує потужних інструментів налагодження. React Context API можна використовувати для передачі менш критичних даних або даних, які рідко змінюються, наприклад, налаштування теми або дані автентифікованого користувача, щоб уникнути 'prop drilling' для цих конкретних випадків."
      }
    ]
  },
  {
    "id": "redux-q3",
    "topic": "Redux",
    "mainQuestion": "Що таке стан у Редаксі?",
    "mainAnswer": "**Стан (State)** у Redux — це єдиний об'єкт JavaScript, який представляє собою весь стан вашого застосунку. Цей об'єкт зберігається в єдиному сховищі (Store) Redux. \n\n**Ключові характеристики стану Redux:** \n-   **Єдиний об'єкт**: Незалежно від складності застосунку, весь його стан (наприклад, дані користувача, списки товарів, стан UI, тощо) агрегується в одному кореневому об'єкті стану. \n-   **Імутабельний**: Стан ніколи не модифікується безпосередньо. Кожного разу, коли стан змінюється, редюсер (Reducer) повертає **новий об'єкт стану** з оновленими даними. Оригінальний об'єкт стану залишається незмінним. Це дозволяє Redux ефективно відстежувати зміни та забезпечує 'time-travel debugging'. \n-   **Нормалізований (часто)**: Для складних застосунків стан часто нормалізується, тобто дані зберігаються у вигляді об'єктів з ID, а не вкладених структур або дубльованих даних. Це спрощує управління даними та їх оновлення. \n-   **Представляє весь UI**: Стан повинен містити всі дані, необхідні для рендерингу вашого інтерфейсу. \n\n**Приклад об'єкта стану:** \n```json \n{ \n  \"user\": { \n    \"id\": \"123\", \n    \"name\": \"Роман\", \n    \"isLoggedIn\": true \n  }, \n  \"products\": [ \n    { \"id\": \"p1\", \"name\": \"Лаптоп\", \"price\": 1200 }, \n    { \"id\": \"p2\", \"name\": \"Мишка\", \"price\": 25 } \n  ], \n  \"cart\": { \n    \"items\": [\"p1\"], \n    \"totalAmount\": 1200 \n  }, \n  \"ui\": { \n    \"loading\": false, \n    \"error\": null \n  } \n} \n``` \nRedux дозволяє вам легко 'знімати знімки' цього об'єкта стану в будь-який момент часу, що є основою для його потужних інструментів налагодження.",
    "additionalQuestions": [
      {
        "id": "redux-q3-aq1",
        "question": "Чому стан у Redux має бути імутабельним?",
        "answer": "Імутабельність є фундаментальною для Redux, оскільки вона дозволяє: \n1.  **Просто і ефективно виявляти зміни**: Redux (та інші оптимізації, такі як `PureComponent` або `React.memo`) може просто порівняти посилання на об'єкт стану. Якщо посилання змінилося, стан змінився. \n2.  **Функції-редюсери бути чистими**: Чисті функції не мають побічних ефектів і не змінюють своїх аргументів. \n3.  **Time-travel debugging**: Можливість 'подорожувати в часі' по стану завдяки збереженню історії імутабельних знімків стану."
      },
      {
        "id": "redux-q3-aq2",
        "question": "Чи всі дані в React-застосунку повинні бути в Redux state?",
        "answer": "Ні. Лише ті дані, які є 'глобальними' для застосунку або які використовуються багатьма компонентами, або ті, що вимагають централізованого управління та потужних інструментів налагодження. Локальний стан компонентів (наприклад, стан форми, яка використовується лише одним компонентом) зазвичай краще залишати в `useState` або `this.state`."
      },
      {
        "id": "redux-q3-aq3",
        "question": "Як Redux забезпечує, що стан є єдиним джерелом істини?",
        "answer": "Redux забезпечує це, примушуючи всі зміни стану відбуватися через надсилання дій (actions) до єдиного сховища (store). Жоден інший спосіб прямої модифікації стану не допускається, що гарантує, що весь UI відображає лише той стан, який знаходиться в сторі."
      }
    ]
  },
  {
    "id": "redux-q4",
    "topic": "Redux",
    "mainQuestion": "Що таке reducer? Які обов’язкові вимоги до них існують?",
    "mainAnswer": "**Редюсер (Reducer)** у Redux — це чиста функція, яка приймає поточний стан застосунку та дію (Action) як аргументи, і повертає **новий об'єкт стану**. Редюсери є єдиним місцем, де дозволено змінювати стан у Redux. \n\nНазва 'reducer' походить від функції `reduce` у JavaScript (наприклад, `Array.prototype.reduce()`), яка приймає колбек-функцію, що оперує з акумулятором та поточним елементом, повертаючи нове значення акумулятора. У Redux редюсер виконує схожу роль: він 'згортає' дії в новий стан. \n\n**Обов'язкові вимоги до редюсерів:** \n1.  **Чиста функція**: \n    -   Не повинна мати побічних ефектів (наприклад, змінювати зовнішні змінні, виконувати HTTP-запити, читати локальне сховище, мутувати аргументи). \n    -   При тих самих вхідних аргументах (поточний стан та дія) завжди повинна повертати один і той самий вихідний стан. \n2.  **Не мутувати стан**: \n    -   Редюсер повинен повертати **новий об'єкт стану**, а не змінювати безпосередньо переданий `state` або `action`. Для оновлення об'єктів та масивів слід використовувати оператори спред (`...`), `Object.assign`, `concat` та інші методи, що створюють копії. \n3.  **Обробляти будь-яку дію**: \n    -   Редюсер повинен мати логіку `default`, яка повертає поточний `state`, якщо передана дія не відповідає жодному відомому типу дії. Це важливо, оскільки Redux надсилає багато системних дій. \n4.  **Початковий стан**: \n    -   Редюсер повинен повертати початковий стан застосунку, якщо аргумент `state` є `undefined` (це відбувається при першому запуску застосунку). Це зазвичай робиться шляхом призначення значення за замовчуванням параметру `state`. \n\n**Приклад:** \n```javascript \nconst initialState = { count: 0 }; \nfunction counterReducer(state = initialState, action) { \n  switch (action.type) { \n    case 'INCREMENT': \n      return { ...state, count: state.count + 1 }; \n    case 'DECREMENT': \n      return { ...state, count: state.count - 1 }; \n    default: \n      return state; // Завжди повертати поточний стан за замовчуванням \n  } \n} \n```",
    "additionalQuestions": [
      {
        "id": "redux-q4-aq1",
        "question": "Чому редюсери повинні бути чистими функціями?",
        "answer": "Чистота редюсерів забезпечує: \n-   **Прогнозованість**: Той самий вхід завжди дає той самий вихід. \n-   **Легкість тестування**: Їх можна тестувати ізольовано. \n-   **Налагодження**: Спрощує 'time-travel debugging' та відстеження змін. \n-   **Оптимізації**: Дозволяє Redux та іншим бібліотекам ефективно порівнювати стан для оптимізації рендерингу."
      },
      {
        "id": "redux-q4-aq2",
        "question": "Що станеться, якщо редюсер мутує стан?",
        "answer": "Якщо редюсер мутує стан, Redux не зможе виявити, що стан змінився, оскільки посилання на об'єкт стану залишається тим самим. Це призведе до: \n-   UI не буде оновлюватися, навіть якщо дані в стані змінилися. \n-   Порушення 'time-travel debugging'. \n-   Непередбачуваної поведінки та складнощів у налагодженні."
      },
      {
        "id": "redux-q4-aq3",
        "question": "Чи може редюсер виконувати асинхронні операції?",
        "answer": "Ні, редюсер не може і не повинен виконувати асинхронні операції або будь-які побічні ефекти. Редюсер повинен бути строго синхронним і чистим. Асинхронна логіка в Redux обробляється за допомогою middleware (наприклад, Redux Thunk або Redux Saga)."
      }
    ]
  },
  {
    "id": "redux-q5",
    "topic": "Redux",
    "mainQuestion": "Що таке pure function?",
    "mainAnswer": "**Чиста функція (Pure Function)** — це концепція з функціонального програмування, яка описує функцію, що задовольняє двом основним вимогам: \n\n1.  **Детермінованість (Deterministic)**: При одних і тих самих вхідних аргументах функція завжди повертає один і той самий вихідний результат. Її результат залежить лише від її аргументів. \n2.  **Відсутність побічних ефектів (No Side Effects)**: Функція не повинна змінювати жодні дані поза своєю локальною областю видимості, і вона не повинна взаємодіяти із зовнішнім світом (наприклад, змінювати глобальні змінні, виконувати операції вводу/виводу, такі як HTTP-запити, читання/запис до бази даних, вивід на консоль, зміна DOM, генерація випадкових чисел). \n\n**Приклад чистої функції:** \n```javascript \nfunction add(a, b) { \n  return a + b; // Завжди повертає суму a і b, не має побічних ефектів \n} \n``` \n**Приклад нечистої функції:** \n```javascript \nlet total = 0; \nfunction addToTotal(value) { \n  total += value; // Має побічний ефект: змінює зовнішню змінну 'total' \n  return total; \n} \n``` \n**Чому чисті функції важливі в Redux:** \n-   **Прогнозованість**: Легко передбачити, що функція зробить. \n-   **Легкість тестування**: Оскільки вони не залежать від зовнішнього стану і не мають побічних ефектів, їх дуже легко тестувати ізольовано. \n-   **Мемоізація**: Результати чистих функцій можна кешувати, оскільки вони завжди повертатимуть той самий результат для тих самих аргументів. \n-   **Паралельне виконання**: Чисті функції не викликають конфліктів при паралельному виконанні."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q5-aq1",
        "question": "Наведіть приклад побічного ефекту, який робить функцію нечистою.",
        "answer": "Приклади побічних ефектів, які роблять функцію нечистою: \n-   Модифікація глобальної змінної. \n-   Виконання HTTP-запиту до сервера. \n-   Запис у локальне сховище (localStorage). \n-   Зміна DOM-елемента. \n-   Генерація випадкових чисел (оскільки результат не є детермінованим)."
      },
      {
        "id": "redux-q5-aq2",
        "question": "Чому редюсери в Redux повинні бути чистими функціями?",
        "answer": "Редюсери повинні бути чистими функціями, щоб гарантувати передбачуваність стану, полегшити тестування, дозволити використання 'time-travel debugging' у Redux DevTools та забезпечити, що зміни стану відбуваються лише у контрольований та імутабельний спосіб."
      },
      {
        "id": "redux-q5-aq3",
        "question": "Чи може чиста функція приймати об'єкти як аргументи?",
        "answer": "Так, чиста функція може приймати об'єкти як аргументи. Головне правило — вона не повинна мутувати (змінювати) ці об'єкти. Якщо потрібно змінити об'єкт, вона має створити та повернути його нову копію."
      }
    ]
  },
  {
    "id": "redux-q6",
    "topic": "Redux",
    "mainQuestion": "Які елементи стану можна було б виділити для базового функціоналу Google: введення пошукового запиту — отримання результатів — введення нового запиту — отримання нових результатів і т. д.?",
    "mainAnswer": "Для базового функціоналу Google, що включає введення пошукового запиту та отримання результатів, можна було б виділити такі елементи стану в Redux (враховуючи, що вони є глобальними або спільними для різних частин застосунку): \n\n```json \n{ \n  \"search\": { \n    \"query\": \"\", // Рядок поточного пошукового запиту, введеного користувачем \n    \"results\": [], // Масив об'єктів, що представляють результати пошуку \n    \"loading\": false, // Булевий індикатор, чи відбувається завантаження результатів \n    \"error\": null, // Об'єкт або рядок для зберігання інформації про помилку, якщо така виникла \n    \"currentPage\": 1, // Поточна сторінка результатів (для пагінації) \n    \"totalResults\": 0 // Загальна кількість знайдених результатів \n  }, \n  \"ui\": { \n    \"isSearchInputFocused\": false, // Чи сфокусоване поле введення пошуку \n    \"showSearchResultsPanel\": false // Чи відображається панель з результатами пошуку \n  }, \n  \"userPreferences\": { \n    \"safeSearchEnabled\": true, \n    \"language\": \"uk\" \n  } \n  // ...інші можливі глобальні стани, наприклад, user, notifications, etc. \n} \n``` \n\n**Пояснення:** \n-   **`search.query`**: Це вхідні дані від користувача, які впливають на результати. \n-   **`search.results`**: Це дані, отримані з сервера, які відображаються на UI. \n-   **`search.loading`**: Це стан UI, який показує, що відбувається асинхронна операція, і користувач повинен чекати. \n-   **`search.error`**: Важливий для UX, щоб повідомити користувача про проблеми. \n-   **`search.currentPage` / `totalResults`**: Дозволяють керувати пагінацією та відображати інформацію про кількість результатів. \n-   **`ui.*`**: Стан, що стосується лише інтерфейсу (наприклад, чи відкритий якийсь модальний вікно, чи активна певна вкладка), хоча для простих UI-станів часто достатньо `useState` у компонентах."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q6-aq1",
        "question": "Чому `loading` і `error` стани є важливими для асинхронних операцій?",
        "answer": "`loading` індикатор дозволяє показати користувачеві, що відбувається завантаження даних, покращуючи UX. `error` стан дозволяє повідомити користувача про проблеми, що виникли під час запиту, і надати зворотний зв'язок, що є критично важливим для надійних застосунків."
      },
      {
        "id": "redux-q6-aq2",
        "question": "Як би ви розділили цей стан між кількома редюсерами?",
        "answer": "Для такого стану можна створити окремі редюсери, які відповідають за певні частини стану. Наприклад: \n-   `searchReducer` для стану `search`. \n-   `uiReducer` для стану `ui`. \n-   `userPreferencesReducer` для стану `userPreferences`. \nПотім ці редюсери об'єднуються за допомогою функції `combineReducers`."
      },
      {
        "id": "redux-q6-aq3",
        "question": "Чи варто зберігати DOM-елементи або їхні посилання в Redux state?",
        "answer": "Ні, категорично не варто. Redux state повинен містити лише прості JavaScript-об'єкти, масиви та примітиви, які можуть бути серіалізовані (тобто перетворені на JSON-рядки). Зберігання DOM-елементів або посилань на них у стані Redux порушує його принципи, ускладнює серіалізацію, робить стан непередбачуваним і унеможливлює використання Redux DevTools."
      }
    ]
  },
  {
    "id": "redux-q7",
    "topic": "Redux",
    "mainQuestion": "Що таке дії (actions)? Який у загальному випадку вони мають вигляд?",
    "mainAnswer": "**Дія (Action)** у Redux — це простий JavaScript-об'єкт, який описує подію, що сталася в застосунку. Це єдиний спосіб повідомити Redux Store, що вам потрібно змінити стан. \n\nДії є 'посилками' з даними, які ви надсилаєте зі свого застосунку до сховища. \n\n**Обов'язкові властивості дії:** \n-   **`type`**: Рядок-константа (наприклад, `'ADD_TODO'`, `'USER_LOGGED_IN'`), яка **обов'язково** визначає тип дії, що відбулася. Це поле є обов'язковим, і саме за цим типом редюсери визначають, як реагувати на дію. \n\n**Інші властивості:** \n-   **`payload`**: Зазвичай містить будь-які дані, необхідні для оновлення стану. Це може бути число, рядок, об'єкт або масив. Вміст `payload` залежить від конкретної дії. Термін `payload` не є обов'язковим, але є загальноприйнятою конвенцією. \n\n**Загальний вигляд дії:** \n```javascript \n{ \n  type: 'UNIQUE_ACTION_TYPE_STRING', \n  payload: { \n    // Будь-які дані, необхідні для обробки цієї дії в редюсері \n    // Зазвичай це дані, які 'прийшли' в результаті події \n  } \n} \n``` \n\n**Приклади дій:** \n```javascript \n// Дія додавання елемента до списку справ \n{ \n  type: 'ADD_TODO', \n  payload: { \n    id: 1, \n    text: 'Вивчити Redux', \n    completed: false \n  } \n} \n\n// Дія завантаження даних (початок) \n{ \n  type: 'FETCH_USERS_REQUEST' \n} \n\n// Дія завантаження даних (успіх) \n{ \n  type: 'FETCH_USERS_SUCCESS', \n  payload: { \n    users: [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }] \n  } \n} \n``` \nДії є основними будівельними блоками для опису того, що відбувається у вашому застосунку, і Redux Store є єдиним об'єктом, який їх отримує та обробляє.",
    "additionalQuestions": [
      {
        "id": "redux-q7-aq1",
        "question": "Хто створює та надсилає дії?",
        "answer": "Дії створюються за допомогою action creators (функцій, які повертають об'єкти дій), а надсилаються (dispatch) до сховища (store) зазвичай з компонентів React (або з middleware, або з інших частин застосунку) за допомогою методу `store.dispatch(action)`."
      },
      {
        "id": "redux-q7-aq2",
        "question": "Чи обов'язкова властивість `payload` у дії?",
        "answer": "Ні, властивість `payload` не є обов'язковою. Якщо дія просто повідомляє про подію, яка не вимагає додаткових даних для зміни стану (наприклад, `'TOGGLE_MENU'`), то `payload` може бути відсутнім."
      },
      {
        "id": "redux-q7-aq3",
        "question": "Чому тип дії має бути рядковою константою?",
        "answer": "Тип дії має бути рядковою константою, щоб зменшити ймовірність друкарських помилок та забезпечити передбачуваність. Використання констант дозволяє інструментам розробника (Redux DevTools) легше відстежувати дії, а також дозволяє TypeScript краще працювати з типами дій."
      }
    ]
  },
  {
    "id": "redux-q8",
    "topic": "Redux",
    "mainQuestion": "Що таке action creators? Чи обов’язково різні типи дій задавати константами?",
    "mainAnswer": "**Action Creator (Створювач дії)** — це функція, яка просто повертає об'єкт дії (Action). Це зручний спосіб інкапсулювати процес створення дії та гарантувати, що всі дії певного типу будуть мати послідовний вигляд. Вони допомагають уникнути дублювання коду та помилок. \n\n**Приклад Action Creator:** \n```javascript \n// Без Action Creator \n// dispatch({ type: 'ADD_TODO', payload: { id: 1, text: 'Купити хліб' } }); \n\n// З Action Creator \nconst addTodo = (id, text) => ({ \n  type: 'ADD_TODO', \n  payload: { id, text } \n}); \n// dispatch(addTodo(1, 'Купити хліб')); \n``` \n\n**Чи обов'язково різні типи дій задавати константами?** \n**Так, це дуже рекомендована практика**, хоча технічно не є абсолютною вимогою (Redux буде працювати і з рядками напряму). \n\n**Причини використання констант для типів дій:** \n1.  **Запобігання друкарським помилкам**: Якщо ви зробите друкарську помилку в назві константи, JavaScript видасть помилку під час компіляції (або раніше в редакторі), тоді як помилка в рядковому літералі може залишитися непоміченою до моменту виконання. \n2.  **Централізоване управління**: Усі типи дій зібрані в одному місці, що полегшує їх відстеження та підтримку. \n3.  **Автодоповнення та рефакторинг**: IDE може надавати автодоповнення для констант, а також полегшує рефакторинг (зміну назви) без ризику пропустити оновлення в усіх місцях використання. \n4.  **Redux DevTools**: Інструменти розробника краще працюють з чітко визначеними константами. \n\n**Приклад використання констант:** \n```javascript \n// constants.js \nexport const ADD_TODO = 'ADD_TODO'; \nexport const REMOVE_TODO = 'REMOVE_TODO'; \n\n// actions.js \nimport { ADD_TODO, REMOVE_TODO } from './constants'; \nexport const addTodo = (id, text) => ({ \n  type: ADD_TODO, \n  payload: { id, text } \n}); \nexport const removeTodo = (id) => ({ \n  type: REMOVE_TODO, \n  payload: { id } \n}); \n\n// reducer.js \nimport { ADD_TODO, REMOVE_TODO } from './constants'; \nfunction todosReducer(state = [], action) { \n  switch (action.type) { \n    case ADD_TODO: \n      return [...state, action.payload]; \n    case REMOVE_TODO: \n      return state.filter(todo => todo.id !== action.payload.id); \n    default: \n      return state; \n  } \n} \n```",
    "additionalQuestions": [
      {
        "id": "redux-q8-aq1",
        "question": "Яка роль `payload` в об'єкті дії?",
        "answer": "`payload` (корисне навантаження) — це загальноприйнята конвенція для назви властивості, яка містить дані, необхідні для того, щоб редюсер міг обробити дію та оновити стан. Це можуть бути будь-які дані: ідентифікатори, рядки, числа, об'єкти, масиви тощо."
      },
      {
        "id": "redux-q8-aq2",
        "question": "Чи обов'язково мати окремі файли для констант, action creators та редюсерів?",
        "answer": "Це загальноприйнята структура файлів у великих Redux-застосунках для кращої організації та відокремлення відповідальності. Однак для менших проектів або в рамках концепції 'ducks' (яка групує редюсер, action creators та типи дій в одному файлі) це не обов'язково."
      },
      {
        "id": "redux-q8-aq3",
        "question": "Яка перевага використання action creators над безпосереднім створенням об'єктів дій?",
        "answer": "Action creators централізують логіку створення дій, забезпечують послідовний формат дій, дозволяють легко додавати чи змінювати поля дії в майбутньому без зміни логіки в місцях виклику, а також полегшують тестування та інтеграцію з middleware (наприклад, Redux Thunk)."
      }
    ]
  },
  {
    "id": "redux-q9",
    "topic": "Redux",
    "mainQuestion": "Чому не можна змінювати окремі елементи стану, а треба оновлювати весь об’єкт стану? Як написати код у редюсері, що додаватиме до масиву `items` у стані рядок `'new item'`?",
    "mainAnswer": "**Чому не можна змінювати окремі елементи стану (мутувати)?** \nУ Redux стан є **імутабельним**. Це означає, що ви ніколи не повинні прямо змінювати об'єкт стану або його властивості. Натомість, при кожній зміні ви повинні створювати **нову копію об'єкта стану** з необхідними оновленнями. \n\n**Причини цього:** \n1.  **Виявлення змін**: Redux (та оптимізації в React, такі як `PureComponent` або `React.memo`) порівнює об'єкти за посиланням. Якщо ви мутуєте об'єкт, посилання на нього залишається тим самим, і Redux не побачить, що стан змінився, що призведе до того, що UI не буде оновлюватися. \n2.  **Time-travel debugging**: Для можливості 'подорожувати в часі' по стану, Redux зберігає історію знімків стану. Це можливо лише якщо кожен знімок є імутабельним і не залежить від попередніх змін. \n3.  **Чистота редюсерів**: Редюсери є чистими функціями, які не мають побічних ефектів, включаючи мутацію своїх аргументів. \n4.  **Прогнозованість**: Імутабельність робить потік даних більш передбачуваним і спрощує відлагодження, запобігаючи несподіваним побічним ефектам. \n\n**Як написати код у редюсері, що додаватиме до масиву `items` у стані рядок `'new item'`?** \nПрипустимо, ваш початковий стан виглядає так: \n```javascript \nconst initialState = { \n  user: { name: 'Роман' }, \n  items: ['apple', 'banana'] \n}; \n``` \nЩоб додати `'new item'` до масиву `items` без мутації, ви повинні створити нові копії всіх об'єктів/масивів на шляху до `items`. Використовуйте оператор спред (`...`): \n\n```javascript \nfunction myReducer(state = initialState, action) { \n  switch (action.type) { \n    case 'ADD_NEW_ITEM': \n      return { \n        ...state, // Копіюємо всі властивості об'єкта state \n        items: [...state.items, 'new item'] // Створюємо новий масив items \n      }; \n    default: \n      return state; \n  } \n} \n``` \n**Пояснення:** \n-   `...state`: Створює поверхневу копію кореневого об'єкта `state`. \n-   `items: [...state.items, 'new item']`: Створює **новий масив**, який включає всі елементи старого `state.items` та новий елемент `'new item'`. Цей новий масив замінює старий `items` у новій копії стану. \n\nТаким чином, оригінальний об'єкт `state` та його масив `items` залишаються незмінними, а редюсер повертає абсолютно новий об'єкт стану з оновленими `items`.",
    "additionalQuestions": [
      {
        "id": "redux-q9-aq1",
        "question": "Які методи JavaScript допомагають працювати з імутабельними масивами?",
        "answer": "Для імутабельного оновлення масивів використовують: \n-   `[...oldArray, newItem]` (додати елемент) \n-   `oldArray.filter(item => item.id !== id)` (видалити елемент) \n-   `oldArray.map(item => item.id === id ? { ...item, updatedProp: newValue } : item)` (оновлення елемента) \n-   `oldArray.slice()` (поверхнева копія)"
      },
      {
        "id": "redux-q9-aq2",
        "question": "Які методи JavaScript допомагають працювати з імутабельними об'єктами?",
        "answer": "Для імутабельного оновлення об'єктів використовують: \n-   `{ ...oldObject, newProp: value }` (додати/змінити властивість) \n-   `Object.assign({}, oldObject, { newProp: value })` (те ж саме, але менш сучасний синтаксис) \nДля видалення властивості: `{ ...oldObject, [keyToDelete]: undefined }` або використання деструктуризації: `const { [keyToDelete], ...rest } = oldObject; return rest;`."
      },
      {
        "id": "redux-q9-aq3",
        "question": "Яка бібліотека допомагає писати 'мутуючий' код, який насправді генерує імутабельні оновлення?",
        "answer": "Бібліотека **Immer** дозволяє писати більш простий, 'мутуючий' код у редюсерах, а вона сама дбає про створення імутабельних копій. Це значно зменшує бойлерплейт і ризик помилок. Наприклад, з Immer: `return produce(state, draft => { draft.items.push('new item'); });`."
      }
    ]
  },
  {
    "id": "redux-q10",
    "topic": "Redux",
    "mainQuestion": "Що таке сховище (store)? Які в нього є методи і події?",
    "mainAnswer": "**Сховище (Store)** — це об'єкт, який є єдиним джерелом істини для всього стану вашого Redux-застосунку. Всі зміни стану проходять через сховище. Це центральний вузол Redux-архітектури. \n\nСховище створюється за допомогою функції `createStore` з Redux (або `configureStore` з Redux Toolkit) і є лише один `store` на застосунок. \n\n**Основні методи сховища:** \n1.  **`getState()`**: \n    -   **Призначення:** Повертає поточний повний об'єкт стану Redux. \n    -   **Використання:** `const currentState = store.getState();` \n2.  **`dispatch(action)`**: \n    -   **Призначення:** Єдиний спосіб змінити стан у Redux. Ви надсилаєте об'єкт дії до сховища. Коли дія надсилається, Redux передає її поточний стан та дію до редюсера, який обчислює новий стан. \n    -   **Використання:** `store.dispatch({ type: 'INCREMENT' });` \n3.  **`subscribe(listener)`**: \n    -   **Призначення:** Дозволяє підписатися на зміни стану. Функція `listener` (слухач) буде викликана щоразу, коли стан зміниться. \n    -   **Використання:** `const unsubscribe = store.subscribe(() => { console.log('Стан змінився:', store.getState()); });` \n    -   Повертає функцію `unsubscribe`, яку можна викликати для відписки: `unsubscribe();` \n\n**Події сховища (внутрішні, не прямі методи для виклику):** \nХоча Redux Store не має 'подій' у традиційному сенсі (на кшталт `EventEmitter`), метод `subscribe` по суті є механізмом підписки на внутрішню подію 'зміна стану'. Коли стан змінюється, Redux автоматично викликає всі підписані слухачі. \n\n**Важливо:** У React-Redux (бібліотека для інтеграції Redux з React) ви рідко використовуєте `store.subscribe` напряму, оскільки `react-redux` (зокрема хуки `useSelector` або функція `connect`) автоматично керує підписками для ваших компонентів.",
    "additionalQuestions": [
      {
        "id": "redux-q10-aq1",
        "question": "Як Redux Toolkit спрощує створення сховища?",
        "answer": "Redux Toolkit надає функцію `configureStore`, яка значно спрощує налаштування сховища. Вона автоматично включає Redux DevTools, додає `redux-thunk` middleware (для асинхронних дій) та об'єднує редюсери, зменшуючи бойлерплейт."
      },
      {
        "id": "redux-q10-aq2",
        "question": "Чи можна мати кілька сховищ у Redux-застосунку?",
        "answer": "Технічно можна, але це **категорично не рекомендується** і є антипатерном у Redux. Основний принцип Redux — 'єдине джерело істини' (Single Source of Truth), що означає, що весь стан застосунку повинен знаходитися в одному сховищі. Наявність кількох сховищ руйнує передбачуваність, ускладнює налагодження та управління станом."
      },
      {
        "id": "redux-q10-aq3",
        "question": "У чому перевага `dispatch` над прямою зміною стану?",
        "answer": "`dispatch` забезпечує, що всі зміни стану відбуваються через стандартизований, відстежуваний та передбачуваний механізм. Це дозволяє Redux DevTools відстежувати кожну дію, застосовувати middleware, перевіряти стан та забезпечувати його імутабельність. Пряма зміна стану обходить усі ці механізми, призводячи до непередбачуваної поведінки."
      }
    ]
  },
  {
    "id": "redux-q11",
    "topic": "Redux",
    "mainQuestion": "Які є два способи задати початковий стан у Redux? Як саме з технічного погляду працює спосіб задати початковий стан у коді редюсера?",
    "mainAnswer": "Існує два основні способи задати початковий стан у Redux: \n\n1.  **Задання початкового стану у коді редюсера (рекомендований спосіб)**: \n    -   Це найпоширеніший і рекомендований спосіб. Ви надаєте параметру `state` у функції редюсера значення за замовчуванням. \n    -   **Як працює з технічного погляду**: Коли Redux створює сховище, він виконує перше 'диспетчеризування' спеціальної дії (`@@redux/INIT` або подібної) з `state`, встановленим на `undefined`. Кожен редюсер отримує цю дію, і оскільки `state` є `undefined`, він використовує своє значення за замовчуванням (яке ви вказали), щоб повернути початковий стан для своєї ділянки. Таким чином, весь об'єкт стану збирається з початкових значень, визначених у кожному редюсері. \n    -   **Приклад:** \n        ```javascript \n        const initialState = { count: 0, message: 'Привіт' }; \n        function counterReducer(state = initialState, action) { \n          // ... логіка редюсера \n          return state; \n        } \n        ``` \n\n2.  **Передача початкового стану як другий аргумент у `createStore` (або `preloadedState` у `configureStore`):** \n    -   Ви можете передати об'єкт початкового стану безпосередньо у функцію `createStore` (або `preloadedState` у `configureStore` Redux Toolkit). \n    -   **Коли використовувати:** Це корисно для гідратації стану з локального сховища або з серверного рендерингу (коли ви хочете відновити стан, який був збережений або згенерований на сервері). \n    -   **Приклад (з `createStore`):** \n        ```javascript \n        import { createStore } from 'redux'; \n        import rootReducer from './reducers'; \n        const preloadedStateFromLocalStorage = { \n          count: 5, \n          message: 'Відновлено з LocalStorage' \n        }; \n        const store = createStore(rootReducer, preloadedStateFromLocalStorage); \n        ``` \n\n**Комбінація:** Якщо ви надаєте початковий стан через `createStore`/`preloadedState`, існуючі значення у вашому об'єкті початкового стану **перевизначать** початкові стани, визначені в редюсерах. Будь-які частини стану, які не були надані через `preloadedState`, отримають свої початкові значення з редюсерів.",
    "additionalQuestions": [
      {
        "id": "redux-q11-aq1",
        "question": "Чому важливо, щоб редюсери повертали початковий стан, коли `state` є `undefined`?",
        "answer": "Це критично важливо, тому що Redux викликає кожен редюсер при ініціалізації сховища з `state = undefined`. Якщо редюсер не обробляє цей випадок і не повертає своє початкове значення, стан залишиться `undefined`, що призведе до помилок у застосунку."
      },
      {
        "id": "redux-q11-aq2",
        "question": "У чому перевага задання початкового стану в редюсері над передачею його в `createStore`?",
        "answer": "Перевага в тому, що кожен редюсер самодостатній і чітко визначає початковий стан для своєї частини даних. Це покращує модульність та дозволяє легше комбінувати редюсери. Використання `createStore` для початкового стану зазвичай резервується для ситуацій відновлення стану, а не для його початкового визначення."
      },
      {
        "id": "redux-q11-aq3",
        "question": "Чи можна змінити початковий стан після створення сховища?",
        "answer": "Ні, початковий стан (як його визначають редюсери) не можна змінити після створення сховища. Стан змінюється лише через надсилання дій та обробку їх редюсерами, які повертають нові об'єкти стану."
      }
    ]
  },
  {
    "id": "redux-q12",
    "topic": "Redux",
    "mainQuestion": "Як об’єднати два редюсери, що опікуються різними ділянками стану, в один?",
    "mainAnswer": "У Redux використовується функція **`combineReducers`** (з бібліотеки `redux`) для об'єднання кількох незалежних редюсерів в один кореневий редюсер. Кожен з цих 'дочірніх' редюсерів відповідає за управління певною ділянкою загального стану. \n\n`combineReducers` приймає об'єкт, де ключі відповідають назвам властивостей у вашому кореневому стані, а значення — це відповідні редюсери. \n\n**Приклад:** \nПрипустимо, у вас є два окремі редюсери: \n\n1.  **`userReducer.js`**: Керує частиною стану, пов'язаною з користувачем. \n    ```javascript \n    // userReducer.js \n    const initialUserState = { name: '', email: '', isLoggedIn: false }; \n    function userReducer(state = initialUserState, action) { \n      switch (action.type) { \n        case 'LOGIN': \n          return { ...state, name: action.payload.name, isLoggedIn: true }; \n        case 'LOGOUT': \n          return { ...initialUserState }; \n        default: \n          return state; \n      } \n    } \n    export default userReducer; \n    ``` \n\n2.  **`productReducer.js`**: Керує частиною стану, пов'язаною з товарами. \n    ```javascript \n    // productReducer.js \n    const initialProductState = { list: [], loading: false }; \n    function productReducer(state = initialProductState, action) { \n      switch (action.type) { \n        case 'FETCH_PRODUCTS_REQUEST': \n          return { ...state, loading: true }; \n        case 'FETCH_PRODUCTS_SUCCESS': \n          return { ...state, loading: false, list: action.payload.products }; \n        default: \n          return state; \n      } \n    } \n    export default productReducer; \n    ``` \n\n**Об'єднання редюсерів у `rootReducer.js`:** \n```javascript \n// rootReducer.js \nimport { combineReducers } from 'redux'; \nimport userReducer from './userReducer'; \nimport productReducer from './productsReducer'; \n\nconst rootReducer = combineReducers({ \n  user: userReducer,    // `state.user` буде керуватися `userReducer` \n  products: productReducer // `state.products` буде керуватися `productReducer` \n}); \n\nexport default rootReducer; \n``` \n\n**Як це працює з технічного погляду:** \n-   Коли `rootReducer` отримує дію, `combineReducers` перебирає всі 'дочірні' редюсери, викликаючи кожен з них з відповідною частиною поточного стану та тією самою дією. \n-   Кожен дочірній редюсер повертає свій новий фрагмент стану. \n-   `combineReducers` потім збирає ці нові фрагменти в єдиний новий об'єкт кореневого стану. \n\nТаким чином, `combineReducers` дозволяє логічно розділити ваш стан та логіку його оновлення, зберігаючи при цьому єдине джерело істини.",
    "additionalQuestions": [
      {
        "id": "redux-q12-aq1",
        "question": "Яка структура стану буде після об'єднання цих редюсерів?",
        "answer": "Після об'єднання, кореневий стан буде виглядати так: \n```json \n{ \n  \"user\": { /* стан від userReducer */ }, \n  \"products\": { /* стан від productReducer */ } \n} \n``` \nтобто, ключі, які ви передали в `combineReducers`, стануть ключами верхнього рівня у вашому глобальному Redux-стані."
      },
      {
        "id": "redux-q12-aq2",
        "question": "Чи потрібно, щоб кожен редюсер у `combineReducers` мав унікальні типи дій?",
        "answer": "Ні, не обов'язково. Різні редюсери можуть реагувати на один і той самий тип дії. Наприклад, дія `'USER_LOGGED_IN'` може оновлювати `userReducer` (встановлюючи `isLoggedIn: true`) і одночасно `uiReducer` (приховуючи модальне вікно входу). Це є перевагою Redux, дозволяючи одній події впливати на кілька частин стану."
      },
      {
        "id": "redux-q12-aq3",
        "question": "Чи можна використовувати `combineReducers` для вкладених редюсерів?",
        "answer": "Так, `combineReducers` можна використовувати рекурсивно. Ви можете об'єднати групу редюсерів, а потім цей об'єднаний редюсер включити в інший `combineReducers`, щоб створити більш складну, ієрархічну структуру стану."
      }
    ]
  },
  {
    "id": "redux-q13",
    "topic": "Redux",
    "mainQuestion": "Що таке презентаційні компоненти та компоненти-обгортки?",
    "mainAnswer": "У контексті React та Redux, часто використовується архітектурний патерн, що розділяє компоненти на дві категорії: **презентаційні (чисті) компоненти** та **контейнерні (або компоненти-обгортки)**. Цей поділ вперше запропонував Ден Абрамов, творець Redux. \n\n1.  **Презентаційні компоненти (Presentational Components / Pure Components / Dumb Components)**: \n    -   **Що це:** Компоненти, які відповідають виключно за **UI (як виглядає)**. \n    -   **Залежності:** Отримують усі дані та функції зворотного виклику через `props`. \n    -   **Стан:** Зазвичай не мають власного стану (або мають мінімальний локальний UI-стан, який не впливає на інші частини застосунку). \n    -   **Дії:** Не надсилають дії Redux напряму. Вони викликають функції-колбеки, передані через props, які, у свою чергу, можуть викликати дії. \n    -   **Приклад:** Кнопки, поля вводу, картки товарів, списки. Вони часто є функціональними компонентами. \n    -   **Чому:** Легко тестуються, багаторазово використовуються, оскільки не залежать від джерела даних. \n\n2.  **Контейнерні компоненти (Container Components / Smart Components / Components-Wrappers)**: \n    -   **Що це:** Компоненти, які відповідають за **логіку та дані (як працює)**. \n    -   **Залежності:** Отримують дані з Redux Store, надсилають дії до Redux Store. \n    -   **Стан:** Зазвичай не мають власного візуального стану, але керують станом своїх презентаційних дітей. \n    -   **Дії:** Відповідають за надсилання дій Redux. \n    -   **Приклад:** Компонент, який отримує список користувачів з Redux Store і передає його презентаційному компоненту `UserList`. \n    -   **Чому:** Відокремлюють логіку від UI, що робить застосунок більш структурованим та легким для підтримки. Часто створюються за допомогою функції `connect` з `react-redux` або за допомогою хуків `useSelector` та `useDispatch`. \n\n**Сучасний підхід (з хуками):** \nПісля появи React Hooks (особливо `useSelector` та `useDispatch`), межа між презентаційними та контейнерними компонентами стала менш чіткою, оскільки функціональні компоненти можуть легко 'підключатися' до Redux Store без необхідності обгортання. Однак, базовий принцип розділення відповідальності (один компонент відповідає за UI, інший за дані) все ще залишається цінним.",
    "additionalQuestions": [
      {
        "id": "redux-q13-aq1",
        "question": "Який тип компонентів легше тестувати і чому?",
        "answer": "Презентаційні компоненти легше тестувати, оскільки вони є 'чистими' у тому сенсі, що вони повністю залежать від своїх пропсів і не мають побічних ефектів або залежностей від Redux Store. Їх можна тестувати ізольовано, передаючи різні набори пропсів і перевіряючи, як вони рендеряться."
      },
      {
        "id": "redux-q13-aq2",
        "question": "Чи може презентаційний компонент мати власний стан?",
        "answer": "Так, може. Презентаційний компонент може мати свій власний локальний UI-стан, який не впливає на інші частини застосунку (наприклад, стан відкритого/закритого модального вікна, стан введеного тексту в інпуті, якщо він не надсилається до Redux). Важливо, щоб цей стан не був даними, які вимагають глобального доступу або синхронізації з Redux."
      },
      {
        "id": "redux-q13-aq3",
        "question": "Як хуки вплинули на цей архітектурний патерн?",
        "answer": "Хуки, такі як `useSelector` та `useDispatch`, дозволяють будь-якому функціональному компоненту безпосередньо підключатися до Redux Store. Це означає, що вам більше не потрібно явно створювати окремі 'компоненти-обгортки' за допомогою `connect`. Функціональний компонент може бути одночасно 'розумним' (маючи доступ до Redux) і 'тупим' (будучи чистим у плані рендерингу від пропсів). Це робить архітектуру більш плоскою і часто зменшує бойлерплейт."
      }
    ]
  },
  {
    "id": "redux-q14",
    "topic": "Redux",
    "mainQuestion": "Які параметри приймає та що повертає функція `connect`?",
    "mainAnswer": "Функція **`connect`** з бібліотеки `react-redux` — це Higher-Order Component (HOC), який використовується для підключення React-компонентів до Redux Store. Вона 'обгортає' ваш React-компонент і надає йому доступ до даних зі стану Redux та/або дозволяє йому надсилати дії. \n\n**`connect` приймає до чотирьох аргументів, але найчастіше використовуються перші два:** \n\n1.  **`mapStateToProps(state, [ownProps])`**: \n    -   **Призначення:** Функція, яка визначає, які дані зі **стану Redux** (перший аргумент `state`) компонент потребує як `props`. \n    -   **Що повертає:** Об'єкт, ключі якого стануть пропсами для вашого компонента, а значення — даними зі стану Redux. \n    -   **`ownProps` (необов'язковий):** Другий аргумент `mapStateToProps` — це пропси, які були передані самому компоненту-обгортці. Ви можете використовувати їх для фільтрації даних зі стану Redux. \n\n2.  **`mapDispatchToProps(dispatch, [ownProps])`**: \n    -   **Призначення:** Функція або об'єкт, яка визначає, які **дії** (Action Creators) компонент може викликати (dispatch) як `props`. \n    -   **Що повертає:** \n        -   Якщо це **функція**, вона повинна повернути об'єкт, де ключі стануть пропсами для вашого компонента, а значення — функціями, які викликають `dispatch` для певних дій. \n        -   Якщо це **об'єкт**, кожен його метод буде автоматично 'обгорнутий' у `dispatch` і переданий як `prop`. \n    -   **`dispatch` (перший аргумент):** Сама функція `dispatch` зі сховища Redux. \n    -   **`ownProps` (необов'язковий):** Аналогічно `mapStateToProps`, дозволяє використовувати пропси обгортки для створення функцій dispatch. \n\n3.  **`mergeProps(stateProps, dispatchProps, ownProps)` (необов'язковий)**: \n    -   Функція, яка дозволяє об'єднати результати `mapStateToProps`, `mapDispatchToProps` та `ownProps` в єдиний об'єкт пропсів, який буде переданий вашому компоненту. Використовується рідко. \n\n4.  **`options` (необов'язковий)**: \n    -   Об'єкт конфігурації для тонкого налаштування поведінки `connect` (наприклад, `pure: false` для відключення оптимізації). \n\n**Що повертає функція `connect`?** \n`connect` — це функція, яка повертає іншу функцію. Ця друга функція вже приймає ваш React-компонент як аргумент і повертає **новий, 'підключений' компонент-обгортку (Higher-Order Component)**. \n\n**Приклад використання:** \n```jsx \nimport { connect } from 'react-redux'; \nimport { addTodo, removeTodo } from './actions'; \n\nfunction MyComponent({ todos, addTodo, userProp }) { \n  return ( \n    <div> \n      <h1>{userProp}</h1> \n      {todos.map(todo => <p key={todo.id}>{todo.text}</p>)} \n      <button onClick={() => addTodo(Date.now(), 'Нове завдання')}>Додати</button> \n    </div> \n  ); \n} \n\nconst mapStateToProps = (state, ownProps) => ({ \n  todos: state.todos, \n  userProp: ownProps.someValueFromParent // Доступ до props обгортки \n}); \n\nconst mapDispatchToProps = { \n  // Це об'єкт action creators, react-redux автоматично оберне їх у dispatch \n  addTodo, \n  removeTodo \n}; \n\n// Підключаємо компонент до Redux Store \nexport default connect(mapStateToProps, mapDispatchToProps)(MyComponent); \n``` \n**Важливо:** У сучасних React-Redux застосунках з функціональними компонентами, замість `connect` частіше використовуються хуки `useSelector` та `useDispatch`, оскільки вони простіші та не вимагають HOC.",
    "additionalQuestions": [
      {
        "id": "redux-q14-aq1",
        "question": "Яка головна відмінність між `mapStateToProps` та `mapDispatchToProps`?",
        "answer": "`mapStateToProps` відповідає за **читання даних** зі стану Redux та передачу їх як пропсів компоненту. `mapDispatchToProps` відповідає за **модифікацію стану** Redux шляхом надсилання дій, надаючи компоненту функції-колбеки як пропси, які викликають `dispatch`."
      },
      {
        "id": "redux-q14-aq2",
        "question": "Чи обов'язково використовувати обидва `mapStateToProps` та `mapDispatchToProps`?",
        "answer": "Ні. Ви можете передати `null` або `undefined` замість будь-якої з цих функцій, якщо ваш компонент потребує лише читання стану, або лише надсилання дій. Наприклад, `connect(mapStateToProps, null)(MyComponent)` дозволить лише читати стан, а `connect(null, mapDispatchToProps)(MyComponent)` дозволить лише надсилати дії."
      },
      {
        "id": "redux-q14-aq3",
        "question": "Чому `connect` є HOC (Higher-Order Component)?",
        "answer": "`connect` є HOC, тому що він приймає React-компонент як аргумент і повертає новий React-компонент. Це дозволяє додати додаткову логіку (управління підпискою на Redux Store, передача пропсів зі стану, обгортання action creators) до вихідного компонента без його модифікації."
      }
    ]
  },
  {
    "id": "redux-q15",
    "topic": "Redux",
    "mainQuestion": "Яке призначення функцій `mapStateToProps` та `mapDispatchToProps` і в чому полягає різниця між ними?",
    "mainAnswer": "Функції **`mapStateToProps`** та **`mapDispatchToProps`** є ключовими для підключення React-компонентів до Redux Store за допомогою функції `connect` з бібліотеки `react-redux`. Вони слугують для різних, але взаємодоповнюючих цілей. \n\n1.  **`mapStateToProps(state, [ownProps])`**: \n    -   **Призначення (Mapping State to Props):** Ця функція відповідає за те, щоб взяти потрібні частини зі **стану Redux** (перший аргумент `state`) і 'змапувати' їх як **пропси** для вашого React-компонента. Вона визначає, які дані з глобального стану Redux компонент потребує для рендерингу. \n    -   **Що повертає:** Об'єкт, де ключі стануть назвами пропсів, а значення — даними, витягнутими зі стану Redux. \n    -   **Приклад:** Якщо вам потрібен лічильник зі стану `state.counter.value`, ви повернете `{ count: state.counter.value }`. Компонент отримає `props.count`. \n\n2.  **`mapDispatchToProps(dispatch, [ownProps])`**: \n    -   **Призначення (Mapping Dispatch to Props):** Ця функція (або об'єкт) відповідає за те, щоб 'змапувати' **дії** (Action Creators) та функцію `dispatch` як **пропси** для вашого React-компонента. Вона дозволяє компоненту викликати зміни стану в Redux Store. \n    -   **Що повертає:** Об'єкт, де ключі стануть назвами пропсів (зазвичай, це функції-колбеки), а значення — функціями, які при виклику надсилають дії до Redux Store. \n    -   **Приклад (як функція):** Якщо вам потрібна функція для збільшення лічильника, ви повернете `{ increment: () => dispatch({ type: 'INCREMENT' }) }`. Компонент отримає `props.increment()`. \n    -   **Приклад (як об'єкт):** `mapDispatchToProps` також може бути об'єктом з action creators, і `react-redux` автоматично оберне їх у `dispatch`. `{ increment, decrement }`. \n\n--- \n\n**Основна різниця між `mapStateToProps` та `mapDispatchToProps`:** \n\n-   **`mapStateToProps`**: Фокусується на **отриманні даних** (`state`) з Redux Store. Вона лише **читає** стан. \n-   **`mapDispatchToProps`**: Фокусується на **модифікації даних** (`dispatch`) у Redux Store. Вона дозволяє компоненту **відправляти дії** для зміни стану. \n\nПростими словами: `mapStateToProps` відповідає на питання \"*які дані мені потрібні?*\", а `mapDispatchToProps` — \"*що я можу зробити, щоб змінити дані?*\"."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q15-aq1",
        "question": "Чому `mapStateToProps` та `mapDispatchToProps` повертають об'єкти з пропсами, а не мутують стан компонента напряму?",
        "answer": "Вони повертають об'єкти з пропсами, щоб дотримуватися реактивного підходу React: компоненти рендеряться на основі пропсів та стану. Цей механізм дозволяє `react-redux` ефективно оновлювати компоненти лише тоді, коли необхідні дані зі стану Redux дійсно змінилися, оптимізуючи рендеринг за допомогою поверхневого порівняння пропсів."
      },
      {
        "id": "redux-q15-aq2",
        "question": "Коли `mapStateToProps` викликається?",
        "answer": "`mapStateToProps` викликається щоразу, коли Redux Store оновлюється. Якщо об'єкт, який вона повертає, відрізняється від попереднього об'єкта пропсів (за поверхневим порівнянням), `react-redux` ініціює повторний рендеринг підключеного компонента."
      },
      {
        "id": "redux-q15-aq3",
        "question": "Коли `mapDispatchToProps` викликається?",
        "answer": "Якщо `mapDispatchToProps` є функцією, вона викликається лише один раз при створенні підключеного компонента (або при зміні `ownProps` та якщо вона залежить від них). Якщо це об'єкт, він також обробляється один раз при створенні компонента. Функції, які вона повертає, викликаються пізніше, коли компонент відправляє дії."
      }
    ]
  },
  {
    "id": "redux-q16",
    "topic": "Redux",
    "mainQuestion": "Як передати параметр із props, що передали компоненту-обгортці, презентаційному компоненту, який він обгортає?",
    "mainAnswer": "При використанні патерну контейнерного/презентаційного компонента з `connect` з `react-redux`, пропси, передані компоненту-обгортці (контейнерному компоненту), автоматично передаються і презентаційному компоненту, який він обгортає. \n\nРозглянемо приклад: \n\n```jsx \n// 1. Презентаційний компонент (Dumb Component) \n// Він просто отримує пропси і рендерить їх \nfunction UserDetails({ userId, userName, userEmail, onEditUser }) { \n  return ( \n    <div> \n      <h2>Деталі користувача {userId}</h2> \n      <p>Ім'я: {userName}</p> \n      <p>Email: {userEmail}</p> \n      <button onClick={() => onEditUser(userId)}>Редагувати</button> \n    </div> \n  ); \n} \n\n// 2. Контейнерний компонент (Smart Component / Wrapper) \n// Це файл, де ви підключаєте UserDetails до Redux \nimport { connect } from 'react-redux'; \nimport { fetchUserDetails, updateUser } from './actions'; \n\n// mapStateToProps отримує `ownProps` як другий аргумент \nconst mapStateToProps = (state, ownProps) => { \n  // ownProps тут це пропси, передані <ConnectedUserDetails userId={123} /> \n  const userId = ownProps.userId; \n  const user = state.users[userId]; // Припустимо, у вас є нормалізований стан users \n  return { \n    userId: userId, // Передаємо userId назад у UserDetails \n    userName: user ? user.name : 'N/A', \n    userEmail: user ? user.email : 'N/A' \n  }; \n}; \n\n// mapDispatchToProps також отримує `ownProps` як другий аргумент, \n// але часто це не потрібно, якщо action creator не залежить від них \nconst mapDispatchToProps = { \n  // Припустимо, що updateUser action creator приймає ID користувача \n  onEditUser: (userId) => updateUser(userId) // або просто updateUser, якщо логіка в action creator \n}; \n\n// Створюємо підключений компонент \nconst ConnectedUserDetails = connect(mapStateToProps, mapDispatchToProps)(UserDetails); \n\nexport default ConnectedUserDetails; \n\n// 3. Використання ConnectedUserDetails у батьківському компоненті \n// Тут ми передаємо параметр 'userId' компоненту-обгортці \nfunction App() { \n  return ( \n    <div> \n      <ConnectedUserDetails userId={123} /> \n      <ConnectedUserDetails userId={456} /> \n    </div> \n  ); \n} \n``` \n\n**Пояснення:** \n-   Коли ви використовуєте `connect(mapStateToProps, mapDispatchToProps)(MyComponent)`, функція `connect` створює новий компонент-обгортку. \n-   Будь-які пропси, які ви передаєте цьому **компоненту-обгортці** (наприклад, `userId={123}` у `<ConnectedUserDetails userId={123} />`), стають доступними як другий аргумент (`ownProps`) у функціях `mapStateToProps` та `mapDispatchToProps`. \n-   Ви можете використовувати ці `ownProps` всередині `mapStateToProps` для вибору специфічних даних зі стану Redux (як у прикладі з `state.users[userId]`). \n-   Важливо, що всі пропси, які були передані обгортці (`ownProps`), а також ті, що були змаповані з Redux за допомогою `mapStateToProps` та `mapDispatchToProps`, об'єднуються і передаються як єдиний об'єкт пропсів безпосередньо до вашого **презентаційного компонента** (`UserDetails` у цьому прикладі). Тобто, `UserDetails` отримує `userId`, `userName`, `userEmail` та `onEditUser` як свої пропси.",
    "additionalQuestions": [
      {
        "id": "redux-q16-aq1",
        "question": "Як це працює з хуками `useSelector` та `useDispatch`?",
        "answer": "З хуками це ще простіше. Ви просто передаєте пропс напряму функціональному компоненту. Наприклад: \n```jsx \nfunction UserDetails({ userId }) { \n  const user = useSelector(state => state.users[userId]); // userId використовується безпосередньо в useSelector \n  const dispatch = useDispatch(); \n  const handleEdit = () => { dispatch(updateUser(userId)); }; \n  return (...); \n} \n// Використання: <UserDetails userId={123} /> \n``` \nТут `userId` є просто пропсом компонента `UserDetails`, і його можна використовувати безпосередньо в хуках."
      },
      {
        "id": "redux-q16-aq2",
        "question": "Чи є різниця в продуктивності при використанні `ownProps` в `mapStateToProps`?",
        "answer": "Використання `ownProps` в `mapStateToProps` саме по собі не є проблемою продуктивності. Проте, якщо `mapStateToProps` виконує дорогі обчислення на основі `ownProps`, і ці `ownProps` часто змінюються, це може призвести до надмірних повторних обчислень. У таких випадках можна використовувати `reselect` для мемоізації селекторів."
      },
      {
        "id": "redux-q16-aq3",
        "question": "Чи можу я змінювати `ownProps` всередині `mapStateToProps` або `mapDispatchToProps`?",
        "answer": "Ні, ви не повинні змінювати `ownProps` всередині цих функцій, оскільки вони є частиною вхідних даних. Ці функції мають бути чистими: вони приймають вхідні дані і повертають новий об'єкт пропсів. Зміна `ownProps` може призвести до непередбачуваної поведінки."
      }
    ]
  },
  {
    "id": "redux-q17",
    "topic": "Redux",
    "mainQuestion": "Як користуватися провайдером з `react-redux`? Чому він потрібен?",
    "mainAnswer": "**Провайдер (Provider)** — це компонент з бібліотеки `react-redux`, який є критично важливим для інтеграції Redux Store з вашим React-застосунком. \n\n**Як користуватися:** \nВи обгортаєте весь ваш React-застосунок (або ту частину, яка має доступ до Redux Store) у компонент `<Provider>`, передаючи йому ваш Redux Store як пропс `store`. \n\n```jsx \n// index.js або App.js \nimport React from 'react'; \nimport ReactDOM from 'react-dom/client'; \nimport { Provider } from 'react-redux'; \nimport { createStore } from 'redux'; \nimport rootReducer from './reducers'; \nimport App from './App'; \n\n// 1. Створюємо Redux Store \nconst store = createStore(rootReducer); \n\n// 2. Обгортаємо кореневий компонент застосунку у Provider \nconst root = ReactDOM.createRoot(document.getElementById('root')); \nroot.render( \n  <React.StrictMode> \n    <Provider store={store}> \n      <App /> \n    </Provider> \n  </React.StrictMode> \n); \n``` \n\n**Чому він потрібен?** \n`Provider` використовує **React Context API** \"під капотом\", щоб зробити Redux Store доступним для всіх підключених компонентів у дереві компонентів, не передаючи його явно як пропс через кожен рівень (уникаючи 'prop drilling'). \n\n**Основні причини його необхідності:** \n1.  **Доступ до Store**: `Provider` робить Redux Store доступним для всіх дочірніх компонентів, які підключаються до Redux за допомогою `connect` або хуків `useSelector`/`useDispatch`. Без нього ці компоненти не зможуть знайти Store і не зможуть отримувати дані або надсилати дії. \n2.  **Управління підписками**: `Provider` керує життєвим циклом підписок на Redux Store. Він гарантує, що підключені компоненти коректно підписуються на зміни стану і відписуються, коли вони розмонтовуються, запобігаючи витокам пам'яті. \n3.  **Оптимізація продуктивності**: Завдяки Context API, `Provider` дозволяє `react-redux` ефективно оптимізувати оновлення. Він гарантує, що лише ті компоненти, які дійсно потребують оновлення через зміну даних зі стану, будуть перерендерені. \n\nПо суті, `Provider` є мостом між Redux Store та вашим React-компонентами, надаючи їм необхідні механізми для взаємодії зі станом централізованого сховища.",
    "additionalQuestions": [
      {
        "id": "redux-q17-aq1",
        "question": "Що таке 'prop drilling' і як `Provider` його уникає?",
        "answer": "'Prop drilling' (або 'прокидання пропсів') — це ситуація, коли дані або колбеки передаються через багато рівнів компонентів у дереві, хоча проміжні компоненти самі ці пропси не використовують. `Provider` уникає цього, роблячи Store доступним через React Context API, дозволяючи будь-якому вкладеному компоненту 'підключитися' до Store без отримання пропсів від батьківських компонентів."
      },
      {
        "id": "redux-q17-aq2",
        "question": "Чи можна мати кілька провайдерів у застосунку?",
        "answer": "Так, технічно можливо, але це дуже рідко потрібно і зазвичай є ознакою проблем з архітектурою. Кожен `Provider` буде надавати свій власний Redux Store дочірньому дереву. Це може бути використано, наприклад, для мікро-фронтендів або в дуже специфічних ситуаціях, але для типового застосунку завжди рекомендується один `Provider` з одним Redux Store."
      },
      {
        "id": "redux-q17-aq3",
        "question": "Чи можна використовувати `Provider` без `connect` або хуків Redux?",
        "answer": "Ви можете використовувати `Provider` з `store` пропсом, але без `connect`, `useSelector` або `useDispatch` ваші компоненти не зможуть взаємодіяти з цим `store`. `Provider` сам по собі лише робить Store доступним через контекст; компоненти все ще потребують механізму (як `connect` або хуки), щоб отримати доступ до цього контексту і взаємодіяти з Store."
      }
    ]
  },
  {
    "id": "redux-q18",
    "topic": "Redux",
    "mainQuestion": "Де б ти викликав асинхроний запит до сервера через Redux?",
    "mainAnswer": "У Redux, асинхронні запити до сервера (або будь-які інші побічні ефекти) зазвичай не викликаються безпосередньо у редюсерах або компонентах (якщо це не дуже простий, локальний запит). Для управління асинхронністю в Redux використовуються **Middleware (проміжне програмне забезпечення)**. \n\nНайпоширеніші місця для виклику асинхронних запитів: \n\n1.  **Redux Thunk (за допомогою `redux-thunk` middleware)**: \n    -   **Що це:** Дозволяє вам писати action creators, які повертають не об'єкти дій, а **функції**. Ці функції отримують `dispatch` та `getState` як аргументи. \n    -   **Де викликати запит:** Всередині цих функцій (т. зв. 'thunks'). Ви відправляєте одну дію на початок запиту, виконуєте асинхронну логіку (наприклад, `fetch` або `axios`), а потім відправляєте іншу дію залежно від результату (успіх чи помилка). \n    -   **Приклад:** \n        ```javascript \n        // actions.js \n        export const fetchPostsRequest = () => ({ type: 'FETCH_POSTS_REQUEST' }); \n        export const fetchPostsSuccess = (posts) => ({ type: 'FETCH_POSTS_SUCCESS', payload: posts }); \n        export const fetchPostsFailure = (error) => ({ type: 'FETCH_POSTS_FAILURE', payload: error }); \n\n        export const fetchPosts = () => { \n          return async (dispatch, getState) => { \n            dispatch(fetchPostsRequest()); // Відправляємо дію про початок запиту \n            try { \n              const response = await fetch('/api/posts'); \n              const data = await response.json(); \n              dispatch(fetchPostsSuccess(data)); // Відправляємо дію про успіх \n            } catch (error) { \n              dispatch(fetchPostsFailure(error.message)); // Відправляємо дію про помилку \n            } \n          }; \n        }; \n        ``` \n        Компонент просто викликає `dispatch(fetchPosts())`. \n\n2.  **Redux Saga (за допомогою `redux-saga` middleware)**: \n    -   **Що це:** Більш потужна і складна бібліотека для управління побічними ефектами, яка використовує ES6 Generators для більш декларативного та контрольованого управління асинхронними потоками. \n    -   **Де викликати запит:** Запити викликаються всередині 'саг' (генераторних функцій), які слухають певні дії, виконують асинхронні операції та надсилають нові дії. \n    -   **Коли використовувати:** Для складних асинхронних потоків, які включають скасування, дебаунсинг, троттлінг, конкурентні запити тощо. \n\n3.  **Redux Observable (за допомогою `redux-observable` middleware)**: \n    -   **Що це:** Використовує RxJS Observables для управління побічними ефектами. \n    -   **Де викликати запит:** Всередині 'епіків' (epic) — функцій, які приймають потік дій і повертають потік дій. \n\n4.  **Redux Toolkit `createAsyncThunk`**: \n    -   **Що це:** Вбудована функція в Redux Toolkit, яка значно спрощує створення асинхронних 'thunks', автоматично генеруючи дії `pending`, `fulfilled` та `rejected`. \n    -   **Приклад:** \n        ```javascript \n        // features/posts/postsSlice.js (з Redux Toolkit) \n        import { createAsyncThunk } from '@reduxjs/toolkit'; \n\n        export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => { \n          const response = await fetch('/api/posts'); \n          const data = await response.json(); \n          return data; \n        }); \n        ``` \n        Це генерує `fetchPosts.pending`, `fetchPosts.fulfilled` та `fetchPosts.rejected` дії, які можна обробляти в редюсері. \n\n**Ніколи не викликайте асинхронні запити безпосередньо у редюсерах**, оскільки вони повинні бути чистими функціями, без побічних ефектів.",
    "additionalQuestions": [
      {
        "id": "redux-q18-aq1",
        "question": "Чому не можна робити асинхронні запити у редюсерах?",
        "answer": "Редюсери повинні бути чистими функціями, що означає відсутність побічних ефектів та детермінованість. Асинхронні операції (як HTTP-запити) є побічними ефектами: вони не детерміновані (результат може змінюватися) і можуть викликати затримки. Їх виконання в редюсері порушить передбачуваність стану, унеможливить 'time-travel debugging' та призведе до невідповідності стану."
      },
      {
        "id": "redux-q18-aq2",
        "question": "У чому різниця між Redux Thunk та Redux Saga?",
        "answer": "`Redux Thunk` є простішим middleware, який дозволяє відправляти функції замість об'єктів дій. Він підходить для більшості простих асинхронних операцій. \n`Redux Saga` є більш потужним і складним, використовує Generators (і спеціальні 'effects') для управління асинхронними потоками. Він краще підходить для складних сценаріїв, де потрібні такі можливості, як скасування запитів, обробка 'race conditions', троттлінг, дебаунсинг тощо."
      },
      {
        "id": "redux-q18-aq3",
        "question": "Як Redux Toolkit допомагає з асинхронними запитами?",
        "answer": "Redux Toolkit значно спрощує асинхронні запити за допомогою функції `createAsyncThunk`. Вона дозволяє легко створювати thunks, які автоматично відправляють три типи дій (`pending`, `fulfilled`, `rejected`) для обробки різних стадій асинхронної операції. Це зменшує бойлерплейт та стандартизує підхід до асинхронності в Redux."
      }
    ]
  },
  {
    "id": "redux-q19",
    "topic": "Redux",
    "mainQuestion": "Що таке middlewares в Redux? Які middleware ти використовував на проектах?",
    "mainAnswer": "**Middleware (Проміжне програмне забезпечення)** у Redux — це спеціальні функції, які надають третю сторону розширення для `dispatch` функції сховища. Вони розташовуються між відправкою дії (dispatching an action) та її досягненням редюсера. \n\nПо суті, middleware перехоплює дії, які надсилаються, і може робити з ними що завгодно: \n-   Виконувати асинхронні операції (наприклад, мережеві запити). \n-   Логувати дії та стан. \n-   Перетворювати дії. \n-   Виконувати умовну логіку. \n-   Зупиняти або модифікувати дію перед її надсиланням до редюсера. \n\nВони дозволяють додавати функціональність (побічні ефекти) до Redux Store, не порушуючи принципів чистих редюсерів. \n\n**Як працює Middleware:** \n`dispatch` є єдиним способом відправки дій у Redux. Без middleware, `dispatch` просто надсилає дію до редюсера. З middleware, `dispatch` спочатку надсилає дію через ланцюжок middleware. Кожне middleware може обробити дію, а потім передати її наступному middleware в ланцюжку, або зупинити ланцюжок. \n\n**Приклади `middlewares`, які я використовував на проектах:** \n\n1.  **`redux-thunk`**: \n    -   **Призначення:** Дозволяє писати action creators, які повертають функції (thunks) замість об'єктів дій. Це дозволяє виконувати асинхронні операції (наприклад, мережеві запити) і відправляти кілька дій (наприклад, `REQUEST`, `SUCCESS`, `FAILURE`) протягом одного асинхронного потоку. \n    -   **Використання:** Найпоширеніший вибір для простих асинхронних операцій завдяки своїй простоті. \n\n2.  **`redux-saga`**: \n    -   **Призначення:** Більш потужна і складна бібліотека для управління побічними ефектами, яка використовує ES6 Generators. Дозволяє писати 'саги' для декларативного управління асинхронними потоками, обробки 'race conditions', скасування запитів тощо. \n    -   **Використання:** Для великих проектів зі складною асинхронною логікою, яка вимагає більшого контролю та тестування. \n\n3.  **`redux-logger`**: \n    -   **Призначення:** Логує всі дії та зміни стану у консолі розробника. Дуже корисний для налагодження. \n    -   **Використання:** Виключно в режимі розробки, щоб отримати візуальне представлення потоку даних. \n\n4.  **`redux-persist`**: \n    -   **Призначення:** Дозволяє зберігати стан Redux у локальному сховищі (localStorage, AsyncStorage тощо) і 'гідратувати' його при перезавантаженні застосунку. \n    -   **Використання:** Для збереження стану користувача, кошика покупок, налаштувань тощо, щоб вони були доступні після оновлення сторінки."
    ,
    "additionalQuestions": [
      {
        "id": "redux-q19-aq1",
        "question": "Як підключити middleware до Redux Store?",
        "answer": "Middleware підключаються до Redux Store при його створенні за допомогою функції `applyMiddleware` з Redux. \n```javascript \nimport { createStore, applyMiddleware } from 'redux'; \nimport thunk from 'redux-thunk'; \nimport logger from 'redux-logger'; \nimport rootReducer from './reducers'; \n\nconst store = createStore( \n  rootReducer, \n  applyMiddleware(thunk, logger) \n); \n``` \nЯкщо ви використовуєте Redux Toolkit, то `configureStore` автоматично включає `redux-thunk` та `redux-dev-tools` за замовчуванням."
      },
      {
        "id": "redux-q19-aq2",
        "question": "Яка послідовність виконання middleware?",
        "answer": "Middleware виконуються в тому порядку, в якому вони передаються в `applyMiddleware`. Якщо ви передаєте `applyMiddleware(thunk, logger)`, спочатку буде виконаний `thunk`, потім `logger`, а вже потім дія дійде до редюсера. Порядок може бути важливим, наприклад, `redux-logger` краще розміщувати останнім, щоб він логував дії після їх обробки іншими middleware."
      },
      {
        "id": "redux-q19-aq3",
        "question": "Чи можна написати власне middleware?",
        "answer": "Так, Redux надає API для написання власних middleware. Це дозволяє розробникам додавати кастомну логіку до потоку Redux, що є потужним інструментом для розширення функціональності Redux Store відповідно до потреб застосунку."
      }
    ]
  },
  {
    "id": "redux-q20",
    "topic": "Redux",
    "mainQuestion": "Що таке thunk? Як його писати і підключати?",
    "mainAnswer": "**Thunk (функція-санкція)** в контексті Redux — це функція, яка повертається `action creator` замість звичайного об'єкта дії. Ця функція не є 'чистою' і може містити побічні ефекти (наприклад, асинхронні запити, логіка, яка залежить від поточного стану). \n\n**Призначення Thunk:** \nЗвичайні Redux редюсери є синхронними та чистими функціями, вони не можуть виконувати побічні ефекти. Thunks дозволяють обробляти асинхронну логіку (як-от мережеві запити, затримки за допомогою `setTimeout`) та інші побічні ефекти поза редюсерами, перш ніж чистий об'єкт дії буде надісланий до редюсера. \n\n**Як він працює:** \n1.  `action creator` повертає функцію (thunk) замість об'єкта дії. \n2.  Ця функція `thunk` отримує два аргументи: `dispatch` (функція для надсилання інших дій) та `getState` (функція для отримання поточного стану Redux). \n3.  Всередині `thunk` ви можете виконувати асинхронні операції, а потім, залежно від результату, `dispatch` інші дії, які вже є чистими об'єктами і будуть оброблені редюсерами. \n\n**Як писати thunk:** \n```javascript \n// actionTypes.js \nexport const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST'; \nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS'; \nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE'; \n\n// actions.js \nimport { FETCH_DATA_REQUEST, FETCH_DATA_SUCCESS, FETCH_DATA_FAILURE } from './actionTypes'; \n\n// Action Creators, що повертають об'єкти дій \nexport const fetchDataRequest = () => ({ type: FETCH_DATA_REQUEST }); \nexport const fetchDataSuccess = (data) => ({ type: FETCH_DATA_SUCCESS, payload: data }); \nexport const fetchDataFailure = (error) => ({ type: FETCH_DATA_FAILURE, payload: error }); \n\n// Thunk - Action Creator, що повертає функцію \nexport const fetchSomeData = () => { \n  return async (dispatch, getState) => { \n    dispatch(fetchDataRequest()); // 1. Відправляємо дію про початок запиту \n    try { \n      // 2. Виконуємо асинхронну операцію (наприклад, мережевий запит) \n      const response = await fetch('[https://api.example.com/data](https://api.example.com/data)'); \n      const data = await response.json(); \n      dispatch(fetchDataSuccess(data)); // 3. Відправляємо дію про успіх з даними \n    } catch (error) { \n      dispatch(fetchDataFailure(error.message)); // 3. Відправляємо дію про помилку \n    } \n    // Можна також отримати стан: \n    // const currentUserId = getState().user.id; \n  }; \n}; \n``` \n\n**Як підключати `redux-thunk` middleware:** \n`redux-thunk` є окремою бібліотекою, яку потрібно встановити (`npm install redux-thunk` або `yarn add redux-thunk`) та застосувати до вашого Redux Store. \n\n```javascript \n// store.js \nimport { createStore, applyMiddleware } from 'redux'; \nimport { thunk } from 'redux-thunk'; // Імпортуємо thunk \nimport rootReducer from './reducers'; \n\nconst store = createStore( \n  rootReducer, \n  applyMiddleware(thunk) // Застосовуємо thunk як middleware \n); \n\nexport default store; \n``` \n\n**З Redux Toolkit:** \nЯкщо ви використовуєте Redux Toolkit, `redux-thunk` вже включений за замовчуванням при використанні `configureStore`, і ви можете писати thunks за допомогою `createAsyncThunk`, який значно спрощує цей процес.",
    "additionalQuestions": [
      {
        "id": "redux-q20-aq1",
        "question": "Які переваги `redux-thunk`?",
        "answer": "`redux-thunk` є простим, легким для вивчення та розуміння. Він не додає багато бойлерплейту і є достатнім для більшості асинхронних операцій у застосунку. Його легко інтегрувати та тестувати."
      },
      {
        "id": "redux-q20-aq2",
        "question": "Коли варто розглянути альтернативи `redux-thunk` (наприклад, Redux Saga)?",
        "answer": "Варто розглянути альтернативи, якщо ваш застосунок має дуже складні асинхронні потоки, які вимагають: \n-   Скасування запитів. \n-   Обробку 'race conditions' (коли кілька запитів конкурують). \n-   Троттлінг або дебаунсинг дій. \n-   Паттерни, такі як 'fork/join' асинхронних операцій. \n-   Більш декларативний спосіб опису побічних ефектів."
      },
      {
        "id": "redux-q20-aq3",
        "question": "Чи може thunk відправити інший thunk?",
        "answer": "Так, thunk може відправити (dispatch) інший thunk. Це дозволяє створювати ланцюжки асинхронних операцій або організовувати більш складну логіку, де одна асинхронна дія запускає іншу."
      }
    ]
  }
]