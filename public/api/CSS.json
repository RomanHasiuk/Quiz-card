[
  {
    "id": "css-q1",
    "topic": "CSS",
    "mainQuestion": "Як додати CSS для веб-сторінки?",
    "mainAnswer": "Існує три основні способи: 1. Зовнішні таблиці стилів (<link> в <head>). 2. Внутрішні стилі (<style> в <head>). 3. Вбудовані стилі (атрибут `style` в елементі).",
    "additionalQuestions": [
      {
        "id": "css-q1-aq1",
        "question": "Який спосіб є кращим і чому?",
        "answer": "Зовнішні таблиці стилів є кращими, оскільки вони дозволяють кешувати CSS, спрощують підтримку коду та відокремлюють структуру (HTML) від стилів (CSS)."
      },
      {
        "id": "css-q1-aq2",
        "question": "Коли доцільно використовувати вбудовані стилі?",
        "answer": "Вбудовані стилі (`style=\"...\"`) рідко використовуються і, як правило, лише для невеликих, унікальних змін або в деяких JavaScript-фреймворках/бібліотеках."
      },
      {
        "id": "css-q1-aq3",
        "question": "Що таке пріоритет стилів і як він впливає на відображення?",
        "answer": "Пріоритет (специфічність) визначає, яке правило CSS буде застосовано, якщо для одного елемента існує кілька конфліктуючих правил. Вбудовані стилі мають найвищий пріоритет, потім ID, потім класи/атрибути, потім теги."
      }
    ]
  },
  {
    "id": "css-q2",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між скиданням (resetting) та нормалізацією (normalizing) CSS? Що ви оберете і чому?",
    "mainAnswer": "Скидання CSS (resetting) повністю видаляє всі вбудовані стилі браузера, надаючи чисту основу. Нормалізація CSS (normalizing) корегує стилі браузерів, щоб вони відображалися послідовно, але залишає корисні за замовчуванням значення. Я б обрав нормалізацію, оскільки вона зберігає корисні типові стилі та вимагає менше перевизначень.",
    "additionalQuestions": [
      {
        "id": "css-q2-aq1",
        "question": "Наведіть приклад бібліотеки для нормалізації CSS.",
        "answer": "Популярним прикладом є Normalize.css."
      },
      {
        "id": "css-q2-aq2",
        "question": "Які потенційні проблеми можуть виникнути при повному скиданні CSS?",
        "answer": "При повному скиданні необхідно буде вручну стилізувати кожен елемент, навіть базові, що може збільшити обсяг коду та час розробки."
      },
      {
        "id": "css-q2-aq3",
        "question": "Яка головна мета використання скидання/нормалізації CSS?",
        "answer": "Основна мета — забезпечити послідовне відображення веб-сторінки в різних браузерах, усуваючи відмінності у їхніх вбудованих стилях."
      }
    ]
  },
  {
    "id": "css-q3",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між відступами (margins) та внутрішніми відступами (paddings)?",
    "mainAnswer": "`padding` (внутрішній відступ) — це простір між вмістом елемента та його рамкою (border). `margin` (зовнішній відступ) — це простір навколо рамки елемента, який відокремлює його від інших елементів.",
    "additionalQuestions": [
      {
        "id": "css-q3-aq1",
        "question": "Як `padding` впливає на розмір елемента?",
        "answer": "За замовчуванням (при `box-sizing: content-box`), `padding` *збільшує* загальний розмір елемента (ширину і висоту)."
      },
      {
        "id": "css-q3-aq2",
        "question": "Що таке 'margin collapse' і коли він відбувається?",
        "answer": "'Margin collapse' (схлопування зовнішніх відступів) відбувається, коли вертикальні зовнішні відступи сусідніх блокових елементів об'єднуються в один, рівний більшому з них."
      },
      {
        "id": "css-q3-aq3",
        "question": "Чи входять `margin` та `padding` у box model?",
        "answer": "Так, `margin`, `border`, `padding` та `content` є основними компонентами CSS Box Model."
      }
    ]
  },
  {
    "id": "css-q4",
    "topic": "CSS",
    "mainQuestion": "Як видалити підкреслення посилання?",
    "mainAnswer": "Щоб видалити підкреслення посилання, використовуйте CSS властивість `text-decoration` зі значенням `none`: `a { text-decoration: none; }`.",
    "additionalQuestions": [
      {
        "id": "css-q4-aq1",
        "question": "Чи варто завжди видаляти підкреслення посилань?",
        "answer": "Ні, не завжди. Підкреслення є важливим візуальним індикатором для користувачів, що текст є посиланням. Видалення може погіршити доступність, особливо для користувачів з порушеннями зору."
      },
      {
        "id": "css-q4-aq2",
        "question": "Як змінити колір посилання в CSS?",
        "answer": "Використовуйте властивість `color`, наприклад: `a { color: blue; }`."
      },
      {
        "id": "css-q4-aq3",
        "question": "Як додати ефект підкреслення при наведенні курсору?",
        "answer": "Можна використовувати псевдоклас `:hover`: `a:hover { text-decoration: underline; }`."
      }
    ]
  },
  {
    "id": "css-q5",
    "topic": "CSS",
    "mainQuestion": "Що таке медіа-запити (media queries)? Поясніть синтаксис.",
    "mainAnswer": "Медіа-запити дозволяють застосовувати різні стилі CSS залежно від характеристик пристрою, таких як ширина екрану, висота, орієнтація або тип носія. Синтаксис: `@media screen and (min-width: 768px) { /* CSS-правила */ }`.",
    "additionalQuestions": [
      {
        "id": "css-q5-aq1",
        "question": "Для чого в основному використовуються медіа-запити?",
        "answer": "Вони є основою для реалізації адаптивного (responsive) веб-дизайну, дозволяючи сайту підлаштовуватися під різні розміри екранів (десктопи, планшети, мобільні телефони)."
      },
      {
        "id": "css-q5-aq2",
        "question": "Які типові характеристики пристроїв можна перевіряти за допомогою медіа-запитів?",
        "answer": "Найчастіше перевіряються `width` (ширина в'юпорта), `height` (висота в'юпорта), `orientation` (портретна/альбомна), `resolution` (роздільна здатність екрана)."
      },
      {
        "id": "css-q5-aq3",
        "question": "Що таке 'mobile first' підхід у контексті медіа-запитів?",
        "answer": "'Mobile first' — це стратегія розробки, при якій спочатку створюються стилі для мобільних пристроїв, а потім за допомогою медіа-запитів додаються стилі для більших екранів (`min-width`)."
      }
    ]
  },
  {
    "id": "css-q6",
    "topic": "CSS",
    "mainQuestion": "Що таке специфічність селекторів у CSS?",
    "mainAnswer": "Специфічність селекторів — це алгоритм, за допомогою якого браузери визначають, яке CSS-правило застосовувати до елемента, якщо до нього застосовуються кілька конфліктуючих правил. Вона розраховується на основі кількості та типу селекторів у правилі.",
    "additionalQuestions": [
      {
        "id": "css-q6-aq1",
        "question": "Який порядок специфічності у різних типів селекторів?",
        "answer": "Від найвищого до найнижчого: inline-стилі > ID селектори > Класи/атрибути/псевдокласи > Теги/псевдоелементи. Універсальний селектор і успадковані стилі мають найнижчу специфічність."
      },
      {
        "id": "css-q6-aq2",
        "question": "Як `!important` впливає на специфічність?",
        "answer": "`!important` перебиває будь-яку іншу специфічність (за винятком іншого `!important` з вищою специфічністю або того ж рівня, що з'явився пізніше). Його використання не рекомендується через можливі проблеми з підтримкою коду."
      },
      {
        "id": "css-q6-aq3",
        "question": "Як розрахувати специфічність для даного правила?",
        "answer": "Специфічність розраховується за чотирма категоріями (a, b, c, d): 'a' для inline-стилів, 'b' для ID, 'c' для класів/атрибутів/псевдокласів, 'd' для тегів/псевдоелементів. Комбінація цих чисел утворює специфічність (наприклад, 0,1,2,3)."
      }
    ]
  },
  {
    "id": "css-q7",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між псевдоелементами та псевдокласами в CSS?",
    "mainAnswer": "Псевдокласи (`:hover`, `:focus`, `:first-child`) вибирають елементи на основі їхнього стану або положення в документі. Псевдоелементи (`::before`, `::after`, `::first-line`) дозволяють стилізувати певну частину елемента або додати віртуальний елемент до DOM-дерева.",
    "additionalQuestions": [
      {
        "id": "css-q7-aq1",
        "question": "Наведіть приклад використання псевдокласу.",
        "answer": "`a:hover { color: red; }` - змінить колір посилання на червоний при наведенні курсору."
      },
      {
        "id": "css-q7-aq2",
        "question": "Наведіть приклад використання псевдоелемента.",
        "answer": "`p::first-line { font-weight: bold; }` - зробить жирним перший рядок параграфа. `div::before { content: '->'; }` - додасть стрілку перед вмістом div."
      },
      {
        "id": "css-q7-aq3",
        "question": "Чи можна використовувати два двокрапки (`::`) для псевдокласів?",
        "answer": "Формально, для псевдокласів використовується один двокрапка (`:focus`). Для псевдоелементів рекомендовано використовувати два двокрапки (`::before`) з CSS3, хоча один (`:before`) також працює для сумісності зі старими браузерами."
      }
    ]
  },
  {
    "id": "css-q8",
    "topic": "CSS",
    "mainQuestion": "Що таке `tabindex`? Як і коли його використовувати?",
    "mainAnswer": "Атрибут `tabindex` дозволяє вказати, чи можна фокусуватися на елементі за допомогою клавіші Tab, і в якому порядку. Значення `0` робить елемент фокусованим у природному порядку, `-1` робить його фокусованим лише програмно, а позитивні значення (`1` і більше) визначають порядок табуляції (не рекомендується).",
    "additionalQuestions": [
      {
        "id": "css-q8-aq1",
        "question": "Для чого `tabindex` важливий у контексті доступності?",
        "answer": "Він критично важливий для навігації за допомогою клавіатури, дозволяючи користувачам, які не використовують мишу (наприклад, з порушеннями моторики), взаємодіяти з інтерактивними елементами веб-сторінки."
      },
      {
        "id": "css-q8-aq2",
        "question": "Коли не слід використовувати позитивні значення `tabindex`?",
        "answer": "Не слід використовувати позитивні значення (`tabindex=\"1\"`, `tabindex=\"2\"` тощо), оскільки це порушує природний порядок фокусування, що є непередбачуваним і погано для доступності."
      },
      {
        "id": "css-q8-aq3",
        "question": "Чи можна додати `tabindex` до будь-якого HTML-елемента?",
        "answer": "Так, `tabindex` є глобальним атрибутом і може бути доданий до будь-якого HTML-елемента, хоча він найбільш корисний для інтерактивних елементів (посилання, кнопки, форми) та елементів, які за замовчуванням не фокусуються, але повинні бути доступними через клавіатуру."
      }
    ]
  },
  {
    "id": "css-q9",
    "topic": "CSS",
    "mainQuestion": "Що означають `:focus` та `:active` у CSS?",
    "mainAnswer": "`:focus` — це псевдоклас, який вибирає елемент, який наразі перебуває у фокусі (наприклад, після кліку або навігації за допомогою клавіатури). `:active` — це псевдоклас, який вибирає елемент, який активується користувачем (наприклад, у момент натискання кнопки миші або клавіші на клавіатурі).",
    "additionalQuestions": [
      {
        "id": "css-q9-aq1",
        "question": "Для яких елементів найчастіше використовуються `:focus` та `:active`?",
        "answer": "Найчастіше використовуються для інтерактивних елементів, таких як посилання (`<a>`), кнопки (`<button>`), елементи форм (`<input>`, `<textarea>`)."
      },
      {
        "id": "css-q9-aq2",
        "question": "Чому важливо стилізувати `:focus` стан?",
        "answer": "Стилізація `:focus` важлива для доступності, оскільки вона надає візуальний індикатор для користувачів клавіатури, який елемент є активним. Видаляти стандартний `outline` не рекомендується без заміни."
      },
      {
      "id": "css-q9-aq3",
      "question": "Як довго зберігається `:active` стан?",
      "answer": "Стан `:active` зберігається лише на дуже короткий проміжок часу — поки користувач активно утримує кнопку миші або натискає клавішу. Після відпускання `:active` зникає."
      }
    ]
  },
  {
    "id": "css-q10",
    "topic": "CSS",
    "mainQuestion": "Що таке `outline`? Чи краще його залишати чи видаляти?",
    "mainAnswer": "`outline` — це контур, який браузери відображають навколо елементів, коли вони знаходяться у фокусі (наприклад, після кліку або навігації клавіатурою). Його *краще залишати* або замінювати на інший візуальний індикатор фокусу, оскільки він критично важливий для доступності та навігації клавіатурою.",
    "additionalQuestions": [
      {
        "id": "css-q10-aq1",
        "question": "Яка головна функція `outline`?",
        "answer": "Основна функція — надати візуальний індикатор фокусу для користувачів клавіатури, що дозволяє їм бачити, який елемент наразі активний."
      },
      {
        "id": "css-q10-aq2",
        "question": "Чому розробники іноді видаляють `outline`?",
        "answer": "Іноді його видаляють з естетичних міркувань (`outline: none;`), але це є поганою практикою для доступності, якщо не надається альтернативний візуальний зворотний зв'язок."
      },
      {
        "id": "css-q10-aq3",
        "question": "Як можна замінити `outline` для збереження доступності?",
        "answer": "Можна замінити його на інший візуальний ефект при фокусі, наприклад, зміною `border`, `box-shadow` або `background-color`, що краще відповідає дизайну, але зберігає функціональність."
      }
    ]
  },
  {
    "id": "css-q11",
    "topic": "CSS",
    "mainQuestion": "Поясніть властивість `position` у CSS та її значення.",
    "mainAnswer": "Властивість `position` визначає метод позиціонування елемента в документі. Основні значення: `static` (за замовчуванням, у природному потоці), `relative` (позиціонується відносно свого нормального положення), `absolute` (позиціонується відносно найближчого позиціонованого предка), `fixed` (позиціонується відносно вікна перегляду) та `sticky` (позиціонується як `relative`, доки не досягне певної точки прокрутки, потім стає `fixed`).",
    "additionalQuestions": [
      {
        "id": "css-q11-aq1",
        "question": "Які властивості використовуються разом з `position`?",
        "answer": "Разом з `position` використовуються властивості `top`, `bottom`, `left`, `right` для визначення зміщення елемента."
      },
      {
        "id": "css-q11-aq2",
        "question": "Чим відрізняється `position: absolute` від `position: fixed`?",
        "answer": "`absolute` позиціонується відносно найближчого *позиціонованого* предка і прокручується разом зі сторінкою. `fixed` позиціонується відносно *вікна перегляду* (viewport) і залишається на місці при прокручуванні."
      },
      {
        "id": "css-q11-aq3",
        "question": "Коли варто використовувати `position: sticky`?",
        "answer": "`position: sticky` ідеально підходить для створення 'прилипаючих' елементів, таких як навігаційні панелі, які спочатку прокручуються, а потім 'залишаються' у верхній частині екрану."
      }
    ]
  },
  {
    "id": "css-q12",
    "topic": "CSS",
    "mainQuestion": "Опишіть `z-index` та як формується контекст накладання (stacking context).",
    "mainAnswer": "`z-index` властивість контролює порядок накладання позиціонованих елементів на осі Z (глибина). Елемент з вищим `z-index` перекриває елемент з нижчим. Контекст накладання формується, коли елемент має `position` відмінний від `static` та/або деякі інші властивості (наприклад, `opacity < 1`, `transform`, `flex` або `grid` контейнери, `will-change`). Елементи в одному контексті накладання позиціонуються відносно один одного, але весь контекст діє як єдиний 'шар' в його батьківському контексті.",
    "additionalQuestions": [
      {
        "id": "css-q12-aq1",
        "question": "Чи працює `z-index` для всіх елементів?",
        "answer": "Ні, `z-index` працює тільки для позиціонованих елементів (тобто тих, у кого `position` встановлено на `relative`, `absolute`, `fixed` або `sticky`)."
      },
      {
        "id": "css-q12-aq2",
        "question": "Якщо два елементи мають однаковий `z-index`, хто буде зверху?",
        "answer": "Якщо `z-index` однаковий, порядок накладання визначається порядком їх появи в HTML-документі: пізніший елемент буде зверху."
      },
      {
        "id": "css-q12-aq3",
        "question": "Які інші властивості можуть створити контекст накладання?",
        "answer": "Крім `position` (не static), це можуть бути `opacity` менше 1, `transform` не `none`, `filter` не `none`, `will-change` (для властивостей, що створюють контекст), `flex` або `grid` контейнери, `isolation: isolate`."
      }
    ]
  },
  {
    "id": "css-q13",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між `inline-block`, `block`, `inline`?",
    "mainAnswer": "`display: block;` елементи займають всю доступну ширину, починаються з нового рядка, дозволяють встановлювати `width`, `height`, `margin`, `padding`. `display: inline;` елементи займають лише стільки місця, скільки їм потрібно, не починаються з нового рядка, ігнорують `width`, `height`, вертикальні `margin`/`padding`. `display: inline-block;` поєднує властивості обох: як `inline`, він не починається з нового рядка, але як `block`, він дозволяє встановлювати `width`, `height`, `margin`, `padding` (всі сторони).",
    "additionalQuestions": [
      {
        "id": "css-q13-aq1",
        "question": "Наведіть приклади типових `block` та `inline` елементів.",
        "answer": "Типові `block`: `<div>`, `<p>`, `<h1>`. Типові `inline`: `<span>`, `<a>`, `<strong>`, `<em>`."
      },
      {
        "id": "css-q13-aq2",
        "question": "Коли `inline-block` є особливо корисним?",
        "answer": "`inline-block` дуже корисний для створення елементів навігації, кнопок або іконок, які повинні бути в одному рядку, але також мати задану ширину, висоту та відступи."
      },
      {
        "id": "css-q13-aq3",
        "question": "Як впливає `display` на поведінку елемента у потоці документа?",
        "answer": "`display` контролює, як елемент генерує Box Model та взаємодіє з іншими елементами у нормальному потоці, визначаючи, чи займатиме він весь рядок, чи буде частиною рядка, і як він реагуватиме на властивості розмірів та відступів."
      }
    ]
  },
  {
    "id": "css-q14",
    "topic": "CSS",
    "mainQuestion": "Чи можна застосувати `padding-top` та `padding-bottom` до `inline` елемента?",
    "mainAnswer": "Так, до `inline` елементів можна застосувати `padding-top` та `padding-bottom`. Ці властивості збільшать 'розмір' елемента, але **не вплинуть на розташування сусідніх елементів у вертикальному напрямку**, оскільки `inline` елементи зберігають свій рядок. Це може призвести до накладання вмісту.",
    "additionalQuestions": [
      {
        "id": "css-q14-aq1",
        "question": "Як виглядатиме візуальний ефект `padding-top` на `inline` елементі?",
        "answer": "Зверху та знизу елемента з'явиться візуальний відступ, але це не посуне елементи у вищому або нижчому рядку. Текст може накладатися на цей відступ."
      },
      {
        "id": "css-q14-aq2",
        "question": "Який ефект `padding-left` та `padding-right` на `inline` елементі?",
        "answer": "`padding-left` та `padding-right` працюють нормально для `inline` елементів, збільшуючи простір по горизонталі та відсуваючи сусідні елементи."
      },
      {
        "id": "css-q14-aq3",
        "question": "Якщо потрібно відсунути `inline` елемент вертикально, що робити?",
        "answer": "Щоб коректно відсунути `inline` елемент вертикально, його потрібно змінити на `display: block;` або `display: inline-block;`."
      }
    ]
  },
  {
    "id": "css-q15",
    "topic": "CSS",
    "mainQuestion": "Чи можна застосувати `margin-top` та `margin-bottom` до `inline` елемента?",
    "mainAnswer": "Ні, `margin-top` та `margin-bottom` **не застосовуються** до `inline` елементів і не матимуть жодного ефекту на їх вертикальне розташування чи відступи від інших елементів. Застосовуються лише `margin-left` та `margin-right`.",
    "additionalQuestions": [
      {
        "id": "css-q15-aq1",
        "question": "Які властивості `margin` працюють для `inline` елементів?",
        "answer": "Для `inline` елементів працюють лише `margin-left` та `margin-right`, створюючи горизонтальний відступ."
      },
      {
        "id": "css-q15-aq2",
        "question": "Яке рішення для створення вертикальних відступів між `inline` елементами?",
        "answer": "Для вертикальних відступів `inline` елементи зазвичай обгортають у блокові контейнери, або самі елементи перетворюють на `inline-block` або `block`."
      },
      {
        "id": "css-q15-aq3",
        "question": "Чи є винятки для правила `margin-top/bottom` на `inline`?",
        "answer": "Ні, це стандартна поведінка `inline` елементів згідно з CSS Box Model. Вертикальні маргіни ігноруються."
      }
    ]
  },
  {
    "id": "css-q16",
    "topic": "CSS",
    "mainQuestion": "Що таке 'margin collapse'?",
    "mainAnswer": "'Margin collapse' (схлопування зовнішніх відступів) — це явище в CSS, коли вертикальні зовнішні відступи (margin-top та margin-bottom) сусідніх *блокових* елементів об'єднуються в один спільний відступ, який дорівнює більшому з них. Це відбувається лише у вертикальному напрямку.",
    "additionalQuestions": [
      {
        "id": "css-q16-aq1",
        "question": "Коли відбувається схлопування зовнішніх відступів?",
        "answer": "Схлопування відбувається між: 1. Сусідніми блоковими елементами. 2. Батьківським елементом та його першим/останнім дочірнім елементом, якщо між ними немає `border` або `padding`. 3. Порожнім блоковим елементом без вмісту, `border` або `padding`."
      },
      {
        "id": "css-q16-aq2",
        "question": "Як запобігти схлопуванню зовнішніх відступів?",
        "answer": "Запобігти можна, додавши `padding` або `border` до батьківського елемента, використовуючи `overflow: hidden`, змінюючи `display` (наприклад, на `flex` або `grid` контейнер), або використовуючи `position: absolute`."
      },
      {
        "id": "css-q16-aq3",
        "question": "Чи схлопуються горизонтальні зовнішні відступи?",
        "answer": "Ні, схлопуються лише вертикальні зовнішні відступи. Горизонтальні `margin-left` та `margin-right` завжди додаються."
      }
    ]
  },
  {
    "id": "css-q17",
    "topic": "CSS",
    "mainQuestion": "Що таке `box-sizing`? Навіщо він потрібен?",
    "mainAnswer": "`box-sizing` — це CSS-властивість, яка визначає, як розраховується загальний розмір елемента (width та height), включаючи `padding` та `border`. За замовчуванням (`content-box`), `padding` та `border` додаються до заданої `width`/`height`. При `border-box`, `padding` та `border` *включаються* в задану `width`/`height`, що спрощує розрахунок розмірів макетів.",
    "additionalQuestions": [
      {
        "id": "css-q17-aq1",
        "question": "Яке значення `box-sizing` вважається кращим для верстки і чому?",
        "answer": "`border-box` часто вважається кращим, оскільки він дозволяє легше контролювати розміри елементів і спрощує розрахунки при створенні макетів, оскільки `padding` та `border` не 'виштовхують' елемент за межі заданої ширини/висоти."
      },
      {
        "id": "css-q17-aq2",
        "question": "Як встановити `box-sizing: border-box` для всіх елементів?",
        "answer": "Поширеною практикою є використання універсального селектора: `*, *::before, *::after { box-sizing: border-box; }`."
      },
      {
        "id": "css-q17-aq3",
        "question": "Чи впливає `box-sizing` на `margin`?",
        "answer": "Ні, `box-sizing` впливає лише на те, як `width`, `height`, `padding` та `border` взаємодіють. `margin` завжди залишається зовні розміру елемента."
      }
    ]
  },
  {
    "id": "css-q18",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між `display: none`, `visibility: hidden` та `opacity: 0`?",
    "mainAnswer": "`display: none` повністю видаляє елемент з документа, він не займає місця і не взаємодіє з подіями. `visibility: hidden` приховує елемент, але він все ще займає своє місце в макеті та може впливати на інші елементи, але не взаємодіє з подіями. `opacity: 0` робить елемент повністю прозорим, він залишається на місці, займає простір, взаємодіє з подіями, але візуально невидимий.",
    "additionalQuestions": [
      {
        "id": "css-q18-aq1",
        "question": "Який метод кращий для приховування елемента, якщо потрібно зберегти його місце в макеті?",
        "answer": "`visibility: hidden` або `opacity: 0`."
      },
      {
        "id": "css-q18-aq2",
        "question": "Який метод впливає на SEO та доступність?",
        "answer": "`display: none` повністю приховує елемент від скрін-рідерів та пошукових систем. `visibility: hidden` та `opacity: 0` приховують візуально, але контент все ще доступний для скрін-рідерів та обробляється пошуковими системами."
      },
      {
        "id": "css-q18-aq3",
        "question": "Який метод дозволяє анімувати проявлення/зникнення?",
        "answer": "`visibility: hidden` (з `transition` на `visibility: visible`) та `opacity: 0` (з `transition` на `opacity: 1`) можуть бути анімовані, на відміну від `display: none`."
      }
    ]
  },
  {
    "id": "css-q19",
    "topic": "CSS",
    "mainQuestion": "Що таке 'візуально прихований' фрагмент коду (visually hidden snippet)?",
    "mainAnswer": "'Візуально прихований' фрагмент коду CSS — це набір правил, який дозволяє приховати елемент візуально з екрана, але зберегти його доступним для скрін-рідерів та інших допоміжних технологій. Це досягається шляхом зменшення розміру елемента до 1px на 1px, обрізання вмісту, видалення видимих меж та переміщення його за межі екрану.",
    "additionalQuestions": [
      {
        "id": "css-q19-aq1",
        "question": "Наведіть приклад використання 'візуально прихованого' фрагмента.",
        "answer": "Використовується для приховування текстових міток для іконок, додаткових пояснень для елементів форм або навігаційних посилань 'Skip to main content' для покращення доступності."
      },
      {
        "id": "css-q19-aq2",
        "question": "Які CSS-властивості зазвичай входять у 'візуально прихований' фрагмент?",
        "answer": "Типові властивості: `position: absolute;`, `width: 1px;`, `height: 1px;`, `margin: -1px;`, `padding: 0;`, `overflow: hidden;`, `clip: rect(0 0 0 0);`, `white-space: nowrap;`, `border: 0;`."
      },
      {
        "id": "css-q19-aq3",
        "question": "У чому відмінність від `display: none` для доступності?",
        "answer": "На відміну від `display: none`, який повністю приховує елемент від усіх, 'візуально прихований' фрагмент робить елемент невидимим *візуально*, але доступним для скрін-рідерів, що є критично важливим для інклюзивного дизайну."
      }
    ]
  },
  {
    "id": "css-q20",
    "topic": "CSS",
    "mainQuestion": "Перелічіть усі способи центрування елементів горизонтально та вертикально. Окремо для `inline` та `block` елементів.",
    "mainAnswer": "Горизонтальне центрування: **Блоковий елемент:** `margin: 0 auto;`. **Inline/inline-block:** `text-align: center;` на батьківському елементі. **Flexbox:** `justify-content: center;` на контейнері. **Grid:** `justify-items: center;` або `justify-self: center;`. \nВертикальне центрування: **Блоковий елемент (з відомою висотою):** `position: absolute; top: 50%; transform: translateY(-50%);`. **Inline/inline-block (один рядок):** `line-height` = `height`. **Flexbox:** `align-items: center;` на контейнері. **Grid:** `align-items: center;` або `align-self: center;`. **Застарілі:** `vertical-align` (для inline), `table-cell`.",
    "additionalQuestions": [
      {
        "id": "css-q20-aq1",
        "question": "Який спосіб центрування вважається найгнучкішим і сучасним?",
        "answer": "Flexbox та CSS Grid є найбільш гнучкими та сучасними способами центрування як горизонтально, так і вертикально, для різних типів елементів."
      },
      {
        "id": "css-q20-aq2",
        "question": "Як центрувати `block` елемент горизонтально без Flexbox/Grid?",
        "answer": "Для блокового елемента з фіксованою або максимальною шириною використовується `margin: 0 auto;`."
      },
      {
        "id": "css-q20-aq3",
        "question": "Чи можна центрувати текст всередині `div` за допомогою `margin: 0 auto;`?",
        "answer": "Ні, `margin: 0 auto;` центрує сам блоковий елемент. Щоб центрувати *текст* всередині блокового елемента, використовується `text-align: center;`."
      }
    ]
  },
  {
    "id": "css-q21",
    "topic": "CSS",
    "mainQuestion": "Що таке Flexbox?",
    "mainAnswer": "Flexbox (Flexible Box Layout module) — це одномірна система макета CSS, яка дозволяє легко вирівнювати та розподіляти простір між елементами в контейнері, навіть якщо їхній розмір невідомий або динамічний. Він ідеально підходить для створення складних компонентів та навігації.",
    "additionalQuestions": [
      {
        "id": "css-q21-aq1",
        "question": "Яка головна відмінність Flexbox від Grid?",
        "answer": "Flexbox є одномірним (працює або по рядку, або по стовпцю), тоді як CSS Grid є двомірним (працює одночасно по рядках і стовпцях)."
      },
      {
        "id": "css-q21-aq2",
        "question": "Які основні поняття Flexbox?",
        "answer": "Основні поняття: flex-контейнер (батьківський елемент), flex-елементи (дочірні елементи), main axis (головна вісь) та cross axis (поперечна вісь)."
      },
      {
        "id": "css-q21-aq3",
        "question": "Яка CSS властивість активує Flexbox для елемента?",
        "answer": "Властивість `display: flex;` на батьківському елементі робить його flex-контейнером."
      }
    ]
  },
  {
    "id": "css-q22",
    "topic": "CSS",
    "mainQuestion": "Як ми можемо змінити порядок елементів у Flexbox?",
    "mainAnswer": "Порядок елементів у Flexbox можна змінити за допомогою властивості `order` на flex-елементах. Елементи з меншим значенням `order` відображаються раніше. За замовчуванням `order` дорівнює `0`.",
    "additionalQuestions": [
      {
        "id": "css-q22-aq1",
        "question": "Чи впливає `order` на DOM-порядок?",
        "answer": "Ні, властивість `order` впливає лише на візуальний порядок відображення елементів у Flexbox, не змінюючи їхнього порядку в DOM-дереві. Це важливо для доступності та SEO."
      },
      {
        "id": "css-q22-aq2",
        "question": "Які значення може приймати властивість `order`?",
        "answer": "`order` приймає цілі числа, включаючи від'ємні. Елементи з меншим значенням відображаються раніше."
      },
      {
        "id": "css-q22-aq3",
        "question": "Навіщо може знадобитися змінювати порядок елементів у Flexbox?",
        "answer": "Це корисно для адаптивного дизайну, коли потрібно змінити візуальне розташування елементів на різних розмірах екрана, або для логічного упорядкування контенту без зміни HTML-структури."
      }
    ]
  },
  {
    "id": "css-q23",
    "topic": "CSS",
    "mainQuestion": "Як працює `margin: auto` у Flexbox?",
    "mainAnswer": "У Flexbox, `margin: auto` на flex-елементі поглинає весь доступний простір у напрямку осі, на якій він застосований. Якщо застосовано `margin: auto` з одного боку, воно розсуне елемент до відповідного краю. Якщо з двох протилежних боків (наприклад, `margin-left: auto; margin-right: auto;` або просто `margin: auto;`), воно центрує елемент по цій осі.",
    "additionalQuestions": [
      {
        "id": "css-q23-aq1",
        "question": "Як `margin: auto` відрізняється в Flexbox порівняно зі звичайним блоковим елементом?",
        "answer": "У звичайному блоковому елементі `margin: auto` центрує його лише горизонтально. У Flexbox `margin: auto` може центрувати елемент як горизонтально, так і вертикально, залежно від `flex-direction` та осі, де застосовано `auto`."
      },
      {
        "id": "css-q23-aq2",
        "question": "Як центрувати елемент вертикально за допомогою `margin: auto` у Flexbox?",
        "answer": "Якщо `flex-direction: row;`, то `margin-top: auto; margin-bottom: auto;` (або `margin: auto 0;`) на flex-елементі вирівняє його вертикально. Якщо `flex-direction: column;`, то `margin: auto;` центрує його вертикально."
      },
      {
        "id": "css-q23-aq3",
        "question": "Чи може `margin: auto` працювати з кількома Flex-елементами одночасно?",
        "answer": "Так. Якщо `margin: auto` застосовано до кількох елементів, вони рівномірно розподілять між собою доступний простір."
      }
    ]
  },
  {
    "id": "css-q24",
    "topic": "CSS",
    "mainQuestion": "Що означають `object-fit: cover` та `object-fit: contain`?",
    "mainAnswer": "Властивість `object-fit` використовується для управління тим, як вміст `<img>` або `<video>` елемента масштабується та обрізається відповідно до розмірів контейнера. `cover`: вміст масштабується, щоб повністю заповнити контейнер, обрізаючи частини, які виходять за межі. Зберігає співвідношення сторін. `contain`: вміст масштабується, щоб поміститися всередині контейнера повністю, зберігаючи співвідношення сторін. Може залишати порожні області (літербокси).",
    "additionalQuestions": [
      {
        "id": "css-q24-aq1",
        "question": "Яке значення `object-fit` є типовим за замовчуванням?",
        "answer": "За замовчуванням `object-fit` має значення `fill`, яке розтягує або стискає вміст, щоб повністю заповнити контейнер, ігноруючи співвідношення сторін."
      },
      {
        "id": "css-q24-aq2",
        "question": "Коли краще використовувати `object-fit: cover`?",
        "answer": "`object-fit: cover` ідеально підходить для фонових зображень або банерів, коли потрібно, щоб зображення повністю заповнювало область, навіть якщо деякі частини обрізаються."
      },
      {
        "id": "css-q24-aq3",
        "question": "Коли краще використовувати `object-fit: contain`?",
        "answer": "`object-fit: contain` краще використовувати, коли важливо показати все зображення без обрізки, наприклад, для логотипів, іконок або галереї зображень, де простір навколо зображення допустимий."
      }
    ]
  },
  {
    "id": "css-q25",
    "topic": "CSS",
    "mainQuestion": "У чому різниця між векторною та растровою графікою?",
    "mainAnswer": "Растрова графіка (наприклад, JPG, PNG, GIF) складається з сітки пікселів. Вона втрачає якість при масштабуванні. Векторна графіка (наприклад, SVG) складається з математичних формул, що описують лінії, криві та фігури. Вона зберігає якість при будь-якому масштабуванні і має менший розмір файлу.",
    "additionalQuestions": [
      {
        "id": "css-q25-aq1",
        "question": "Для яких цілей краще використовувати растрову графіку?",
        "answer": "Растрову графіку краще використовувати для фотографій, складних зображень з великою кількістю кольорів та деталей, або коли потрібна реалістична текстура."
      },
      {
        "id": "css-q25-aq2",
        "question": "Для яких цілей краще використовувати векторну графіку?",
        "answer": "Векторну графіку ідеально використовувати для логотипів, іконок, ілюстрацій, діаграм, шрифтів та будь-яких елементів, які повинні виглядати чітко на будь-якому розмірі екрана."
      },
      {
        "id": "css-q25-aq3",
        "question": "Які формати файлів для векторної та растрової графіки поширені у вебі?",
        "answer": "Растрові: `.jpg`, `.png`, `.gif`, `.webp`, `.avif`. Векторні: `.svg`."
      }
    ]
  },
  {
    "id": "css-q26",
    "topic": "CSS",
    "mainQuestion": "Поясніть різні види трансформацій (transforms) у CSS.",
    "mainAnswer": "CSS Transforms дозволяють змінювати розмір, обертати, нахиляти та переміщувати елементи в 2D або 3D просторі, не впливаючи на інші елементи в документі. Основні функції: `translate()` (переміщення), `rotate()` (обертання), `scale()` (зміна розміру), `skew()` (нахил). Вони можуть бути застосовані індивідуально або комбіновано.",
    "additionalQuestions": [
      {
        "id": "css-q26-aq1",
        "question": "У чому перевага використання `transform` для анімації переміщення над `top`/`left`?",
        "answer": "`transform` виконується на GPU (графічному процесорі), що забезпечує більш плавну та продуктивну анімацію, оскільки не викликає перемальовування (repaint) або перекомпонування (reflow) макета, на відміну від `top`/`left`."
      },
      {
        "id": "css-q26-aq2",
        "question": "Що таке `transform-origin`?",
        "answer": "`transform-origin` дозволяє визначити точку, навколо якої відбуваються трансформації (наприклад, центр обертання або масштабування). За замовчуванням це центр елемента."
      },
      {
        "id": "css-q26-aq3",
        "question": "Чи можуть `transform` властивості впливати на потік документа?",
        "answer": "Ні, `transform` не впливає на потік документа. Елемент лише візуально змінюється, але його початкове місце в макеті залишається незмінним, тому він не посуне сусідні елементи."
      }
    ]
  },
  {
    "id": "css-q27",
    "topic": "CSS",
    "mainQuestion": "Що таке `transition` у CSS3? Поясніть синтаксис.",
    "mainAnswer": "CSS `transition` дозволяє плавно змінювати значення CSS-властивостей протягом певного періоду часу, створюючи анімаційні ефекти без використання JavaScript. Синтаксис: `transition: [property] [duration] [timing-function] [delay];`.",
    "additionalQuestions": [
      {
        "id": "css-q27-aq1",
        "question": "Наведіть приклад використання `transition`.",
        "answer": "`button { background-color: blue; transition: background-color 0.3s ease-in-out; } button:hover { background-color: red; }` - плавна зміна кольору фону при наведенні."
      },
      {
        "id": "css-q27-aq2",
        "question": "Які значення може приймати `timing-function`?",
        "answer": "Типові значення: `ease` (повільно на початку і в кінці), `linear` (рівномірно), `ease-in` (повільно на початку), `ease-out` (повільно в кінці), `ease-in-out` (повільно на початку і в кінці). Можна використовувати `cubic-bezier()` для кастомних функцій."
      },
      {
        "id": "css-q27-aq3",
        "question": "Чи можна анімувати всі CSS-властивості за допомогою `transition`?",
        "answer": "Ні, не всі. Можна анімувати лише властивості, які мають 'проміжні стани' (тобто числові значення, кольори, розміри, позиції). Властивості на кшталт `display` або `visibility` не можуть бути плавно анімовані безпосередньо."
      }
    ]
  },
  {
    "id": "css-q28",
    "topic": "CSS",
    "mainQuestion": "Що таке `animation` у CSS3? Поясніть синтаксис.",
    "mainAnswer": "CSS `animation` дозволяє створювати складніші анімації з кількома кроками (ключовими кадрами) та більшим контролем над їхнім виконанням, на відміну від простих `transition`. Синтаксис: `@keyframes animation-name { from { ... } to { ... } }` та `element { animation: [name] [duration] [timing-function] [delay] [iteration-count] [direction] [fill-mode] [play-state]; }`.",
    "additionalQuestions": [
      {
        "id": "css-q28-aq1",
        "question": "У чому головна відмінність між `transition` та `animation`?",
        "answer": "`transition` - це проста анімація між двома станами (наприклад, при наведенні курсора). `animation` - дозволяє створювати складні анімації з кількома ключовими кадрами, циклічним повторенням та більшим контролем над часом."
      },
      {
        "id": "css-q28-aq2",
        "question": "Що таке `@keyframes`?",
        "answer": "`@keyframes` — це правило CSS, яке визначає послідовність анімації, задаючи стилі в конкретних точках (відсотках) її виконання."
      },
      {
        "id": "css-q28-aq3",
        "question": "Які властивості `animation` контролюють повторення та напрямок анімації?",
        "answer": "`animation-iteration-count` (скільки разів повторити) та `animation-direction` (нормально, зворотньо, поперемінно) контролюють повторення та напрямок."
      }
    ]
  },
  {
    "id": "css-q29",
    "topic": "CSS",
    "mainQuestion": "Які властивості кращі для анімацій? Чому `transform` та `opacity` є кращими?",
    "mainAnswer": "Для анімацій краще використовувати властивості, які не викликають 'reflow' (перекомпонування) та 'repaint' (перемальовування) браузером, а натомість використовують GPU для 'compositing'. `transform` (переміщення, обертання, масштабування) та `opacity` (прозорість) є кращими, оскільки вони відносно дешеві з точки зору продуктивності, оскільки впливають лише на композицію шарів і не змушують браузер перераховувати макет сторінки.",
    "additionalQuestions": [
      {
        "id": "css-q29-aq1",
        "question": "Які CSS-властивості варто уникати для анімацій через продуктивність?",
        "answer": "Варто уникати анімації властивостей, які впливають на макет (`width`, `height`, `margin`, `padding`, `top`, `left`) або на 'paint' (`color`, `background-color`, `box-shadow`) без певних оптимізацій, оскільки вони викликають дорогі операції reflow/repaint."
      },
      {
        "id": "css-q29-aq2",
        "question": "Що означає 'reflow' та 'repaint' у браузері?",
        "answer": "'Reflow' (або 'layout') — це перерахунок розташування та розмірів усіх елементів на сторінці. 'Repaint' — це перемальовування пікселів елементів. Обидві операції є ресурсоємними і можуть призвести до 'лагів' в анімації."
      },
      {
        "id": "css-q29-aq3",
        "question": "Як `will-change` властивість допомагає оптимізувати анімації?",
        "answer": "`will-change` є підказкою для браузера, що певна властивість елемента буде змінена в майбутньому (наприклад, анімована), дозволяючи браузеру заздалегідь виконати деякі оптимізації, такі як перенесення елемента на окремий шар GPU."
      }
    ]
  },
  {
    "id": "css-q30",
    "topic": "CSS",
    "mainQuestion": "Як писати ефективний CSS? Поясніть загальні правила, технології, методології.",
    "mainAnswer": "Ефективний CSS — це читабельний, підтримуваний, масштабований та продуктивний код. Загальні правила: використання семантичного HTML, мінімізація вкладеності селекторів, використання коротких властивостей, зменшення використання `!important`. Технології: препроцесори (Sass, Less), PostCSS, CSS-змінні. Методології: BEM, OOCSS, SMACSS, CSS Modules, Styled Components — вони допомагають організувати код та уникнути конфліктів.",
    "additionalQuestions": [
      {
        "id": "css-q30-aq1",
        "question": "Які переваги використання CSS-препроцесорів?",
        "answer": "Препроцесори додають функціонал, якого немає в чистому CSS (змінні, міксини, вкладеність, функції), що робить код більш організованим, читабельним та легким для підтримки."
      },
      {
        "id": "css-q30-aq2",
        "question": "Що таке 'CSS-in-JS'?",
        "answer": "'CSS-in-JS' — це підхід, при якому CSS пишеться безпосередньо в JavaScript-коді, що забезпечує інкапсуляцію стилів для компонентів та динамічну генерацію стилів."
      },
      {
        "id": "css-q30-aq3",
        "question": "Чому мінімізація вкладеності селекторів є важливою для продуктивності?",
        "answer": "Більш вкладені (складні) селектори вимагають від браузера більше часу для обчислення їхньої специфічності та застосування стилів, що може уповільнювати рендеринг сторінки. Простіші селектори працюють швидше."
      }
    ]
  },
  {
    "id": "css-q31",
    "topic": "CSS",
    "mainQuestion": "Що таке методології CSS?",
    "mainAnswer": "Методології CSS — це набори правил та принципів для організації та структурування CSS-коду у великих проектах. Їхня мета — забезпечити читабельність, підтримуваність, масштабованість та уникнення конфліктів стилів, особливо при роботі в команді.",
    "additionalQuestions": [
      {
        "id": "css-q31-aq1",
        "question": "Наведіть кілька прикладів популярних методологій CSS.",
        "answer": "BEM (Block, Element, Modifier), OOCSS (Object-Oriented CSS), SMACSS (Scalable and Modular Architecture for CSS), ITCSS (Inverted Triangle CSS)."
      },
      {
        "id": "css-q31-aq2",
        "question": "Які переваги використання методології CSS?",
        "answer": "Покращена організація коду, легша підтримка, зменшення конфліктів, полегшення співпраці в команді, можливість повторного використання компонентів."
      },
      {
        "id": "css-q31-aq3",
        "question": "Чи є недоліки у використанні методологій CSS?",
        "answer": "Деякі методології можуть бути занадто багатослівними (наприклад, BEM з довгими іменами класів) або мати круту криву навчання для нових розробників."
      }
    ]
  },
  {
    "id": "css-q32",
    "topic": "CSS",
    "mainQuestion": "Поясніть методологію BEM.",
    "mainAnswer": "BEM (Block, Element, Modifier) — це методологія іменування класів CSS, яка допомагає створювати модульний, повторно використовуваний та масштабований код. Вона розділяє інтерфейс на незалежні блоки (Block), їхні складові частини (Element) та стани/варіації (Modifier). Наприклад: `block__element--modifier`.",
    "additionalQuestions": [
      {
        "id": "css-q32-aq1",
        "question": "Що таке 'Блок' у BEM?",
        "answer": "Блок — це незалежний, функціонально завершений компонент інтерфейсу, який можна використовувати повторно (наприклад, `header`, `button`, `form`)."
      },
      {
        "id": "css-q32-aq2",
        "question": "Що таке 'Елемент' у BEM?",
        "answer": "Елемент — це частина Блоку, яка не має самостійного значення і не може використовуватися поза контекстом свого Блоку (наприклад, `header__logo`, `button__icon`, `form__input`)."
      },
      {
        "id": "css-q32-aq3",
        "question": "Що таке 'Модифікатор' у BEM?",
        "answer": "Модифікатор — це сутність, яка визначає зовнішній вигляд або поведінку Блоку або Елемента (наприклад, `button--primary`, `form--disabled`, `header__logo--small`)."
      }
    ]
  },
  {
    "id": "css-q33",
    "topic": "CSS",
    "mainQuestion": "Що таке Stylelint? Коли його використовувати?",
    "mainAnswer": "Stylelint — це потужний, сучасний 'лінтинг' (linting) інструмент для CSS, Sass, Less та інших препроцесорів. Він допомагає виявляти помилки, дотримуватися стандартів кодування, забезпечувати послідовність стилів та запобігати антипатернам. Його варто використовувати у будь-якому проекті для забезпечення високої якості та єдності CSS-коду.",
    "additionalQuestions": [
      {
        "id": "css-q33-aq1",
        "question": "Які переваги використання лінтерів, таких як Stylelint?",
        "answer": "Лінтери покращують якість коду, запобігають помилкам, підтримують єдиний стиль кодування в команді, допомагають дотримуватися кращих практик та забезпечують швидший зворотний зв'язок розробникам."
      },
      {
        "id": "css-q33-aq2",
        "question": "Чи можна інтегрувати Stylelint у процес збірки проекту?",
        "answer": "Так, Stylelint можна інтегрувати в системи збірки (наприклад, Webpack, Gulp, Rollup) або системи контролю версій (через pre-commit хуки), щоб автоматично перевіряти код перед його комітом."
      },
      {
        "id": "css-q33-aq3",
        "question": "Чи підтримує Stylelint кастомні правила?",
        "answer": "Так, Stylelint дозволяє створювати власні правила або використовувати плагіни для розширення його функціоналу відповідно до унікальних потреб проекту."
      }
    ]
  },
  {
    "id": "css-q34",
    "topic": "CSS",
    "mainQuestion": "Що таке вендорні префікси (vendor prefixes)?",
    "mainAnswer": "Вендорні префікси — це префікси, які додаються до експериментальних або нестандартних CSS-властивостей, щоб дозволити браузерам реалізувати або тестувати ці властивості до того, як вони стануть частиною офіційного стандарту. Наприклад: `-webkit-` для Chrome/Safari, `-moz-` для Firefox, `-ms-` для Internet Explorer, `-o-` для Opera.",
    "additionalQuestions": [
      {
        "id": "css-q34-aq1",
        "question": "Чи потрібно вручну додавати вендорні префікси?",
        "answer": "Ні, вручну додавати не рекомендується. Використовують інструменти, такі як Autoprefixer (з PostCSS), які автоматично додають потрібні префікси на основі вказаних версій браузерів."
      },
      {
        "id": "css-q34-aq2",
        "question": "Чи потрібні вендорні префікси у сучасному вебі?",
        "answer": "Вони потрібні все рідше, оскільки більшість сучасних CSS-властивостей вже стандартизовані. Однак для деяких нових або експериментальних властивостей вони все ще можуть бути потрібні для підтримки старих браузерів."
      },
      {
        "id": "css-q34-aq3",
        "question": "Яка головна проблема використання вендорних префіксів?",
        "answer": "Головна проблема полягає в тому, що вони збільшують обсяг CSS-коду, вимагають оновлення та можуть призвести до фрагментації, якщо розробники забувають про них або не використовують автоматичні інструменти."
      }
    ]
  }
]