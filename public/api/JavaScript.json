[
  {
    "id": "js-q1",
    "topic": "JavaScript",
    "mainQuestion": "Що таке глобальний об'єкт (global object)?",
    "mainAnswer": "Глобальний об'єкт — це об'єкт, який завжди доступний у глобальній області видимості JavaScript. У браузері це об'єкт `window`, а в Node.js — `global`. Він містить глобальні змінні, функції та властивості, доступні з будь-якого місця коду.",
    "additionalQuestions": [
      {
        "id": "js-q1-aq1",
        "question": "Яка головна відмінність між `window` та `global`?",
        "answer": "`window` є глобальним об'єктом у середовищі браузера, що представляє вікно браузера та його вміст, тоді як `global` є глобальним об'єктом у середовищі Node.js, що представляє глобальний простір імен сервера."
      },
      {
        "id": "js-q1-aq2",
        "question": "Чи можна додавати властивості до глобального об'єкта?",
        "answer": "Так, глобальні змінні та функції, оголошені без `var`, `let` або `const` (у нестрогому режимі), стають властивостями глобального об'єкта. Однак це не є рекомендованою практикою."
      },
      {
        "id": "js-q1-aq3",
        "question": "Які типові глобальні властивості або функції ви знаєте?",
        "answer": "`setTimeout()`, `console.log()`, `parseInt()`, `isNaN()`, `Math`, `JSON` - це все глобальні функції або об'єкти, доступні через глобальний об'єкт."
      }
    ]
  },
  {
    "id": "js-q2",
    "topic": "JavaScript",
    "mainQuestion": "Що таке область видимості (scope)?",
    "mainAnswer": "Область видимості (scope) — це механізм, який визначає доступність змінних, функцій та об'єктів у певній частині коду. Вона контролює, де саме в коді ви можете посилатися на ці елементи. В JavaScript існують глобальна, функціональна (Function Scope) та блокова (Block Scope) області видимості.",
    "additionalQuestions": [
      {
        "id": "js-q2-aq1",
        "question": "У чому відмінність між функціональною та блоковою областю видимості?",
        "answer": "Функціональна область видимості означає, що змінні, оголошені за допомогою `var` всередині функції, доступні лише всередині цієї функції. Блокова область видимості (для `let` та `const`) означає, що змінні доступні лише всередині блоку коду (`{}`)."
      },
      {
        "id": "js-q2-aq2",
        "question": "Що таке 'Hoisting'?",
        "answer": "'Hoisting' — це механізм JavaScript, при якому оголошення змінних (оголошених за допомогою `var`) та функцій переміщуються вгору до початку їхньої області видимості під час компіляції, що дозволяє використовувати їх до фактичного оголошення в коді."
      },
      {
        "id": "js-q2-aq3",
        "question": "Який вплив `let` та `const` на hoisting?",
        "answer": "`let` та `const` також піднімаються (hoisted), але не ініціалізуються. Вони перебувають у 'тимчасовій мертвій зоні' (Temporal Dead Zone - TDZ) від початку їхньої області видимості до фактичного оголошення, що запобігає їх використанню до оголошення і викликає помилку."
      }
    ]
  },
  {
    "id": "js-q3",
    "topic": "JavaScript",
    "mainQuestion": "У чому різниця між `var`, `let` та `const`?",
    "mainAnswer": "`var` оголошує змінні з функціональною областю видимості (або глобальною), може бути перевизначений і переоголошений. `let` оголошує змінні з блоковою областю видимості, може бути перевизначений, але не переоголошений в одній області. `const` оголошує константи з блоковою областю видимості, не може бути перевизначений чи переоголошений, його значення не змінюється (для примітивних типів), а для об'єктів — не можна перевизначити посилання, але можна змінювати властивості об'єкта.",
    "additionalQuestions": [
      {
        "id": "js-q3-aq1",
        "question": "Яку ключове слово слід використовувати за замовчуванням і чому?",
        "answer": "За замовчуванням слід використовувати `const`, якщо значення змінної не повинно змінюватися. Якщо змінна повинна бути змінена, тоді використовувати `let`. `var` слід уникати через потенційні проблеми з областю видимості та hoisting."
      },
      {
        "id": "js-q3-aq2",
        "question": "Що означає 'блокова область видимості' для `let` та `const`?",
        "answer": "Це означає, що змінні, оголошені за допомогою `let` або `const`, доступні лише в межах найближчого блоку коду (наприклад, всередині `if` statement, `for` loop, або просто `{}`)."
      },
      {
        "id": "js-q3-aq3",
        "question": "Що станеться, якщо спробувати перепризначити `const` змінну?",
        "answer": "Буде викинута помилка `TypeError: Assignment to constant variable.`"
      }
    ]
  },
  {
    "id": "js-q4",
    "topic": "JavaScript",
    "mainQuestion": "У чому різниця між функціональним виразом (function expression) та оголошенням функції (function declaration)? Який з них використовувати?",
    "mainAnswer": "Оголошення функції (Function Declaration) — це функція, оголошена як окремий оператор (`function myFunction() {}`). Вона піднімається (hoisted), тому її можна викликати до її оголошення. Функціональний вираз (Function Expression) — це функція, яка є частиною виразу, часто присвоюється змінній (`const myFunction = function() {};`). Вона не піднімається і може бути викликана лише після її оголошення. Зазвичай краще використовувати функціональні вирази (особливо стрілкові функції) для більшої передбачуваності та уникнення проблем з hoisting.",
    "additionalQuestions": [
      {
        "id": "js-q4-aq1",
        "question": "Чи можна функціональний вираз бути іменованим?",
        "answer": "Так, функціональний вираз може бути іменованим (`const func = function myName() {};`). Це ім'я буде доступне лише всередині самої функції для рекурсії або налагодження."
      },
      {
        "id": "js-q4-aq2",
        "question": "Що таке 'стрілкові функції' і до якого типу вони належать?",
        "answer": "Стрілкові функції (Arrow Functions) — це більш короткий синтаксис для функціональних виразів (`const func = () => {};`). Вони завжди є анонімними функціональними виразами і не мають власного `this`."
      },
      {
        "id": "js-q4-aq3",
        "question": "Яка перевага використання функціональних виразів у порівнянні з оголошеннями?",
        "answer": "Функціональні вирази запобігають випадковому використанню функції до її оголошення (що може бути проблемою з hoisting) і дозволяють створювати анонімні функції, що часто корисно для колбеків."
      }
    ]
  },
  {
    "id": "js-q5",
    "topic": "JavaScript",
    "mainQuestion": "Що таке лексичне оточення (lexical environment)?",
    "mainAnswer": "Лексичне оточення — це внутрішній, прихований об'єкт, пов'язаний з кожною виконаною функцією або блоком коду в JavaScript. Воно містить інформацію про змінні та функції, які визначені в поточній області видимості, а також посилання на батьківське лексичне оточення. Це те, як JavaScript визначає, які змінні доступні в певному місці коду.",
    "additionalQuestions": [
      {
        "id": "js-q5-aq1",
        "question": "Як лексичне оточення пов'язане з областю видимості?",
        "answer": "Лексичне оточення *реалізує* концепцію області видимості в JavaScript. Кожна область видимості (глобальна, функціональна, блокова) має своє власне лексичне оточення."
      },
      {
        "id": "js-q5-aq2",
        "question": "Чи змінюється лексичне оточення під час виконання коду?",
        "answer": "Ні, лексичне оточення створюється під час *парсингу* (лексичного аналізу) коду і не змінюється під час його виконання. Саме це дозволяє замиканням 'запам'ятовувати' змінні з батьківської області."
      },
      {
        "id": "js-q5-aq3",
        "question": "Що таке 'ланцюжок областей видимості' (scope chain)?",
        "answer": "'Ланцюжок областей видимості' (або 'ланцюжок лексичних оточень') — це послідовність лексичних оточень, яка дозволяє JavaScript шукати змінну: спочатку в поточному оточенні, потім у батьківському, і так далі до глобального."
      }
    ]
  },
  {
    "id": "js-q6",
    "topic": "JavaScript",
    "mainQuestion": "Що таке контекст виконання (execution context)?",
    "mainAnswer": "Контекст виконання — це абстрактна концепція, яка оточує поточний запущений код. Кожного разу, коли JavaScript-код виконується, він робиться в рамках контексту виконання. Це середовище, в якому функція або глобальний код інтерпретується. Кожен контекст виконання має свою власну область видимості (змінні, функції) та власне значення `this`.",
    "additionalQuestions": [
      {
        "id": "js-q6-aq1",
        "question": "Які типи контекстів виконання існують?",
        "answer": "Основні типи: Глобальний контекст виконання (Global Execution Context) — для коду, що знаходиться поза функціями, та Функціональний контекст виконання (Function Execution Context) — для кожної викликаної функції."
      },
      {
        "id": "js-q6-aq2",
        "question": "Що таке 'Стек викликів' (Call Stack)?",
        "answer": "'Стек викликів' — це механізм, який JavaScript-інтерпретатор використовує для відстеження активних контекстів виконання. Коли функція викликається, її контекст виконання додається до стеку, і видаляється, коли функція завершує свою роботу."
      },
      {
        "id": "js-q6-aq3",
        "question": "Які компоненти входять до контексту виконання?",
        "answer": "До контексту виконання входять: Змінна середовище (Variable Environment) — де зберігаються змінні та оголошення функцій, Лексичне середовище (Lexical Environment) — для доступу до змінних батьківського скоупу, та значення `this`."
      }
    ]
  },
  {
    "id": "js-q7",
    "topic": "JavaScript",
    "mainQuestion": "Поясніть замикання (closures).",
    "mainAnswer": "Замикання (closure) — це функція, яка 'пам'ятає' своє лексичне оточення (змінні з батьківської області видимості), навіть якщо зовнішня функція вже завершила своє виконання. Це дозволяє внутрішній функції мати доступ до змінних зовнішньої функції, що робить її дуже потужним інструментом для приховування даних та створення функцій-фабрик.",
    "additionalQuestions": [
      {
        "id": "js-q7-aq1",
        "question": "Наведіть простий приклад замикання.",
        "answer": "`function makeCounter() { let count = 0; return function() { return count++; }; } const counter = makeCounter(); console.log(counter()); // 0 console.log(counter()); // 1`"
      },
      {
        "id": "js-q7-aq2",
        "question": "Які типові сценарії використання замикань?",
        "answer": "Замикання використовуються для приховування даних (data privacy/encapsulation), створення функцій-фабрик, каррінг-функцій, реалізації паттерну 'модуль' та для колбеків в асинхронному коді."
      },
      {
        "id": "js-q7-aq3",
        "question": "Чи може замикання впливати на продуктивність або використання пам'яті?",
        "answer": "Так, оскільки замикання тримає посилання на змінні з батьківської області, це може призвести до того, що ці змінні не будуть прибрані з пам'яті 'збирачем сміття' (garbage collector) так швидко, як могли б. Однак, зазвичай це не є значною проблемою, якщо замикання використовуються розумно."
      }
    ]
  },
  {
    "id": "js-q8",
    "topic": "JavaScript",
    "mainQuestion": "Що таке `this` у JavaScript? Як воно змінює своє значення? Як воно працює зі стрілковими функціями?",
    "mainAnswer": "`this` — це ключове слово, яке посилається на об'єкт, що 'володіє' поточним кодом, або на об'єкт, з яким функція була викликана. Його значення динамічно змінюється залежно від способу виклику функції (глобальний виклик, метод об'єкта, конструктор, явне прив'язування). Стрілкові функції не мають власного `this`; вони успадковують `this` з лексичного контексту (батьківської області видимості), де вони були визначені.",
    "additionalQuestions": [
      {
        "id": "js-q8-aq1",
        "question": "Як `this` поводиться при виклику функції як методу об'єкта?",
        "answer": "Коли функція викликається як метод об'єкта (наприклад, `myObject.myMethod()`), `this` всередині `myMethod` посилається на `myObject`."
      },
      {
        "id": "js-q8-aq2",
        "question": "Що таке 'явна прив'язка' `this`?",
        "answer": "'Явна прив'язка' — це коли значення `this` встановлюється за допомогою методів `call()`, `apply()` або `bind()`."
      },
      {
        "id": "js-q8-aq3",
        "question": "Яка перевага `this` у стрілкових функціях?",
        "answer": "Основна перевага в тому, що стрілкові функції вирішують проблему втрати контексту `this` у колбеках або вкладених функціях, оскільки вони автоматично захоплюють `this` з батьківського лексичного оточення."
      }
    ]
  },
  {
    "id": "js-q9",
    "topic": "JavaScript",
    "mainQuestion": "Поясніть методи `bind`, `call`, `apply`.",
    "mainAnswer": "Ці методи дозволяють явно встановлювати значення `this` для функції. `call()` викликає функцію негайно, передаючи аргументи окремо. `apply()` викликає функцію негайно, передаючи аргументи у вигляді масиву. `bind()` створює нову функцію з прив'язаним `this` (та аргументами), але не викликає її негайно.",
    "additionalQuestions": [
      {
        "id": "js-q9-aq1",
        "question": "Коли краще використовувати `call()` або `apply()` замість `bind()`?",
        "answer": "`call()` або `apply()` краще використовувати, коли вам потрібно викликати функцію негайно з певним контекстом `this` і аргументами. `bind()` використовується, коли вам потрібна нова функція, яку ви зможете викликати пізніше з вже прив'язаним контекстом."
      },
      {
        "id": "js-q9-aq2",
        "question": "Наведіть приклад використання `bind()`.",
        "answer": "`const person = { name: 'Роман', sayHello: function() { console.log(`Привіт, ${this.name}!`); } }; const greet = person.sayHello.bind(person); setTimeout(greet, 1000); // Привіт, Роман!` (Без bind this був би window або undefined у строгому режимі)"
      },
      {
        "id": "js-q9-aq3",
        "question": "Яка головна відмінність у передачі аргументів між `call()` та `apply()`?",
        "answer": "`call()` приймає аргументи як окремі значення (після першого аргументу `thisArg`), тоді як `apply()` приймає аргументи як один масив."
      }
    ]
  },
  {
    "id": "js-q10",
    "topic": "JavaScript",
    "mainQuestion": "Що таке прототип? Поясніть, як працює успадкування в JavaScript?",
    "mainAnswer": "Прототип (prototype) — це об'єкт, до якого JavaScript-об'єкт звертається для успадкування властивостей та методів. Кожен об'єкт в JavaScript має приховане внутрішнє посилання на свій прототип (property `[[Prototype]]`). Успадкування в JavaScript працює через 'прототипний ланцюжок' (prototype chain): коли ви намагаєтеся отримати доступ до властивості об'єкта, а його немає безпосередньо в ньому, JavaScript шукає його в прототипі цього об'єкта, потім у прототипі прототипу, і так далі, доки не знайде властивість або не дійде до `null`.",
    "additionalQuestions": [
      {
        "id": "js-q10-aq1",
        "question": "Як отримати доступ до прототипу об'єкта?",
        "answer": "Доступ можна отримати за допомогою `Object.getPrototypeOf(obj)`, `obj.__proto__` (застаріло, але часто використовується) або `obj.constructor.prototype`."
      },
      {
        "id": "js-q10-aq2",
        "question": "Як створити об'єкт з певним прототипом?",
        "answer": "Можна використовувати `Object.create(protoObject)` або синтаксис класів (`class Child extends Parent {}`) який є синтаксичним цукром над прототипним успадкуванням."
      },
      {
        "id": "js-q10-aq3",
        "question": "Чи є різниця між прототипним та класичним успадкуванням?",
        "answer": "JavaScript використовує прототипне успадкування (поведінкове делегування), тоді як багато інших мов використовують класичне (базоване на класах). Класи в JavaScript (ES6 `class`) — це синтаксичний цукор над існуючою прототипною моделлю успадкування."
      }
    ]
  },
  {
    "id": "js-q11",
    "topic": "JavaScript",
    "mainQuestion": "Поясніть `async`/`await` та Проміси (Promises).",
    "mainAnswer": "Проміси (`Promise`) — це об'єкти, які представляють результат асинхронної операції: успішне завершення (`resolve`) або помилку (`reject`). Вони дозволяють уникнути 'callback hell' (пекла колбеків). `async`/`await` — це синтаксичний цукор (syntactic sugar) над Промісами, який дозволяє писати асинхронний код у більш синхронному, читабельному стилі. Функція, позначена як `async`, завжди повертає Проміс, а оператор `await` 'чекає' на виконання Промісу перед продовженням виконання коду.",
    "additionalQuestions": [
      {
        "id": "js-q11-aq1",
        "question": "Які стани може мати Проміс?",
        "answer": "Проміс може перебувати в трьох станах: `pending` (очікування), `fulfilled` (виконано успішно) та `rejected` (відхилено з помилкою)."
      },
      {
        "id": "js-q11-aq2",
        "question": "Як обробляти помилки в `async`/`await`?",
        "answer": "Помилки в `async`/`await` обробляються за допомогою конструкції `try...catch`, аналогічно синхронному коду."
      },
      {
        "id": "js-q11-aq3",
        "question": "У чому перевага `async`/`await` над ланцюжками `.then()`?",
        "answer": "`async`/`await` робить асинхронний код більш читабельним, схожим на синхронний, дозволяє легше обробляти помилки за допомогою `try...catch` і спрощує налагодження, оскільки стек викликів виглядає більш звично."
      }
    ]
  },
  {
    "id": "js-q12",
    "topic": "JavaScript",
    "mainQuestion": "Що таке Event Loop? Поясніть його.",
    "mainAnswer": "Event Loop (цикл подій) — це фундаментальна частина архітектури виконання JavaScript, яка дозволяє JavaScript (однопотоковому за своєю природою) обробляти асинхронні операції. Він постійно перевіряє чергу колбеків (callback queue) та стек викликів (call stack). Якщо стек викликів порожній (тобто немає синхронного коду, що виконується), Event Loop переміщує першу функцію з черги колбеків у стек викликів для виконання.",
    "additionalQuestions": [
      {
        "id": "js-q12-aq1",
        "question": "Які компоненти складають середовище виконання JavaScript, крім Call Stack та Heap?",
        "answer": "Крім Call Stack (стек викликів) та Heap (купа, де зберігаються об'єкти), ключовими компонентами є Web APIs (для браузера), Callback Queue (черга колбеків) та Event Loop."
      },
      {
        "id": "js-q12-aq2",
        "question": "Як Web APIs взаємодіють з Event Loop?",
        "answer": "Web APIs (наприклад, `setTimeout`, `fetch`, DOM події) виконують асинхронні операції. Після їх завершення, їхні колбеки поміщаються в Callback Queue, звідки Event Loop їх переміщує до Call Stack."
      },
      {
        "id": "js-q12-aq3",
        "question": "Що таке 'Microtask Queue' та як вона пов'язана з Event Loop?",
        "answer": "'Microtask Queue' (черга мікрозавдань) — це окрема черга, яка має вищий пріоритет, ніж звичайна Callback Queue. Проміси, `queueMicrotask` та `MutationObserver` додають завдання до Microtask Queue. Event Loop спочатку обробляє всі завдання з Microtask Queue, а потім переходить до Callback Queue."
      }
    ]
  },
  {
    "id": "js-q13",
    "topic": "JavaScript",
    "mainQuestion": "Які типи даних JS ви знаєте? Як перевірити тип змінної?",
    "mainAnswer": "У JavaScript існує 8 типів даних: **Примітивні:** `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`. **Непримітивні:** `object` (включаючи функції та масиви). Тип змінної можна перевірити за допомогою оператора `typeof` (для примітивів та функцій) або `instanceof` (для об'єктів та класів). Для `null` `typeof` повертає `'object'` (це відома помилка).",
    "additionalQuestions": [
      {
        "id": "js-q13-aq1",
        "question": "У чому відмінність між `null` та `undefined`?",
        "answer": "`undefined` означає, що змінна була оголошена, але їй не було присвоєно значення, або властивість відсутня. `null` означає навмисну відсутність будь-якого об'єктного значення, тобто змінній явно присвоєно 'нічого'."
      },
      {
        "id": "js-q13-aq2",
        "question": "Чому `typeof null` повертає 'object'?",
        "answer": "Це є відомою історичною помилкою в JavaScript, яка збереглася для сумісності. Внутрішньо `null` представлений як нульовий вказівник, і `typeof` помилково інтерпретує його як об'єкт."
      },
      {
        "id": "js-q13-aq3",
        "question": "Як перевірити, чи є змінна масивом?",
        "answer": "Найкращий спосіб — `Array.isArray(variable)`. Також можна використовувати `variable instanceof Array`, але це може дати некоректний результат у багатофреймових середовищах."
      }
    ]
  },
  {
    "id": "js-q14",
    "topic": "JavaScript",
    "mainQuestion": "Що таке строге та нестроге порівняння в JS? У чому їх різниця?",
    "mainAnswer": "Нестроге порівняння (`==`) перевіряє лише значення, допускаючи неявне приведення типів (type coercion) перед порівнянням. Наприклад, `5 == '5'` поверне `true`. Строге порівняння (`===`) перевіряє як значення, так і тип даних, не виконуючи приведення типів. Наприклад, `5 === '5'` поверне `false`. Завжди рекомендується використовувати строге порівняння (`===`) для уникнення неочікуваної поведінки та потенційних помилок.",
    "additionalQuestions": [
      {
        "id": "js-q14-aq1",
        "question": "Наведіть приклад, де нестроге порівняння може призвести до неочікуваних результатів.",
        "answer": "`false == 0` поверне `true`; `'' == 0` поверне `true`; `null == undefined` поверне `true`. Це може спричинити логічні помилки."
      },
      {
        "id": "js-q14-aq2",
        "question": "Чи є випадки, коли нестроге порівняння допустиме?",
        "answer": "Дуже рідко, і зазвичай тільки для перевірки на `null` та `undefined` одночасно (`value == null`), оскільки `null == undefined` є `true`. Але навіть у цьому випадку `value === null || value === undefined` є більш явним."
      },
      {
        "id": "js-q14-aq3",
        "question": "Яке порівняння використовується для об'єктів?",
        "answer": "Для об'єктів (включаючи масиви та функції), як `==`, так і `===` перевіряють, чи посилаються обидві змінні на один і той же об'єкт у пам'яті, а не чи є їхній вміст однаковим. Тобто `[] == []` і `[] === []` обидва повернуть `false`."
      }
    ]
  },
  {
    "id": "js-q15",
    "topic": "JavaScript",
    "mainQuestion": "Що таке тернарний оператор? Коли його доцільно використовувати, а коли ні?",
    "mainAnswer": "Тернарний оператор (`condition ? exprIfTrue : exprIfFalse`) — це скорочена форма умовного оператора `if...else`. Він повертає значення `exprIfTrue`, якщо `condition` є істинним, і `exprIfFalse` в іншому випадку. Доцільно використовувати для простих, коротких умов, що присвоюють значення змінній або повертають його. Не варто використовувати для складних логічних блоків або кількох вкладених умов, оскільки це погіршує читабельність.",
    "additionalQuestions": [
      {
        "id": "js-q15-aq1",
        "question": "Наведіть приклад використання тернарного оператора.",
        "answer": "`const age = 20; const status = age >= 18 ? 'Дорослий' : 'Неповнолітній'; console.log(status); // Дорослий`"
      },
      {
        "id": "js-q15-aq2",
        "question": "Чи можна вкладати тернарні оператори?",
        "answer": "Так, можна, але це швидко робить код важким для читання і розуміння, тому це не рекомендується."
      },
      {
        "id": "js-q15-aq3",
        "question": "У чому головна відмінність тернарного оператора від `if...else`?",
        "answer": "Тернарний оператор є *виразом* (expression) і повертає значення, тоді як `if...else` є *оператором* (statement) і не повертає значення (хоча може виконувати код)."
      }
    ]
  },
  {
    "id": "js-q16",
    "topic": "JavaScript",
    "mainQuestion": "Які логічні оператори ви знаєте? Який результат вони повертають?",
    "mainAnswer": "В JavaScript є три основні логічні оператори: **AND (`&&`)**: повертає перше `falsy` значення або останнє `truthy` значення. **OR (`||`)**: повертає перше `truthy` значення або останнє `falsy` значення. **NOT (`!`)**: перетворює операнд на булеве значення і повертає його протилежне значення (`true` стає `false`, `false` стає `true`).",
    "additionalQuestions": [
      {
        "id": "js-q16-aq1",
        "question": "Що таке 'коротке замикання' (short-circuiting) у логічних операторах?",
        "answer": "'Коротке замикання' означає, що логічні оператори (`&&` та `||`) обчислюють операнди зліва направо і припиняють обчислення, як тільки результат стає очевидним. Наприклад, у `a && b`, якщо `a` є `false`, `b` не обчислюється."
      },
      {
        "id": "js-q16-aq2",
        "question": "Які значення є 'falsy' у JavaScript?",
        "answer": "Значення, які при приведенні до булевого типу стають `false`: `false`, `0`, `-0`, `null`, `undefined`, `NaN`, `''` (порожній рядок)."
      },
      {
        "id": "js-q16-aq3",
        "question": "Для чого може використовуватися оператор `||` (OR) крім логічних перевірок?",
        "answer": "Оператор `||` часто використовується для встановлення значень за замовчуванням: `const value = someVariable || 'default_value';`."
      }
    ]
  },
  {
    "id": "js-q17",
    "topic": "JavaScript",
    "mainQuestion": "Які види JS циклів ви знаєте? У яких сценаріях найкраще використовувати кожен з них?",
    "mainAnswer": "Основні види циклів: **`for`**: для ітерації, коли відома кількість повторень або потрібен доступ до індексу. **`while`**: коли умова перевіряється перед кожним виконанням циклу. **`do...while`**: коли потрібно виконати тіло циклу хоча б один раз, потім перевірити умову. **`for...in`**: для ітерації по перелічуваних властивостях об'єкта (не рекомендується для масивів). **`for...of`**: для ітерації по ітерованих об'єктах (масиви, рядки, Map, Set). **`forEach`**: метод масиву для ітерації по елементах масиву (не переривається).",
    "additionalQuestions": [
      {
        "id": "js-q17-aq1",
        "question": "Чому не рекомендується використовувати `for...in` для ітерації по масивах?",
        "answer": "`for...in` ітерує по ключах (індексах) і властивостях об'єкта, а не по елементах. Він також ітерує по успадкованих властивостях, що може призвести до неочікуваних результатів. Для масивів краще використовувати `for`, `for...of` або `forEach`."
      },
      {
        "id": "js-q17-aq2",
        "question": "Коли `for...of` кращий за `forEach`?",
        "answer": "`for...of` дозволяє використовувати `break`, `continue` та `return` (якщо він знаходиться у функції), що недоступно у `forEach`. Також `for...of` працює з будь-якими ітерованими об'єктами, не лише масивами."
      },
      {
        "id": "js-q17-aq3",
        "question": "Які ще ітераційні методи для масивів ви знаєте, крім `forEach`?",
        "answer": "Також існують `map`, `filter`, `reduce`, `some`, `every`, `find`, `findIndex`, які є більш функціональними та часто кращими для конкретних завдань, ніж загальні цикли."
      }
    ]
  },
  {
    "id": "js-q18",
    "topic": "JavaScript",
    "mainQuestion": "Назвіть кілька способів округлення числа в JavaScript.",
    "mainAnswer": "В JavaScript є кілька вбудованих методів для округлення чисел: `Math.round()` (до найближчого цілого, .5 вгору), `Math.floor()` (до найменшого цілого, округлення вниз), `Math.ceil()` (до найбільшого цілого, округлення вгору), `Math.trunc()` (відкидає дробову частину). Також можна використовувати `toFixed()` для округлення до певної кількості знаків після коми, але він повертає рядок.",
    "additionalQuestions": [
      {
        "id": "js-q18-aq1",
        "question": "Який метод `Math` округлює число до найближчого цілого?",
        "answer": "`Math.round()`."
      },
      {
        "id": "js-q18-aq2",
        "question": "Якщо потрібно округлити число до двох знаків після коми, який метод використовувати?",
        "answer": "`number.toFixed(2)` поверне рядок. Якщо потрібне число, то потрібно буде привести його до числа, наприклад, `parseFloat(number.toFixed(2))` або `+number.toFixed(2)`."
      },
      {
        "id": "js-q18-aq3",
        "question": "Яка поведінка `Math.trunc()` з від'ємними числами?",
        "answer": "`Math.trunc()` просто відкидає дробову частину, не виконуючи округлення. Наприклад, `Math.trunc(-4.7)` поверне `-4` (на відміну від `Math.floor(-4.7)`, який поверне `-5`)."
      }
    ]
  },
  {
    "id": "js-q19",
    "topic": "JavaScript",
    "mainQuestion": "Як перетворити числове значення на рядок і навпаки? Коли таке перетворення може знадобитися?",
    "mainAnswer": "**Число в рядок:** 1. `String(number)` (конструктор). 2. `number.toString()` (метод). 3. Конкатенація з порожнім рядком: `number + ''`. **Рядок у число:** 1. `Number(string)` (конструктор). 2. `parseInt(string)` (для цілих чисел). 3. `parseFloat(string)` (для чисел з плаваючою комою). 4. Унарний плюс: `+string`. Перетворення корисне, коли потрібно працювати з даними, отриманими з форм (завжди рядки), або при виконанні математичних операцій, або для відображення чисел як текст.",
    "additionalQuestions": [
      {
        "id": "js-q19-aq1",
        "question": "Яка різниця між `parseInt()` та `Number()` при перетворенні рядка у число?",
        "answer": "`parseInt()` парсить рядок до першого нечислового символу і повертає ціле число. `Number()` намагається перетворити *весь* рядок на число; якщо весь рядок не є дійсним числом, він повертає `NaN`."
      },
      {
        "id": "js-q19-aq2",
        "question": "Коли `Number(string)` може повернути `NaN`?",
        "answer": "`Number(string)` поверне `NaN` (Not a Number), якщо рядок містить будь-які нечислові символи, крім, можливо, пробілів на початку/в кінці, або якщо рядок порожній."
      },
      {
        "id": "js-q19-aq3",
        "question": "Наведіть сценарій, коли перетворення 'число в рядок' є необхідним.",
        "answer": "Коли потрібно відобразити число в HTML-елементі або об'єднати його з іншими рядками (наприклад, `id` елемента, номер телефону, ціна)."
      }
    ]
  },
  {
    "id": "js-q20",
    "topic": "JavaScript",
    "mainQuestion": "Як можна ітерувати по символах рядка в JavaScript?",
    "mainAnswer": "Існує кілька способів ітерації по символах рядка: 1. **Цикл `for`**: традиційний підхід з використанням індексів. 2. **`for...of`**: сучасний і рекомендований спосіб, який ітерує по символах (включаючи Unicode). 3. **`String.prototype[Symbol.iterator]()`**: для ручного використання ітератора. 4. **`Array.from(string)`**: перетворення рядка на масив символів, а потім ітерація по масиву. 5. **`split('')` + `forEach`**: розбиття рядка на масив символів і використання `forEach`.",
    "additionalQuestions": [
      {
        "id": "js-q20-aq1",
        "question": "Який метод найкращий для роботи з Unicode-символами (наприклад, емодзі)?",
        "answer": "`for...of` є найкращим, оскільки він коректно ітерує по кодових точках Unicode, на відміну від звичайного `for` циклу, який може розбивати сурогатні пари."
      },
      {
        "id": "js-q20-aq2",
        "question": "Чи можна використовувати `for...in` для ітерації по рядку?",
        "answer": "Так, `for...in` буде ітерувати по індексах рядка, але це не рекомендований спосіб, оскільки він ітерує по всіх перелічуваних властивостях об'єкта (включаючи потенційно успадковані), а не лише по символах."
      },
      {
        "id": "js-q20-aq3",
        "question": "Наведіть приклад використання `for...of` для рядка.",
        "answer": "`const str = 'Привіт 👋'; for (const char of str) { console.log(char); } // Виведе: П, р, и, в, і, т, 👋 (один за одним)`"
      }
    ]
  },
  {
    "id": "js-q21",
    "topic": "JavaScript",
    "mainQuestion": "Який найкращий спосіб перевірити, чи містить рядок заданий підрядок у JavaScript? А що, якщо потрібна позиція підрядка?",
    "mainAnswer": "Найкращий спосіб перевірити, чи містить рядок підрядок, — це використовувати метод `String.prototype.includes()`. Він повертає `true`, якщо підрядок знайдено, і `false` в іншому випадку. Якщо потрібна позиція (індекс) першого входження підрядка, використовуйте метод `String.prototype.indexOf()`. Він повертає індекс, з якого починається підрядок, або `-1`, якщо підрядок не знайдено.",
    "additionalQuestions": [
      {
        "id": "js-q21-aq1",
        "question": "Чи чутливі `includes()` та `indexOf()` до регістру?",
        "answer": "Так, обидва методи чутливі до регістру. Якщо вам потрібен регістронезалежний пошук, слід привести рядок і підрядок до одного регістру (наприклад, `toLowerCase()`) перед пошуком."
      },
      {
        "id": "js-q21-aq2",
        "question": "Які інші методи можна використовувати для перевірки підрядка?",
        "answer": "Можна використовувати `String.prototype.search()` з регулярними виразами або `String.prototype.match()`."
      },
      {
        "id": "js-q21-aq3",
        "question": "Як знайти останнє входження підрядка?",
        "answer": "Для цього використовується метод `String.prototype.lastIndexOf()`, який повертає індекс останнього входження підрядка або `-1`, якщо не знайдено."
      }
    ]
  },
  {
    "id": "js-q22",
    "topic": "JavaScript",
    "mainQuestion": "Як видалити пробіли на початку та в кінці рядка? Як би ви реалізували додавання кількох пробілів на початку рядка, щоб рядок набув заданої довжини?",
    "mainAnswer": "Для видалення пробілів на початку та в кінці рядка використовується метод `String.prototype.trim()`. Він повертає новий рядок. Для додавання пробілів на початку рядка до заданої довжини можна використовувати метод `String.prototype.padStart(targetLength, padString)`. Наприклад, `myString.padStart(10, ' ')` додасть пробіли на початку, щоб загальна довжина стала 10 символів.",
    "additionalQuestions": [
      {
        "id": "js-q22-aq1",
        "question": "Які методи `trim()` є крім `trim()`?",
        "answer": "Є також `trimStart()` (або `trimLeft()`) для видалення пробілів тільки на початку та `trimEnd()` (або `trimRight()`) для видалення пробілів тільки в кінці."
      },
      {
        "id": "js-q22-aq2",
        "question": "Що повертають методи `trim()` та `padStart()`?",
        "answer": "Обидва методи повертають *новий* рядок. Оригінальний рядок залишається незмінним, оскільки рядки в JavaScript є незмінними (immutable)."
      },
      {
        "id": "js-q22-aq3",
        "question": "Як би ви реалізували `padStart` без використання вбудованого методу?",
        "answer": "Можна обчислити кількість необхідних пробілів: `const numSpaces = targetLength - originalString.length;` потім створити рядок з цими пробілами (наприклад, за допомогою ` ' '.repeat(numSpaces) `) і додати його до оригінального рядка."
      }
    ]
  },
  {
    "id": "js-q23",
    "topic": "JavaScript",
    "mainQuestion": "Що таке об'єкт? Як отримати доступ до властивостей об'єкта?",
    "mainAnswer": "Об'єкт у JavaScript — це колекція властивостей, де кожна властивість складається з пари 'ключ-значення'. Ключі (імена властивостей) є рядками (або символами), а значення можуть бути будь-яким типом даних, включаючи інші об'єкти або функції. Доступ до властивостей об'єкта можна отримати двома основними способами: **за допомогою крапкової нотації (`object.property`)** — якщо ім'я властивості відоме заздалегідь і є валідним ідентифікатором, та **за допомогою дужкової нотації (`object['property']`)** — якщо ім'я властивості є змінною, містить спеціальні символи або є числом.",
    "additionalQuestions": [
      {
        "id": "js-q23-aq1",
        "question": "Коли варто використовувати дужкову нотацію замість крапкової?",
        "answer": "Дужкову нотацію слід використовувати, коли ім'я властивості динамічно генерується (змінна), містить пробіли, дефіси або інші спеціальні символи, або є числом."
      },
      {
        "id": "js-q23-aq2",
        "question": "Чи можна використовувати змінні як ключі властивостей об'єкта при створенні об'єкта?",
        "answer": "Так, починаючи з ES6, можна використовувати обчислювані імена властивостей за допомогою квадратних дужок: `const key = 'name'; const obj = { [key]: 'Роман' };`."
      },
      {
        "id": "js-q23-aq3",
        "question": "Чи існує порядок властивостей в об'єкті?",
        "answer": "До ES2015 порядок властивостей не гарантувався. З ES2015 та пізніше, об'єкти зберігають порядок вставки числових властивостей, потім строкових властивостей у порядку їх створення, і нарешті, символьних властивостей."
      }
    ]
  },
  {
    "id": "js-q24",
    "topic": "JavaScript",
    "mainQuestion": "Як перевірити, чи має об'єкт певну властивість?",
    "mainAnswer": "Для перевірки наявності властивості в об'єкті є кілька способів: **`in` оператор**: `propertyName in object` перевіряє, чи має об'єкт або його ланцюжок прототипів зазначену властивість. **`Object.prototype.hasOwnProperty()`**: `object.hasOwnProperty(propertyName)` перевіряє, чи є властивість безпосередньо власною властивістю об'єкта, а не успадкованою. **Доступ до властивості**: `object.property !== undefined` або просто `object.property` (якщо значення не може бути `undefined`).",
    "additionalQuestions": [
      {
        "id": "js-q24-aq1",
        "question": "Яка головна відмінність між оператором `in` та `hasOwnProperty()`?",
        "answer": "Оператор `in` перевіряє наявність властивості як у самому об'єкті, так і в його прототипному ланцюжку. `hasOwnProperty()` перевіряє лише, чи є властивість *безпосередньо* власною властивістю об'єкта."
      },
      {
        "id": "js-q24-aq2",
        "question": "Коли використання `object.property !== undefined` може бути ненадійним?",
        "answer": "Цей метод ненадійний, якщо властивість дійсно існує на об'єкті, але її значення навмисно встановлено на `undefined`. У таких випадках `in` або `hasOwnProperty()` є більш точними."
      },
      {
        "id": "js-q24-aq3",
        "question": "Чи можна використовувати `object[propertyName]` для перевірки наявності властивості?",
        "answer": "Так, але це те саме, що `object.property !== undefined`, і має ті ж обмеження. Якщо властивість існує, але має значення `undefined`, це поверне `false` (якщо не порівнювати з `undefined`), що може бути помилковим."
      }
    ]
  },
  {
    "id": "js-q25",
    "topic": "JavaScript",
    "mainQuestion": "Як видалити властивість з об'єкта?",
    "mainAnswer": "Для видалення властивості з об'єкта використовується оператор `delete`. Наприклад, `delete myObject.propertyName;` або `delete myObject['propertyName'];`. Цей оператор видаляє властивість з об'єкта і повертає `true`, якщо видалення було успішним або якщо властивість не існувала. Якщо властивість не може бути видалена (наприклад, якщо вона неконфігурована), `delete` поверне `false`.",
    "additionalQuestions": [
      {
        "id": "js-q25-aq1",
        "question": "Що станеться, якщо спробувати видалити успадковану властивість за допомогою `delete`?",
        "answer": "`delete` оператор видаляє лише власні (own) властивості об'єкта. Він не може видалити успадковані властивості. Якщо ви спробуєте видалити успадковану властивість, він поверне `true`, але властивість залишиться в прототипному ланцюжку."
      },
      {
        "id": "js-q25-aq2",
        "question": "Чи можна просто встановити властивість у `null` або `undefined` замість видалення?",
        "answer": "Так, можна, але це не те саме, що видалення. Властивість все ще буде існувати на об'єкті з її значенням `null` або `undefined`, що може вплинути на ітерацію по властивостях або на перевірки `in`."
      },
      {
        "id": "js-q25-aq3",
        "question": "Що таке 'конфігуровані' (configurable) властивості?",
        "answer": "Властивість вважається 'конфігурованою', якщо її можна видалити за допомогою `delete` оператора, а також якщо її дескриптор властивості може бути змінений. За замовчуванням, властивості, створені звичайним способом, є конфігурованими."
      }
    ]
  },
  {
    "id": "js-q26",
    "topic": "JavaScript",
    "mainQuestion": "Як можна ітерувати по властивостях об'єкта?",
    "mainAnswer": "Для ітерації по власних, перелічуваних властивостях об'єкта (не включаючи успадковані) використовуються: **`for...in` цикл**: ітерує по ключах (іменах властивостей), включаючи успадковані перелічувані. Зазвичай комбінується з `hasOwnProperty()`. **`Object.keys(obj)`**: повертає масив імен власних, перелічуваних рядкових властивостей об'єкта. **`Object.values(obj)`**: повертає масив значень власних, перелічуваних рядкових властивостей. **`Object.entries(obj)`**: повертає масив пар `[key, value]` для власних, перелічуваних рядкових властивостей.",
    "additionalQuestions": [
      {
        "id": "js-q26-aq1",
        "question": "Коли `for...in` може бути проблематичним?",
        "answer": "`for...in` може бути проблематичним, оскільки він ітерує також по успадкованих перелічуваних властивостях. Це може призвести до непередбачуваної поведінки, якщо не використовувати `hasOwnProperty()` для фільтрації."
      },
      {
        "id": "js-q26-aq2",
        "question": "Якщо потрібно ітерувати по ключах і значеннях одночасно, який метод найкраще використовувати?",
        "answer": "`Object.entries(obj)` у поєднанні з `for...of` циклом (`for (const [key, value] of Object.entries(obj))`) є найзручнішим способом для цього."
      },
      {
        "id": "js-q26-aq3",
        "question": "Чи ітерують `Object.keys()`, `Object.values()`, `Object.entries()` по символьних властивостях?",
        "answer": "Ні, ці методи ігнорують властивості, ключами яких є `Symbol`. Для доступу до символьних ключів використовується `Object.getOwnPropertySymbols(obj)`."
      }
    ]
  },
  {
    "id": "js-q27",
    "topic": "JavaScript",
    "mainQuestion": "Що таке геттери (getters) та сеттери (setters)?",
    "mainAnswer": "Геттери та сеттери — це спеціальні методи об'єкта, які дозволяють визначати функції, що виконуються при спробі отримати або встановити значення властивості. **Геттер** (`get`) — це метод, який виконується, коли ви намагаєтеся *отримати* значення властивості. **Сеттер** (`set`) — це метод, який виконується, коли ви намагаєтеся *встановити* значення властивості. Вони дозволяють контролювати доступ до властивостей і виконувати додаткову логіку (наприклад, валідацію, обчислення) при роботі з ними.",
    "additionalQuestions": [
      {
        "id": "js-q27-aq1",
        "question": "Наведіть приклад використання геттера.",
        "answer": "`const person = { firstName: 'Іван', lastName: 'Петров', get fullName() { return `${this.firstName} ${this.lastName}`; } }; console.log(person.fullName); // Іван Петров`"
      },
      {
        "id": "js-q27-aq2",
        "question": "Коли варто використовувати сеттер?",
        "answer": "Сеттери корисні для валідації вхідних даних, виконання побічних ефектів при присвоєнні, або для трансформації даних перед їх зберіганням. Наприклад, для перетворення імені в нижній регістр."
      },
      {
        "id": "js-q27-aq3",
        "question": "Яка перевага геттерів/сеттерів над звичайними функціями?",
        "answer": "Вони дозволяють взаємодіяти з властивістю як зі звичайною змінною (`obj.prop = value;` або `obj.prop;`), приховуючи складну логіку всередині, що робить код більш інтуїтивно зрозумілим і чистим."
      }
    ]
  },
  {
    "id": "js-q28",
    "topic": "JavaScript",
    "mainQuestion": "Що таке масив (array)? Як можна ітерувати по елементах масиву?",
    "mainAnswer": "Масив у JavaScript — це впорядкована колекція елементів. Це особливий тип об'єкта, де елементи зберігаються за числовими індексами, починаючи з `0`. Ітерувати по елементах масиву можна кількома способами: **`for` цикл**: класичний підхід з індексами. **`for...of`**: сучасний, рекомендований спосіб, що працює з будь-якими ітерованими об'єктами. **`forEach()` метод**: вбудований метод масиву для виконання функції для кожного елемента (не переривається). **`map()`, `filter()`, `reduce()` та інші методи**: для трансформації, фільтрації або агрегації елементів, які також ітерують по масиву.",
    "additionalQuestions": [
      {
        "id": "js-q28-aq1",
        "question": "Чи можуть масиви в JavaScript містити елементи різних типів?",
        "answer": "Так, масиви в JavaScript можуть містити елементи будь-яких типів даних: числа, рядки, булеві, об'єкти, інші масиви тощо."
      },
      {
        "id": "js-q28-aq2",
        "question": "Яка різниця між `for` циклом і `forEach()`?",
        "answer": "`for` цикл дозволяє контролювати ітерацію за допомогою `break` та `continue`, а `forEach()` — ні. `forEach()` є методом масиву, тоді як `for` — це загальна керуюча структура циклу."
      },
      {
        "id": "js-q28-aq3",
        "question": "Яка довжина масиву з 5 елементів?",
        "answer": "Довжина масиву з 5 елементів буде 5. Властивість `length` масиву повертає кількість елементів у ньому."
      }
    ]
  },
  {
    "id": "js-q29",
    "topic": "JavaScript",
    "mainQuestion": "Які методи для додавання та видалення елементів з масиву ви пам'ятаєте? Як вони працюють?",
    "mainAnswer": "Основні методи: **Додавання:** `push()` додає один або більше елементів в кінець масиву і повертає нову довжину. `unshift()` додає один або більше елементів на початок масиву і повертає нову довжину. **Видалення:** `pop()` видаляє *останній* елемент з масиву і повертає його. `shift()` видаляє *перший* елемент з масиву і повертає його. **Універсальні:** `splice()` може додавати/видаляти елементи з будь-якої позиції. `slice()` створює новий масив з вибраних елементів (не змінює оригінал).",
    "additionalQuestions": [
      {
        "id": "js-q29-aq1",
        "question": "Які з цих методів змінюють оригінальний масив, а які створюють новий?",
        "answer": "`push()`, `pop()`, `unshift()`, `shift()`, `splice()` змінюють оригінальний масив. `slice()` створює новий масив."
      },
      {
        "id": "js-q29-aq2",
        "question": "Як додати елемент в середину масиву?",
        "answer": "Використовуйте `splice()`. Наприклад, `arr.splice(index, 0, element)` додасть `element` на `index` без видалення інших елементів."
      },
      {
        "id": "js-q29-aq3",
        "question": "Для чого може бути корисний `concat()`?",
        "answer": "`concat()` використовується для об'єднання двох або більше масивів. Він створює новий масив, що містить елементи всіх об'єднаних масивів, не змінюючи оригінальні."
      }
    ]
  },
  {
    "id": "js-q30",
    "topic": "JavaScript",
    "mainQuestion": "Які методи для пошуку в масиві ви пам'ятаєте? Як вони працюють?",
    "mainAnswer": "Ключові методи для пошуку: **`indexOf()`**: повертає індекс першого входження вказаного елемента, або `-1`, якщо його немає. **`lastIndexOf()`**: повертає індекс останнього входження елемента, або `-1`. **`includes()`**: повертає `true`, якщо масив містить вказаний елемент, і `false` в іншому випадку. **`find()`**: повертає *перший* елемент в масиві, який задовольняє умові, наданій функцією зворотного виклику, або `undefined`. **`findIndex()`**: повертає *індекс* першого елемента, який задовольняє умові, або `-1`.",
    "additionalQuestions": [
      {
        "id": "js-q30-aq1",
        "question": "Яка головна перевага `find()` та `findIndex()` над `indexOf()`?",
        "answer": "`find()` та `findIndex()` дозволяють шукати елементи за складною умовою (функцією зворотного виклику), а не лише за точним значенням, що робить їх набагато гнучкішими."
      },
      {
        "id": "js-q30-aq2",
        "question": "Чи можна використовувати `includes()` для пошуку об'єктів у масиві?",
        "answer": "Так, але `includes()` перевіряє за посиланням, тобто він знайде об'єкт, тільки якщо це *той самий об'єкт* у пам'яті, а не об'єкт з однаковим вмістом."
      },
      {
        "id": "js-q30-aq3",
        "question": "Якщо потрібно отримати всі елементи, що відповідають певній умові, який метод використовувати?",
        "answer": "Для цього використовується метод `filter()`, який повертає новий масив, що містить всі елементи, які пройшли перевірку умовою функції зворотного виклику."
      }
    ]
  },
  {
    "id": "js-q31",
    "topic": "JavaScript",
    "mainQuestion": "Як працюють наступні методи масивів: `filter`, `map`, `some`, `every`, `reduce`?",
    "mainAnswer": "Це високорівневі методи масивів для функціональної обробки даних: \n- **`filter()`**: Створює **новий масив**, що містить лише ті елементи оригінального масиву, для яких функція зворотного виклику повертає `true`. \n- **`map()`**: Створює **новий масив**, застосовуючи функцію зворотного виклику до кожного елемента оригінального масиву та збираючи результати. \n- **`some()`**: Перевіряє, чи хоча б **один елемент** масиву задовольняє умові, наданій функцією зворотного виклику. Повертає `true` або `false`. Зупиняється при першому `true`. \n- **`every()`**: Перевіряє, чи **всі елементи** масиву задовольняють умові. Повертає `true` або `false`. Зупиняється при першому `false`. \n- **`reduce()`**: Застосовує функцію 'редуктора' до кожного елемента масиву (зліва направо), щоб звести весь масив до **одного значення** (наприклад, сума, середнє, агрегований об'єкт).",
    "additionalQuestions": [
      {
        "id": "js-q31-aq1",
        "question": "Які з цих методів змінюють оригінальний масив?",
        "answer": "Жоден з цих методів (`filter`, `map`, `some`, `every`, `reduce`) не змінює оригінальний масив. Вони створюють нові масиви або повертають окремі значення."
      },
      {
        "id": "js-q31-aq2",
        "question": "Наведіть приклад використання `reduce()` для обчислення суми елементів масиву.",
        "answer": "`const numbers = [1, 2, 3, 4]; const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0); // sum буде 10`"
      },
      {
        "id": "js-q31-aq3",
        "question": "Коли варто використовувати `some()` замість `filter()`?",
        "answer": "`some()` використовується, коли вам потрібно лише знати, чи існує хоча б один елемент, що відповідає умові, і вам не потрібен новий масив з цих елементів. `filter()` потрібен, коли вам потрібні всі елементи, що відповідають умові."
      }
    ]
  },
  {
    "id": "js-q32",
    "topic": "JavaScript",
    "mainQuestion": "Як би ви відсортували масив за власною характеристикою його елементів?",
    "mainAnswer": "Для сортування масиву за власною характеристикою використовується метод масиву **`sort()`** разом із функцією порівняння. Ця функція приймає два аргументи (`a`, `b`) і повинна повертати: \n- Від'ємне число, якщо `a` має бути перед `b` \n- Додатне число, якщо `a` має бути після `b` \n- `0`, якщо порядок не має значення (або вони рівні). \nНаприклад, для сортування масиву об'єктів за властивістю `age`: `arr.sort((a, b) => a.age - b.age);` (для сортування за зростанням).",
    "additionalQuestions": [
      {
        "id": "js-q32-aq1",
        "question": "Чи змінює метод `sort()` оригінальний масив?",
        "answer": "Так, метод `sort()` змінює оригінальний масив. Якщо вам потрібен відсортований масив, але оригінальний має залишитися незмінним, спочатку створіть копію масиву (наприклад, за допомогою `slice()` або оператора `...spread`), а потім застосуйте `sort()` до копії."
      },
      {
        "id": "js-q32-aq2",
        "question": "Як відсортувати масив рядків у порядку спадання (від Z до A)?",
        "answer": "`arr.sort((a, b) => b.localeCompare(a));` або просто `arr.sort().reverse();` якщо алфавітне сортування є достатнім."
      },
      {
        "id": "js-q32-aq3",
        "question": "Яка поведінка `sort()` без функції порівняння?",
        "answer": "Без функції порівняння `sort()` перетворює елементи на рядки і сортує їх лексикографічно (як рядки), що може призвести до неочікуваних результатів для чисел (наприклад, `[1, 10, 2]` стане `[1, 10, 2]` або `[1, 2, 10]` залежно від реалізації, але не гарантовано числовий порядок)."
      }
    ]
  },
  {
    "id": "js-q33",
    "topic": "JavaScript",
    "mainQuestion": "Що таке деструктуризація присвоєння (destructuring assignment)? Наведіть кілька прикладів.",
    "mainAnswer": "Деструктуризація присвоєння — це синтаксична функція JavaScript (ES6), яка дозволяє 'розпаковувати' значення з масивів або властивості з об'єктів у окремі змінні. Це робить код більш читабельним і скорочує кількість коду, необхідного для доступу до даних. \n**Приклади:** \n- **Масив:** `const [first, second] = [10, 20]; // first = 10, second = 20` \n- **Об'єкт:** `const { name, age } = { name: 'Роман', age: 30 }; // name = 'Роман', age = 30` \n- **Деструктуризація в параметрах функції:** `function printUser({ name, age }) { console.log(`${name} (${age} років)`); }`",
    "additionalQuestions": [
      {
        "id": "js-q33-aq1",
        "question": "Чи можна призначити значення за замовчуванням під час деструктуризації?",
        "answer": "Так, можна: `const { name, age = 25 } = { name: 'Анна' }; // age буде 25` або `const [a, b = 0] = [1]; // b буде 0`."
      },
      {
        "id": "js-q33-aq2",
        "question": "Як перейменувати змінну під час деструктуризації об'єкта?",
        "answer": "Використовуйте двокрапку: `const { name: userName, age } = { name: 'Іван', age: 25 }; // userName = 'Іван'`."
      },
      {
        "id": "js-q33-aq3",
        "question": "Чи можна деструктурувати вкладені об'єкти/масиви?",
        "answer": "Так, деструктуризація підтримує вкладені структури: `const { user: { id, email } } = { user: { id: 1, email: 'a@b.com' } }; // id = 1, email = 'a@b.com'`."
      }
    ]
  },
  {
    "id": "js-q34",
    "topic": "JavaScript",
    "mainQuestion": "Що таке rest-синтаксис? Що таке spread-синтаксис? У чому різниця між ними?",
    "mainAnswer": "Обидва використовують оператор `...` (три крапки), але в різних контекстах: \n- **Rest-синтаксис** (`...rest`): Збирає декілька елементів (або властивостей) у **масив**. Використовується в параметрах функцій (збирає решту аргументів) або при деструктуризації масивів/об'єктів (збирає решту властивостей). Він **збирає** елементи. \n- **Spread-синтаксис** (`...array` або `...object`): 'Розгортає' ітерований об'єкт (наприклад, масив або рядок) або властивості об'єкта в окремі елементи. Використовується для створення копій масивів/об'єктів, об'єднання їх, або передачі елементів масиву як окремих аргументів функції. Він **розгортає** елементи.",
    "additionalQuestions": [
      {
        "id": "js-q34-aq1",
        "question": "Наведіть приклад використання rest-синтаксису в параметрах функції.",
        "answer": "`function sum(a, b, ...others) { console.log(a, b, others); } sum(1, 2, 3, 4, 5); // 1, 2, [3, 4, 5]`"
      },
      {
        "id": "js-q34-aq2",
        "question": "Як використовувати spread-синтаксис для об'єднання двох масивів?",
        "answer": "`const arr1 = [1, 2]; const arr2 = [3, 4]; const combined = [...arr1, ...arr2]; // combined = [1, 2, 3, 4]`"
      },
      {
        "id": "js-q34-aq3",
        "question": "Чи можна використовувати spread-синтаксис для глибокого копіювання об'єктів?",
        "answer": "Ні, spread-синтаксис виконує лише *поверхневе копіювання* (shallow copy). Якщо об'єкт містить вкладені об'єкти або масиви, вони будуть копіюватися за посиланням, а не як нові об'єкти."
      }
    ]
  },
  {
    "id": "js-q35",
    "topic": "JavaScript",
    "mainQuestion": "Для чого потрібна структура даних `Set`? Які методи вона реалізує?",
    "mainAnswer": "`Set` (множина) — це нова вбудована структура даних (ES6), яка дозволяє зберігати колекцію **унікальних значень будь-якого типу**. Вона автоматично видаляє дублікати. \n**Основні методи:** \n- **`new Set([iterable])`**: Створює нову множину. \n- **`set.add(value)`**: Додає нове значення. \n- **`set.delete(value)`**: Видаляє значення, повертає `true`, якщо елемент був у Set. \n- **`set.has(value)`**: Перевіряє наявність значення, повертає `true` або `false`. \n- **`set.clear()`**: Видаляє всі елементи. \n- **`set.size`**: Властивість, що повертає кількість елементів.",
    "additionalQuestions": [
      {
        "id": "js-q35-aq1",
        "question": "Як перетворити `Set` на `Array`?",
        "answer": "Можна використовувати `Array.from(mySet)` або spread-синтаксис `[...mySet]`."
      },
      {
        "id": "js-q35-aq2",
        "question": "Чи можна зберігати об'єкти в `Set`?",
        "answer": "Так, можна. Однак `Set` порівнює об'єкти за посиланням. Тобто, `{}` та `{}` будуть вважатися різними об'єктами, навіть якщо їхній вміст однаковий, оскільки вони є різними об'єктами в пам'яті."
      },
      {
        "id": "js-q35-aq3",
        "question": "Який сценарій використання `Set` є типовим?",
        "answer": "Видалення дублікатів з масиву, перевірка наявності елемента в колекції з високою ефективністю (якщо не потрібно зберігати порядок або індекси)."
      }
    ]
  },
  {
    "id": "js-q36",
    "topic": "JavaScript",
    "mainQuestion": "Для чого потрібна структура даних `Map`? Які методи вона реалізує?",
    "mainAnswer": "`Map` (карта/словник) — це нова вбудована структура даних (ES6), яка зберігає колекцію пар 'ключ-значення', де ключі можуть бути **будь-якого типу** (на відміну від звичайних об'єктів, де ключі є лише рядками або символами). Вона зберігає порядок вставки елементів. \n**Основні методи:** \n- **`new Map([iterable])`**: Створює нову карту. \n- **`map.set(key, value)`**: Додає або оновлює пару 'ключ-значення'. \n- **`map.get(key)`**: Повертає значення за ключем, або `undefined`, якщо ключ не знайдено. \n- **`map.has(key)`**: Перевіряє наявність ключа, повертає `true` або `false`. \n- **`map.delete(key)`**: Видаляє пару за ключем. \n- **`map.clear()`**: Видаляє всі пари. \n- **`map.size`**: Властивість, що повертає кількість пар.",
    "additionalQuestions": [
      {
        "id": "js-q36-aq1",
        "question": "У чому головна перевага `Map` над звичайними об'єктами для зберігання даних?",
        "answer": "Головна перевага полягає в тому, що `Map` дозволяє використовувати ключі будь-якого типу (включаючи об'єкти, функції, `NaN`), гарантує порядок вставки елементів і має кращу продуктивність для частих операцій додавання/видалення великих об'ємів даних."
      },
      {
        "id": "js-q36-aq2",
        "question": "Як ітерувати по елементах `Map`?",
        "answer": "Можна використовувати `for...of` цикл з `map.keys()`, `map.values()`, або `map.entries()`: \n`for (const [key, value] of myMap) { console.log(key, value); }`."
      },
      {
        "id": "js-q36-aq3",
        "question": "Чи можна використовувати об'єкти як ключі в `Map`?",
        "answer": "Так, це одна з ключових особливостей `Map`. Об'єкти як ключі порівнюються за посиланням, тобто `map.set({}, 'value1')` та `map.set({}, 'value2')` створять дві різні записи."
      }
    ]
  },
  {
    "id": "js-q37",
    "topic": "JavaScript",
    "mainQuestion": "Що таке `WeakSet` та `WeakMap` і чим вони відрізняються від їхніх 'сильних' аналогів?",
    "mainAnswer": "`WeakSet` та `WeakMap` (ES6) є 'слабкими' колекціями, що означає, що вони не створюють сильних посилань на свої елементи/ключі. \n- **`WeakSet`**: Колекція унікальних об'єктів. \n- **`WeakMap`**: Колекція пар 'ключ-значення', де ключі — це об'єкти, а значення можуть бути будь-якими. \n**Відмінність від 'сильних' (звичайних `Set`/`Map`)**: \n1. **Лише об'єкти**: `WeakSet` може зберігати лише об'єкти (не примітиви), а `WeakMap` може використовувати лише об'єкти як ключі. \n2. **'Слабкі' посилання**: Якщо на об'єкт, що зберігається у `WeakSet` або є ключем у `WeakMap`, більше немає сильних посилань, збирач сміття (garbage collector) може видалити цей об'єкт з пам'яті (і, відповідно, з колекції `WeakSet`/`WeakMap`), не чекаючи, поки ви його явно видалите. Це запобігає витокам пам'яті. \n3. **Не ітеровані**: Вони не ітеровані (не мають `size`, `clear()`, `keys()`, `values()`, `entries()`), тому неможливо отримати список всіх елементів або ключів. \n4. **Асинхронність**: Видалення елементів відбувається асинхронно і не детерміновано, тому не можна точно знати, коли об'єкт буде видалено.",
    "additionalQuestions": [
      {
        "id": "js-q37-aq1",
        "question": "Коли `WeakSet` або `WeakMap` можуть бути корисними?",
        "answer": "Вони корисні для зберігання метаданих або додаткової інформації, пов'язаної з об'єктами, без запобігання збору сміття цих об'єктів. Наприклад, для відстеження стану DOM-елементів або для приватних даних класів."
      },
      {
        "id": "js-q37-aq2",
        "question": "Чому `WeakSet` та `WeakMap` не ітеровані?",
        "answer": "Оскільки об'єкти можуть бути видалені збирачем сміття в будь-який момент, наявність ітерації або методу `size` призвела б до непередбачуваної поведінки, оскільки колекція могла б змінитись під час ітерації."
      },
      {
        "id": "js-q37-aq3",
        "question": "Чи можна в `WeakMap` використовувати примітивні значення як ключі?",
        "answer": "Ні, `WeakMap` дозволяє використовувати лише об'єкти як ключі. Якщо ви спробуєте використовувати примітив, буде викинута помилка `TypeError`."
      }
    ]
  },
  {
    "id": "js-q38",
    "topic": "JavaScript",
    "mainQuestion": "Яке застосування регулярних виразів? Які основні способи роботи з ними в JavaScript?",
    "mainAnswer": "Регулярні вирази (Regular Expressions - RegEx) — це потужний інструмент для пошуку, заміни та маніпуляції текстом, а також для валідації рядків за певним шаблоном. \n**Застосування:** валідація форм (email, номер телефону), пошук шаблонів у тексті, розбір URL-адрес, заміна підрядків. \n**Основні способи роботи:** \n1. **Створення**: \n   - Літерал: `/pattern/flags` (наприклад, `/abc/g`) \n   - Конструктор: `new RegExp('pattern', 'flags')` \n2. **Методи `String`:** \n   - `string.match(regex)`: повертає масив з усіма збігами або `null`. \n   - `string.search(regex)`: повертає індекс першого збігу або `-1`. \n   - `string.replace(regex, replacement)`: замінює збіги. \n   - `string.split(regex)`: розбиває рядок за шаблоном. \n3. **Методи `RegExp`:** \n   - `regex.test(string)`: повертає `true` або `false`, чи знайдено збіг. \n   - `regex.exec(string)`: повертає масив з інформацією про один збіг або `null`.",
    "additionalQuestions": [
      {
        "id": "js-q38-aq1",
        "question": "Що означають прапорці (flags) у регулярних виразах?",
        "answer": "Прапорці змінюють поведінку регулярного виразу: \n- `i` (ignore case): регістронезалежний пошук. \n- `g` (global): знайти всі збіги, а не тільки перший. \n- `m` (multiline): дозволяє `^` та `$` збігатися з початком/кінцем рядка, а не лише всього тексту."
      },
      {
        "id": "js-q38-aq2",
        "question": "У чому різниця між `string.match()` та `regex.exec()`?",
        "answer": "`string.match()` повертає всі збіги (якщо прапорець `g` встановлений) або деталі першого збігу. `regex.exec()` повертає деталі *одного* збігу за раз і зберігає стан, що дозволяє послідовно отримувати всі збіги при багаторазовому виклику."
      },
      {
        "id": "js-q38-aq3",
        "question": "Коли варто використовувати конструктор `new RegExp()` замість літералу?",
        "answer": "Конструктор `new RegExp()` варто використовувати, коли шаблон регулярного виразу створюється динамічно, наприклад, з рядка, введеного користувачем."
      }
    ]
  },
  {
    "id": "js-q39",
    "topic": "JavaScript",
    "mainQuestion": "Що означають дужки `()`, квадратні дужки `[]` та фігурні дужки `{}` у регулярних виразах?",
    "mainAnswer": "У регулярних виразах ці символи мають специфічне значення: \n- **Круглі дужки `()` (Grouping / Capturing Group)**: Використовуються для групування частин виразу, щоб застосовувати до них квантифікатори (наприклад, `(ab)+`), а також для створення 'груп захоплення', які зберігають текст, що відповідає цій частині виразу, для подальшого використання (доступні через `match[1]`, `match[2]` тощо). \n- **Квадратні дужки `[]` (Character Set)**: Визначають набір символів. Вони збігаються з *будь-яким одним символом* з цього набору. Наприклад, `[abc]` збігається з 'a', 'b' або 'c'. `[0-9]` збігається з будь-якою цифрою. \n- **Фігурні дужки `{}` (Quantifier)**: Визначають кількість повторень попереднього символу або групи. Наприклад, `a{3}` означає 'aaa', `a{2,4}` означає 'aa', 'aaa' або 'aaaa'.",
    "additionalQuestions": [
      {
        "id": "js-q39-aq1",
        "question": "Що таке 'незахоплюючі групи' (non-capturing groups) і як їх створити?",
        "answer": "Незахоплюючі групи `(?:...)` групують частини виразу без створення окремої групи захоплення. Вони корисні, коли вам потрібно згрупувати елементи, але не потрібно зберігати їх у результатах `match()`."
      },
      {
        "id": "js-q39-aq2",
        "question": "Як інвертувати набір символів у квадратних дужках?",
        "answer": "Використовуйте `^` на початку набору: `[^abc]` збігається з будь-яким символом, який *не* є 'a', 'b' або 'c'."
      },
      {
        "id": "js-q39-aq3",
        "question": "Яка різниця між `a{1,}` та `a+`?",
        "answer": "Обидва означають 'один або більше повторень символу `a`'. `a+` є скороченням для `a{1,}`."
      }
    ]
  },
  {
    "id": "js-q40",
    "topic": "JavaScript",
    "mainQuestion": "Що означають наступні символи в регулярних виразах: `+`, `*`, `?`, `^`, `$`?",
    "mainAnswer": "Ці символи є квантифікаторами або якорями: \n- **`+` (One or More)**: Збігається з одним або більше повторень попереднього елемента. Наприклад, `a+` збігається з 'a', 'aa', 'aaa' тощо. \n- **`*` (Zero or More)**: Збігається з нулем або більше повторень попереднього елемента. Наприклад, `a*` збігається з '', 'a', 'aa' тощо. \n- **`?` (Zero or One / Optional)**: Збігається з нулем або одним повторенням попереднього елемента, роблячи його необов'язковим. Також використовується для 'нежадібних' (non-greedy) квантифікаторів (наприклад, `*?`). Наприклад, `colou?r` збігається з 'color' або 'colour'. \n- **`^` (Start of String / Negation)**: \n  - На початку виразу: якір, що збігається з початком рядка (або початком рядка в багаторядковому режимі). Наприклад, `^abc`. \n  - Всередині `[]`: заперечення набору символів. Наприклад, `[^abc]`. \n- **`$` (End of String)**: Як якір, що збігається з кінцем рядка (або кінцем рядка в багаторядковому режимі). Наприклад, `abc$`.",
    "additionalQuestions": [
      {
        "id": "js-q40-aq1",
        "question": "Яка різниця між 'жадібним' (greedy) та 'нежадібним' (non-greedy) квантифікатором?",
        "answer": "За замовчуванням квантифікатори (`+`, `*`, `{}`) є 'жадібними' — вони намагаються збігтися з якомога більшою кількістю символів. Додавання `?` після квантифікатора робить його 'нежадібним' (або 'лінивим'), що означає, що він намагається збігтися з якомога меншою кількістю символів."
      },
      {
        "id": "js-q40-aq2",
        "question": "Як збігатися з буквальним символом `+`, `*`, `?`, `^`, `$`?",
        "answer": "Щоб збігатися з цими символами буквально, їх потрібно екранувати зворотним слешем: `\\+`, `\\*`, `\\?`, `\\^`, `\\$`."
      },
      {
        "id": "js-q40-aq3",
        "question": "Наведіть приклад використання `^` та `$` разом.",
        "answer": "`^Hello$` збігається лише з рядком, який містить *точно* 'Hello' і нічого більше. Часто використовується для повної валідації рядка."
      }
    ]
  },
  {
    "id": "js-q41",
    "topic": "JavaScript",
    "mainQuestion": "Що таке рекурсія? Що таке стек?",
    "mainAnswer": "**Рекурсія** — це програмна техніка, при якій функція викликає сама себе для вирішення задачі. Вона продовжує викликати себе доти, доки не досягне базового (вихідного) випадку. **Стек** (зокрема, стек викликів, Call Stack) — це структура даних, що працює за принципом LIFO (Last-In, First-Out), яка використовується JavaScript-двигуном для відстеження послідовності викликів функцій. Кожен виклик функції додається до стеку (push), а коли функція завершується, вона видаляється зі стеку (pop). При рекурсії, кожен рекурсивний виклик додає новий кадр до стеку, що може призвести до 'переповнення стеку' (Stack Overflow) при надто глибокій рекурсії без належного базового випадку.",
    "additionalQuestions": [
      {
        "id": "js-q41-aq1",
        "question": "Наведіть приклад рекурсивної функції.",
        "answer": "`function factorial(n) { if (n === 0 || n === 1) { return 1; } return n * factorial(n - 1); } console.log(factorial(5)); // 120`"
      },
      {
        "id": "js-q41-aq2",
        "question": "Що таке 'базовий випадок' у рекурсії і чому він важливий?",
        "answer": "Базовий випадок — це умова, при якій рекурсивна функція припиняє викликати сама себе і повертає кінцеве значення. Він критично важливий для запобігання нескінченної рекурсії та переповнення стеку."
      },
      {
        "id": "js-q41-aq3",
        "question": "Коли варто використовувати рекурсію, а коли цикл?",
        "answer": "Рекурсія часто робить код більш читабельним для задач, які природно розв'язуються рекурсивно (наприклад, обробка дерев, фракталів). Цикли зазвичай ефективніші за продуктивністю та пам'яттю, особливо для великих об'ємів даних, де рекурсія може призвести до переповнення стеку."
      }
    ]
  },
  {
    "id": "js-q42",
    "topic": "JavaScript",
    "mainQuestion": "Що таке клас (class)?",
    "mainAnswer": "У JavaScript **клас** — це синтаксичний цукор (syntactic sugar) над вже існуючою прототипною моделлю успадкування. Класи надають більш зрозумілий і звичний синтаксис для створення конструкторів об'єктів та реалізації успадкування, схожий на об'єктно-орієнтовані мови, такі як Java або C#. Класи не вводять нової об'єктної моделі в JavaScript, вони просто спрощують роботу з прототипами.",
    "additionalQuestions": [
      {
        "id": "js-q42-aq1",
        "question": "Як оголосити клас у JavaScript?",
        "answer": "Класи оголошуються за допомогою ключового слова `class`, наприклад: `class MyClass { constructor() {} myMethod() {} }`."
      },
      {
        "id": "js-q42-aq2",
        "question": "Що таке метод `constructor` у класі?",
        "answer": "`constructor` — це спеціальний метод, який викликається при створенні нового екземпляра класу за допомогою оператора `new`. Він використовується для ініціалізації властивостей об'єкта."
      },
      {
        "id": "js-q42-aq3",
        "question": "Яке ключове слово використовується для успадкування одного класу від іншого?",
        "answer": "Для успадкування використовується ключове слово `extends`, наприклад: `class Dog extends Animal { ... }`."
      }
    ]
  },
  {
    "id": "js-q43",
    "topic": "JavaScript",
    "mainQuestion": "Що таке статичні властивості (static properties) класу?",
    "mainAnswer": "**Статичні властивості** (та методи) класу — це властивості (та методи), які належать самому класу, а не його окремим екземплярам. До них можна отримати доступ без створення екземпляра класу, безпосередньо через ім'я класу. Вони корисні для утилітних функцій, які не залежать від стану конкретного об'єкта, або для констант, пов'язаних з класом.",
    "additionalQuestions": [
      {
        "id": "js-q43-aq1",
        "question": "Як оголосити статичний метод у класі?",
        "answer": "Статичні методи оголошуються за допомогою ключового слова `static` перед назвою методу: `class MyClass { static myStaticMethod() { console.log('Я статичний метод'); } }`."
      },
      {
        "id": "js-q43-aq2",
        "question": "Як отримати доступ до статичної властивості або методу?",
        "answer": "Доступ здійснюється через ім'я класу: `MyClass.myStaticMethod();` або `console.log(MyClass.staticProperty);`."
      },
      {
        "id": "js-q43-aq3",
        "question": "Чи може статичний метод отримати доступ до нестатичних властивостей екземпляра?",
        "answer": "Ні, статичні методи не мають доступу до `this` екземпляра класу, оскільки вони не викликаються на екземплярі. Вони можуть отримувати доступ лише до інших статичних властивостей або методів класу."
      }
    ]
  },
  {
    "id": "js-q44",
    "topic": "JavaScript",
    "mainQuestion": "Як перевірити, чи належить об'єкт певному класу?",
    "mainAnswer": "Для перевірки належності об'єкта до певного класу (або чи є він екземпляром класу або його дочірнього класу) використовується оператор **`instanceof`**. Наприклад, `myObject instanceof MyClass` поверне `true`, якщо `myObject` є екземпляром `MyClass` або екземпляром класу, який успадковується від `MyClass`. Також можна перевірити властивість `constructor.name` (наприклад, `myObject.constructor.name === 'MyClass'`), але це менш надійно, оскільки ім'я конструктора може бути змінено або обфусковано.",
    "additionalQuestions": [
      {
        "id": "js-q44-aq1",
        "question": "Чи працює `instanceof` для примітивних типів даних?",
        "answer": "Ні, `instanceof` працює лише для об'єктів. Спроба використовувати його з примітивами (наприклад, `5 instanceof Number`) поверне `false`."
      },
      {
        "id": "js-q44-aq2",
        "question": "Яке обмеження має перевірка через `constructor.name`?",
        "answer": "Перевірка `constructor.name` може бути ненадійною, оскільки вона залежить від імені функції конструктора, яке може бути змінено або обфусковано в процесі мініфікації коду. Крім того, вона не враховує ланцюжок успадкування, на відміну від `instanceof`."
      },
      {
        "id": "js-q44-aq3",
        "question": "Як перевірити, чи об'єкт є `null` або `undefined` перед використанням `instanceof`?",
        "answer": "Завжди рекомендується перевіряти об'єкт на `null` або `undefined` перед використанням `instanceof`, оскільки `null instanceof MyClass` викине `TypeError`, а `undefined instanceof MyClass` буде `false`. Можна використати `if (myObject && myObject instanceof MyClass)`."
      }
    ]
  },
  {
    "id": "js-q45",
    "topic": "JavaScript",
    "mainQuestion": "Які є засоби обробки помилок у JavaScript?",
    "mainAnswer": "Основними засобами обробки помилок у JavaScript є: \n- **`try...catch` блок**: Дозволяє 'спіймати' та обробити помилки (винятки), які виникають у блоці `try`. Якщо помилка виникає, виконання переходить до блоку `catch`. \n- **`finally` блок**: Виконується завжди, незалежно від того, чи була помилка, чи ні. Корисний для очищення ресурсів. \n- **`throw` оператор**: Дозволяє вручну генерувати помилку (виняток). \n- **Об'єкт `Error` та його похідні**: Вбудовані конструктори для створення об'єктів помилок (`TypeError`, `ReferenceError` тощо). \n- **Проміси (`.catch()`) та `async/await` (`try...catch`)**: Для обробки помилок в асинхронному коді.",
    "additionalQuestions": [
      {
        "id": "js-q45-aq1",
        "question": "Коли слід використовувати `try...catch`?",
        "answer": "`try...catch` слід використовувати, коли ви очікуєте, що певна частина коду може викинути помилку, і ви хочете контрольовано її обробити, щоб програма не завершила свою роботу."
      },
      {
        "id": "js-q45-aq2",
        "question": "У чому відмінність між `Error` та `TypeError`?",
        "answer": "`Error` — це загальний базовий клас для об'єктів помилок. `TypeError` — це специфічний тип помилки, який виникає, коли операція не може бути виконана, тому що значення не має очікуваного типу (наприклад, виклик нефункції як функції)."
      },
      {
        "id": "js-q45-aq3",
        "question": "Чи можна зловити помилки, які виникають в асинхронних колбеках, за допомогою синхронного `try...catch`?",
        "answer": "Ні, синхронний `try...catch` може зловити лише помилки, що виникають синхронно в його блоці. Для асинхронних помилок (наприклад, у `setTimeout` колбеках, промісах) потрібно використовувати `.catch()` для промісів або `try...catch` всередині `async` функції."
      }
    ]
  },
  {
    "id": "js-q46",
    "topic": "JavaScript",
    "mainQuestion": "Навіщо потрібна модульність у наших застосунках? Які інструменти завантаження JS модулів ви знаєте?",
    "mainAnswer": "**Модульність** дозволяє розбивати великі застосунки на невеликі, незалежні, багаторазово використовувані частини (модулі). Це покращує організацію коду, полегшує його підтримку, налагодження та тестування, а також дозволяє командній роботі. \n**Інструменти та стандарти завантаження модулів:** \n- **ES Modules (ESM)**: Стандартний синтаксис JavaScript (`import`/`export`), підтримується більшістю сучасних браузерів та Node.js. \n- **CommonJS (CJS)**: Стандарт для Node.js (`require`/`module.exports`), використовується переважно на стороні сервера. \n- **AMD (Asynchronous Module Definition)**: Для асинхронного завантаження модулів у браузері (наприклад, RequireJS). \n- **UMD (Universal Module Definition)**: Патерн, що дозволяє модулям працювати як в CommonJS, так і в AMD/браузері. \n- **Bundlers (збирачі)**: Такі інструменти, як Webpack, Rollup, Parcel, Vite, які об'єднують модулі та їхні залежності в один або кілька файлів для оптимізації завантаження.",
    "additionalQuestions": [
      {
        "id": "js-q46-aq1",
        "question": "У чому головна відмінність між `import`/`export` та `require`/`module.exports`?",
        "answer": "`import`/`export` (ESM) є статичними (аналіз залежностей відбувається під час компіляції) та підтримують деревовидне струшування (tree-shaking). `require`/`module.exports` (CommonJS) є динамічними (завантаження відбувається під час виконання) і синхронними."
      },
      {
        "id": "js-q46-aq2",
        "question": "Яка роль бандлерів у сучасній веб-розробці?",
        "answer": "Бандлери (наприклад, Webpack) об'єднують файли модулів та їхні залежності в оптимізовані пакети для розгортання в браузері. Вони можуть також виконувати транспіляцію (Babel), мініфікацію, оптимізацію зображень тощо."
      },
      {
        "id": "js-q46-aq3",
        "question": "Чи можна використовувати ES Modules у Node.js?",
        "answer": "Так, починаючи з Node.js 12 (та стабільніше з 14), можна використовувати ES Modules, якщо файли мають розширення `.mjs` або якщо в `package.json` встановлено `\"type\": \"module\"`."
      }
    ]
  },
  {
    "id": "js-q47",
    "topic": "JavaScript",
    "mainQuestion": "Опишіть потік завантаження даних з віддаленого сервера в JavaScript. Які інструменти для отримання даних ви знаєте?",
    "mainAnswer": "Потік завантаження даних зазвичай є асинхронним: \n1. **Ініціація запиту**: JavaScript відправляє HTTP-запит до віддаленого сервера. Це не блокує основний потік виконання програми. \n2. **Очікування відповіді**: Запит виконується у фоновому режимі (за допомогою Web APIs). \n3. **Отримання відповіді**: Після отримання відповіді від сервера викликається колбек-функція або обробляється Проміс. \n4. **Обробка даних**: Отримані дані (зазвичай у форматі JSON) парсяться та використовуються в застосунку. \n**Інструменти для отримання даних:** \n- **`XMLHttpRequest` (XHR)**: Старіший, але все ще робочий API для HTTP-запитів. \n- **`Fetch API`**: Сучасний, заснований на Промісах API для мережевих запитів, який надає більш потужний і гнучкий інтерфейс. \n- **Бібліотеки/фреймворки**: \n  - **Axios**: Популярна бібліотека для HTTP-запитів, заснована на Промісах, з багатьма зручними функціями. \n  - **jQuery.ajax()**: Метод для AJAX-запитів, якщо ви використовуєте jQuery. \n  - **Спеціалізовані рішення**: GraphQL клієнти (Apollo Client, Relay), RTK Query для Redux Toolkit тощо.",
    "additionalQuestions": [
      {
        "id": "js-q47-aq1",
        "question": "У чому перевага `Fetch API` над `XMLHttpRequest`?",
        "answer": "`Fetch API` використовує Проміси, що дозволяє працювати з асинхронними операціями більш чисто та уникнути 'callback hell'. Він має більш сучасний та гнучкий дизайн."
      },
      {
        "id": "js-q47-aq2",
        "question": "Що таке CORS і як він пов'язаний з завантаженням даних?",
        "answer": "CORS (Cross-Origin Resource Sharing) — це механізм безпеки браузера, який обмежує запити до ресурсів з іншого домену (origin). Якщо ви намагаєтеся зробити запит до API, який знаходиться на іншому домені, без належної конфігурації CORS на сервері, браузер заблокує запит з міркувань безпеки."
      },
      {
        "id": "js-q47-aq3",
        "question": "Як обробляти відповіді у форматі JSON за допомогою `Fetch API`?",
        "answer": "Після отримання об'єкта `Response` від `fetch`, ви можете викликати `response.json()` на ньому. Цей метод також повертає Проміс, який резолвиться з об'єктом JavaScript, отриманим після парсингу JSON."
      }
    ]
  },
  {
    "id": "js-q48",
    "topic": "JavaScript",
    "mainQuestion": "Поясніть спливання подій (event bubbling)?",
    "mainAnswer": "**Спливання подій (Event Bubbling)** — це механізм, при якому події, що виникають на елементі DOM (наприклад, клік на кнопці), спочатку обробляються на цьому елементі, а потім 'спливають' (поширюються) вгору по дереву DOM до батьківських елементів, аж до `document` і `window`. Це означає, що якщо ви клікнете на внутрішньому елементі, обробники подій на ньому спрацюють першими, а потім спрацюють обробники на його батьківському елементі, потім на батьківському батька і так далі. Це дозволяє використовувати **делегування подій**.",
    "additionalQuestions": [
      {
        "id": "js-q48-aq1",
        "question": "Як зупинити спливання події?",
        "answer": "Для зупинки спливання події використовується метод `event.stopPropagation()` всередині обробника події. Це запобігає подальшому поширенню події до батьківських елементів."
      },
      {
        "id": "js-q48-aq2",
        "question": "Що таке фаза 'захоплення' (capturing phase) у потоці подій?",
        "answer": "Потік подій складається з трьох фаз: фаза захоплення (від `window` до цільового елемента), фаза цілі (коли подія досягає цільового елемента) і фаза спливання (від цільового елемента назад до `window`). Зазвичай обробники подій реєструються для фази спливання, але їх можна зареєструвати і для фази захоплення, передавши `true` третім аргументом `addEventListener`."
      },
      {
        "id": "js-q48-aq3",
        "question": "Чи всі події спливають?",
        "answer": "Більшість подій спливає, але є деякі винятки, які не спливають, наприклад, подія `focus` або `blur`."
      }
    ]
  },
  {
    "id": "js-q49",
    "topic": "JavaScript",
    "mainQuestion": "Що таке делегування подій (event delegation)?",
    "mainAnswer": "**Делегування подій** — це техніка, яка використовує спливання подій для ефективної обробки подій на кількох дочірніх елементах. Замість того, щоб призначати обробник подій кожному окремому дочірньому елементу, ви призначаєте один обробник подій **батьківському елементу**. Коли подія 'спливає' від дочірнього елемента до батьківського, обробник на батьківському елементі визначає, який саме дочірній елемент викликав подію (за допомогою `event.target`), і виконує відповідну логіку. Це зменшує кількість обробників подій, покращує продуктивність та спрощує роботу з динамічно доданими елементами.",
    "additionalQuestions": [
      {
        "id": "js-q49-aq1",
        "question": "Які головні переваги делегування подій?",
        "answer": "Головні переваги: зменшення кількості обробників подій (і, відповідно, споживання пам'яті), підвищення продуктивності, особливо для великих списків, та автоматична робота з елементами, які додаються в DOM після ініціалізації сторінки."
      },
      {
        "id": "js-q49-aq2",
        "question": "Наведіть приклад, де делегування подій особливо корисне.",
        "answer": "Делегування подій дуже корисне для динамічних списків, таких як списки завдань (Todo List), де елементи додаються або видаляються. Замість того, щоб додавати обробник кліків до кожного нового елемента списку, ви додаєте один обробник до батьківського контейнера списку."
      },
      {
        "id": "js-q49-aq3",
        "question": "Як отримати доступ до елемента, на якому відбулася подія, при делегуванні?",
        "answer": "Доступ до елемента, який фактично викликав подію (тобто того, на якому вона почалася), можна отримати за допомогою властивості `event.target`."
      }
    ]
  },
  {
    "id": "js-q50",
    "topic": "JavaScript",
    "mainQuestion": "Що таке `WeakMap`? Які його особливості?",
    "mainAnswer": "`WeakMap` — це колекція, яка дозволяє використовувати об'єкти як ключі, але не перешкоджає їх видаленню збирачем сміття. Це означає, що якщо єдиний посилання на об'єкт-ключ буде видалено, то відповідний запис у `WeakMap` також буде видалено. \n**Особливості:** \n- Ключами можуть бути лише об'єкти (примітиви не підтримуються). \n- Не має методів для отримання розміру (`size`) або ітерації по елементах (немає методів `keys()`, `values()`, `entries()`). \n- Використовується для зберігання метаданих про об'єкти без перешкоджання їх видаленню збирачем сміття.",
    "additionalQuestions": [
      {
        "id": "js-q50-aq1",
        "question": "Яка різниця між `WeakMap` та `Map`?",
        "answer": "`WeakMap` дозволяє використовувати лише об'єкти як ключі і не перешкоджає збору сміття, тоді як `Map` може мати будь-які типи ключів і зберігає всі елементи незалежно від того, чи є на них посилання."
      },
      {
        "id": "js-q50-aq2",
        "question": "Чому в `WeakMap` немає методів для ітерації?",
        "answer": "`WeakMap` не підтримує ітерацію через свої елементи, оскільки ключі можуть бути видалені збирачем сміття в будь-який момент, що робить ітерацію непередбачуваною."
      },
      {
        "id": "js-q50-aq3",
        "question": "Чи можна використовувати `WeakMap` для зберігання примітивних значень?",
        "answer": "`WeakMap` не підтримує примітивні значення як ключі. Ключами можуть бути лише об'єкти. Примітивні значення можна зберігати в `Map` або інших структурах даних, але не в `WeakMap`."
      }
    ]
  },
  {
    "id": "js-q51",
    "topic": "JavaScript",
    "mainQuestion": "Що таке `WeakSet`? Які його особливості?",
    "mainAnswer": "`WeakSet` — це колекція, яка дозволяє зберігати лише об'єкти, але не перешкоджає їх видаленню збирачем сміття. Це означає, що якщо єдиний посилання на об'єкт буде видалено, то відповідний запис у `WeakSet` також буде видалено. \n**Особливості:** \n- Може містити лише об'єкти (примітиви не підтримуються). \n- Не має методів для отримання розміру (`size`) або ітерації по елементах (немає методів `keys()`, `values()`, `entries()`). \n- Використовується для зберігання унікальних об'єктів без перешкоджання їх видаленню збирачем сміття.",
    "additionalQuestions": [
      {
        "id": "js-q51-aq1",
        "question": "Яка різниця між `WeakSet` та `Set`?",
        "answer": "`WeakSet` дозволяє використовувати лише об'єкти і не перешкоджає збору сміття, тоді як `Set` може мати будь-які типи значень (примітиви та об'єкти) і зберігає всі елементи незалежно від того, чи є на них посилання."
      },
      {
        "id": "js-q51-aq2",
        "question": "Чому в `WeakSet` немає методів для ітерації?",
        "answer": "`WeakSet` не підтримує ітерацію через свої елементи, оскільки ключі можуть бути видалені збирачем сміття в будь-який момент, що робить ітерацію непередбачуваною."
      },
      {
        "id": "js-q51-aq3",
        "question": "Чи можна використовувати `WeakSet` для зберігання примітивних значень?",
        "answer": "`WeakSet` не підтримує примітивні значення. Ключами можуть бути лише об'єкти. Примітивні значення можна зберігати в `Set` або інших структурах даних, але не в `WeakSet`."
      }
    ]
  }
]