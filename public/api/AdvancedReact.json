[
  {
    "id": "adv-react-q1",
    "topic": "Advanced React",
    "mainQuestion": "Що таке ref? У яких випадках ними варто користуватися і як?",
    "mainAnswer": "**Refs** (від 'references') — це механізм у React, який надає спосіб прямого доступу до DOM-вузлів або екземплярів React-компонентів, створених у методі `render()` (або повернених функціональним компонентом). Вони є своєрідним 'запасним виходом' з декларативного підходу React і використовуються, коли потрібно виконати імперативні дії, які неможливо досягти через пропси та стан. \n\n**Коли ними варто користуватися (типові випадки):** \n- **Управління фокусом, виділенням тексту або медіа-відтворенням.** \n- **Імперативні анімації.** \n- **Інтеграція зі сторонніми DOM-бібліотеками**, які не є React-орієнтованими (наприклад, деякі візуалізатори графіків або галереї). \n- **Вимірювання розмірів або позиції DOM-елементів.** \n\n**Як користуватися:** \n- **Функціональні компоненти (рекомендовано):** Використовуйте хук `useRef`. \n  ```jsx \n  import React, { useRef, useEffect } from 'react'; \n  function MyInput() { \n    const inputRef = useRef(null); \n    useEffect(() => { \n      inputRef.current.focus(); \n    }, []); \n    return <input type=\"text\" ref={inputRef} />; \n  } \n  ``` \n- **Класові компоненти:** Використовуйте `React.createRef()` (у `constructor`) або функціональні рефи. \n  ```jsx \n  class MyInput extends React.Component { \n    constructor(props) { \n      super(props); \n      this.inputRef = React.createRef(); \n    } \n    componentDidMount() { \n      this.inputRef.current.focus(); \n    } \n    render() { \n      return <input type=\"text\" ref={this.inputRef} />; \n    } \n  } \n  ``` \nЗавжди намагайтеся використовувати декларативні підходи (props/state) і звертайтеся до рефів лише тоді, коли це абсолютно необхідно.",
    "additionalQuestions": [
      {
        "id": "adv-react-q1-aq1",
        "question": "Чому прямі маніпуляції з DOM за допомогою рефів вважаються антипатерном у більшості випадків?",
        "answer": "Прямі маніпуляції з DOM обходять механізм Virtual DOM React, що може призвести до розсинхронізації стану UI, труднощів у відстеженні змін, погіршення продуктивності та ускладнення налагодження. React вважає, що він є єдиним джерелом істини для DOM."
      },
      {
        "id": "adv-react-q1-aq2",
        "question": "Чи можна використовувати ref для доступу до іншого React-компонента?",
        "answer": "Так, можна, але лише якщо цей компонент є класовим. Призначення ref функціональному компоненту призведе до помилки, оскільки функціональні компоненти не мають екземплярів. Якщо вам потрібен доступ до методів функціонального компонента, використовуйте `useImperativeHandle` разом з `forwardRef`."
      },
      {
        "id": "adv-react-q1-aq3",
        "question": "Яка різниця між `useRef` та `useState`?",
        "answer": "`useRef` повертає об'єкт, `current` властивість якого є змінюваною і не викликає повторного рендерингу при зміні. Він призначений для збереження посилань на DOM-вузли або будь-яких змінюваних значень, які не впливають на рендеринг. `useState` повертає значення стану та функцію для його оновлення, і зміна цього стану *викликає* повторний рендеринг компонента."
      }
    ]
  },
  {
    "id": "adv-react-q2",
    "topic": "Advanced React",
    "mainQuestion": "Що за другий аргумент методу `this.setState`?",
    "mainAnswer": "Другий (необов'язковий) аргумент методу `this.setState()` у класових компонентах React — це **функція зворотного виклику (callback function)**. Ця функція виконується **після того, як стан був оновлений**, і компонент був повторно відрендерений. \nЦе важливо, тому що `this.setState()` є **асинхронним**. Якщо ви спробуєте отримати доступ до `this.state` або до оновлених DOM-елементів одразу після виклику `setState()`, ви можете отримати старі значення. Функція зворотного виклику гарантує, що ваш код виконається тоді, коли всі зміни стану вже були застосовані та відображені в DOM. \n\n**Приклад:** \n```jsx \nthis.setState(\n  { count: this.state.count + 1 }, \n  () => { \n    console.log('Нове значення count після оновлення:', this.state.count); \n    // Тут можна виконувати дії, які залежать від оновленого DOM \n  }\n); \n``` \nУ сучасних функціональних компонентах з хуками `useState`, подібна логіка зазвичай реалізується за допомогою `useEffect` з відповідними залежностями.",
    "additionalQuestions": [
      {
        "id": "adv-react-q2-aq1",
        "question": "Чому `setState` є асинхронним?",
        "answer": "React робить `setState` асинхронним для оптимізації продуктивності. Він групує кілька викликів `setState` в один батч, щоб уникнути зайвих повторних рендерингів DOM. Це дозволяє React виконувати оновлення більш ефективно."
      },
      {
        "id": "adv-react-q2-aq2",
        "question": "Яка альтернатива другому аргументу `setState` для виконання побічних ефектів?",
        "answer": "Рекомендованою альтернативою (особливо для класових компонентів) є метод життєвого циклу `componentDidUpdate()`. Для функціональних компонентів це хук `useEffect()`."
      },
      {
        "id": "adv-react-q2-aq3",
        "question": "Коли не варто використовувати другий аргумент `setState`?",
        "answer": "Не варто використовувати його для логіки, яка має бути виконана при кожному оновленні компонента. Для такої логіки призначений `componentDidUpdate` або `useEffect`. Другий аргумент корисний для одноразових дій, які повинні відбутися *безпосередньо після* конкретного оновлення стану."
      }
    ]
  },
  {
    "id": "adv-react-q3",
    "topic": "Advanced React",
    "mainQuestion": "Що таке властивість `children`?",
    "mainAnswer": "`props.children` — це спеціальна властивість у React, яка автоматично передається до компонента, коли він має дочірні елементи (тобто все, що знаходиться між відкриваючим і закриваючим тегами компонента). Це дозволяє компоненту \"прокидати\" і рендерити вміст, який був переданий йому ззовні. \n\n**Приклад:** \n```jsx \n// Компонент Layout.jsx \nfunction Layout({ header, children, footer }) { \n  return ( \n    <div> \n      <header>{header}</header> \n      <main>{children}</main> {/* Тут рендериться вміст */} \n      <footer>{footer}</footer> \n    </div> \n  ); \n} \n// Використання: \n<Layout header={<h2>Мій Заголовок</h2>}> \n  <p>Це основний вміст сторінки.</p> \n  <button>Натисни мене</button> \n</Layout> \n``` \nУ цьому прикладі `<p>` та `<button>` будуть доступні всередині `Layout` компонента через `props.children` і будуть відрендерені всередині тегу `<main>`. `children` може бути чим завгодно: текстом, JSX-елементами, іншими компонентами, масивами елементів або навіть функціями.",
    "additionalQuestions": [
      {
        "id": "adv-react-q3-aq1",
        "question": "Як `children` допомагає у створенні гнучких компонентів?",
        "answer": "Він дозволяє створювати так звані 'контейнерні' компоненти або 'Layout' компоненти, які фокусуються на наданні обгортки або загальної структури, а вміст, який вони містять, визначається батьківським компонентом. Це сприяє композиції та повторному використанню."
      },
      {
        "id": "adv-react-q3-aq2",
        "question": "Чи можна передати більше одного елемента через `children`?",
        "answer": "Так, `children` може бути масивом елементів. Якщо ви передаєте кілька дочірніх елементів, React передасть їх як масив об'єктів JSX."
      },
      {
        "id": "adv-react-q3-aq3",
        "question": "Який хук можна використовувати для роботи з `children` у функціональних компонентах?",
        "answer": "`props.children` доступний напряму у функціональних компонентах так само, як і будь-який інший prop. Додаткових хуків для доступу до нього не потрібно. Однак, для маніпуляцій з дітьми (наприклад, для додавання пропсів кожному дочірньому елементу) можна використовувати `React.Children` у поєднанні з `React.cloneElement`."
      }
    ]
  },
  {
    "id": "adv-react-q4",
    "topic": "Advanced React",
    "mainQuestion": "Розкажи про паттерн `render props`.",
    "mainAnswer": "**Паттерн Render Props** — це техніка у React для обміну кодом між компонентами за допомогою властивості (prop), значенням якої є функція. Ця функція рендерить щось, що належить компоненту, який використовує `render props`. Ідея полягає в тому, що компонент з `render prop` відповідає за логіку та стан, а функція, передана через `render prop`, відповідає за те, як ці дані відображаються. \n\n**Основна ідея:** компонент з `render prop` отримує функцію як prop, і викликає цю функцію зі своїми внутрішніми даними, щоб отримати JSX для рендерингу. \n\n**Приклад:** \n```jsx \n// Компонент MouseTracker.jsx (компонент з render prop) \nclass MouseTracker extends React.Component { \n  constructor(props) { \n    super(props); \n    this.state = { x: 0, y: 0 }; \n  } \n  handleMouseMove = (event) => { \n    this.setState({ x: event.clientX, y: event.clientY }); \n  }; \n  render() { \n    return ( \n      <div style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}> \n        {this.props.render(this.state)} {/* Викликаємо функцію з даними */} \n      </div> \n    ); \n  } \n} \n// Використання: \n<MouseTracker render={(mouse) => ( \n  <h1>Позиція курсору: ({mouse.x}, {mouse.y})</h1> \n)} /> \n``` \nТут `MouseTracker` надає логіку відстеження позиції курсору, а компонент, що його використовує, через `render` prop визначає, як ці дані відображаються. Це забезпечує гнучке повторне використання логіки без надмірної залежності.",
    "additionalQuestions": [
      {
        "id": "adv-react-q4-aq1",
        "question": "Яка головна перевага `render props`?",
        "answer": "Головна перевага полягає в можливості повторно використовувати логіку стану та поведінки між компонентами, не обмежуючи їх у тому, як вони відображають UI. Це дозволяє розділити 'що робити' (логіка) від 'як рендерити' (UI)."
      },
      {
        "id": "adv-react-q4-aq2",
        "question": "У чому відмінність між `render props` та `children` як функцією?",
        "answer": "Технічно, `children` може бути також функцією, що робить його варіантом `render props`. Відмінність лише в назві prop: якщо функція передається через `children`, це `props.children`, якщо через іншу назву prop (наприклад, `render`), це `props.render`."
      },
      {
        "id": "adv-react-q4-aq3",
        "question": "Чи є `render props` все ще актуальним після появи React Hooks?",
        "answer": "Хоча `render props` все ще є дійсним патерном, React Hooks значною мірою замінили його для більшості випадків повторного використання логіки стану та поведінки, оскільки хуки пропонують більш простий та елегантний спосіб досягнення того ж результату без додаткової вкладеності JSX."
      }
    ]
  },
  {
    "id": "adv-react-q5",
    "topic": "Advanced React",
    "mainQuestion": "Що таке HOC (Higher-Order Component)? Навіщо він потрібен? Чи може HOC мати власний state?",
    "mainAnswer": "**HOC (Higher-Order Component)** — це просунутий патерн у React для повторного використання логіки компонентів. HOC — це функція, яка приймає React-компонент і повертає **новий, розширений** React-компонент. Він дозволяє 'обернути' існуючі компоненти, додаючи їм додаткові пропси, логіку, стан або поведінку без модифікації вихідного компонента. \n\n**Навіщо потрібен:** \n- **Повторне використання логіки компонентів**: Дозволяє ділитися загальною функціональністю (наприклад, завантаження даних, авторизація, управління підписками) між кількома компонентами. \n- **Зменшення дублювання коду**: Уникає повторення однакової логіки в різних компонентах. \n- **Абстракція**: Приховує складну логіку, надаючи простий інтерфейс. \n\n**Чи може HOC мати власний state?** \n**Так, HOC може мати власний стан.** Оскільки HOC повертає новий React-компонент (який може бути класовим або функціональним), цей новий компонент може мати свій власний внутрішній стан. HOC може використовувати цей стан, щоб впливати на пропси, які він передає 'обгорнутому' компоненту, або для своєї внутрішньої логіки.",
    "additionalQuestions": [
      {
        "id": "adv-react-q5-aq1",
        "question": "Наведіть приклад HOC.",
        "answer": "Наприклад, HOC `withAuth(Component)` може перевіряти статус автентифікації і рендерити `Component`, якщо користувач автентифікований, або перенаправляти його на сторінку входу. \n```jsx \nfunction withAuth(WrappedComponent) { \n  return class extends React.Component { \n    // Тут може бути власний state HOC \n    render() { \n      if (!this.props.isAuthenticated) { \n        return <p>Будь ласка, увійдіть.</p>; \n      } \n      return <WrappedComponent {...this.props} />; \n    } \n  }; \n} \n// Використання: const AuthenticatedDashboard = withAuth(Dashboard); \n```"
      },
      {
        "id": "adv-react-q5-aq2",
        "question": "Які недоліки HOC?",
        "answer": "Недоліки HOC: 'обгортання' компонентів (wrapper hell) може призвести до глибокої вкладеності компонентів у дереві React DevTools, що ускладнює налагодження. Також можуть виникати проблеми з передачею рефів (потрібно використовувати `forwardRef`) та відображенням імен компонентів у DevTools."
      },
      {
        "id": "adv-react-q5-aq3",
        "question": "Яка альтернатива HOC у сучасній розробці React?",
        "answer": "Основними альтернативами HOC після появи React Hooks є **власні (custom) хуки**. Вони дозволяють повторно використовувати логіку стану та ефектів без додавання зайвих обгорток у дерево компонентів, що робить код більш читабельним та плоским."
      }
    ]
  },
  {
    "id": "adv-react-q6",
    "topic": "Advanced React",
    "mainQuestion": "Що таке React.Context? Як і в яких випадках ним користуватися?",
    "mainAnswer": "**React Context** — це механізм у React, який дозволяє передавати дані через дерево компонентів **без необхідності явно передавати props на кожному рівні**. Він призначений для обміну даними, які вважаються 'глобальними' для дерева компонентів (наприклад, тема UI, дані користувача, мова інтерфейсу). Context дозволяє уникнути 'prop drilling' (коли props передаються через багато проміжних компонентів, які їх самі не використовують). \n\n**Як користуватися:** \n1.  **Створення контексту:** Використання `React.createContext()` для створення об'єкта Context. Він повертає об'єкт з двома компонентами: `Provider` та `Consumer` (або просто `Context.Provider` та хук `useContext`). \n2.  **Надання значення (Provider):** Компонент `Provider` обгортає частину дерева компонентів і надає значення, яке буде доступне всім компонентам-споживачам всередині цього дерева. \n3.  **Споживання значення (Consumer/useContext):** \n    - **`Context.Consumer` (класові компоненти або старіший підхід):** Використовує рендер-проп для доступу до значення. \n    - **`useContext` (функціональні компоненти - рекомендовано):** Хук `useContext` дозволяє безпосередньо отримати значення контексту у функціональному компоненті. \n\n**Коли користуватися (типові випадки):** \n- **Глобальні теми UI**: Передача налаштувань світлої/темної теми. \n- **Дані автентифікованого користувача**: Доступ до інформації про поточного користувача. \n- **Локалізація**: Передача поточної мови інтерфейсу. \n- **Невелике управління станом**: Для не дуже складних глобальних станів, що не вимагають Redux. \n\n**Приклад (з `useContext`):** \n```jsx \n// 1. Створення контексту \nconst ThemeContext = React.createContext('light'); \n\n// 2. Надання значення (Provider) \nfunction App() { \n  return ( \n    <ThemeContext.Provider value=\"dark\"> \n      <Toolbar /> \n    </ThemeContext.Provider> \n  ); \n} \n\n// 3. Споживання значення (Consumer) \nfunction Toolbar() { \n  const theme = useContext(ThemeContext); \n  return <p>Поточна тема: {theme}</p>; \n} \n``` \nContext не є заміною для бібліотек управління станом, таких як Redux, для складних сценаріїв, але є чудовим рішенням для простих глобальних даних.",
    "additionalQuestions": [
      {
        "id": "adv-react-q6-aq1",
        "question": "Що таке 'prop drilling' і як Context допомагає його уникнути?",
        "answer": "'Prop drilling' (або 'прокидання пропсів') — це ситуація, коли дані передаються через кілька рівнів компонентів у дереві, навіть якщо проміжні компоненти їх не використовують, а просто \"прокидають\" далі. Context допомагає уникнути цього, дозволяючи даним \"перестрибувати\" через проміжні компоненти і бути доступними безпосередньо там, де вони потрібні."
      },
      {
        "id": "adv-react-q6-aq2",
        "question": "У чому відмінність між `React.createContext` та `useContext`?",
        "answer": "`React.createContext` використовується для *створення* об'єкта контексту. `useContext` — це хук, який використовується у функціональних компонентах для *доступу* до значення, наданого цим контекстом, без необхідності обгортати компонент у `Context.Consumer`."
      },
      {
        "id": "adv-react-q6-aq3",
        "question": "Чи можна використовувати `React.Context` для великої кількості часто оновлюваних даних?",
        "answer": "Ні, не рекомендується. Context оптимізований для передачі \"стабільних\" даних, які змінюються не дуже часто. Якщо значення контексту часто оновлюється, це може призвести до надмірних повторних рендерингів усіх компонентів, які його споживають, оскільки вони всі будуть ререндеритися при кожній зміні. Для частих оновлень або складної логіки стану краще використовувати спеціалізовані бібліотеки управління станом."
      }
    ]
  },
  {
    "id": "adv-react-q7",
    "topic": "Advanced React",
    "mainQuestion": "Що таке імутабельність? Який benefit вона дає в React?",
    "mainAnswer": "**Імутабельність (Immutability)** означає, що об'єкт або значення не може бути змінено після його створення. Замість зміни існуючого об'єкта, створюється його нова копія з необхідними змінами. Оригінальний об'єкт залишається незмінним. У JavaScript примітивні типи (рядки, числа, булеві, `null`, `undefined`) є імутабельними, а об'єкти та масиви — мутабельними. \n\n**Benefit (переваги) в React:** \n1.  **Оптимізація продуктивності**: React (особливо `PureComponent` або `React.memo`) використовує поверхневе порівняння `props` та `state` для визначення, чи потрібно компоненту повторно рендеритися. Якщо ви модифікуєте об'єкт/масив напряму (мутуєте), React може не побачити зміни, оскільки посилання на об'єкт залишається тим самим, і компонент не буде рендеритися, що призведе до розсинхронізації UI. Імутабельність гарантує, що при будь-якій зміні створюється нове посилання, і React достовірно виявить зміну та повторно відрендерить компонент. \n2.  **Простота відстеження змін**: Легше відстежувати, коли і як змінилися дані, оскільки кожна зміна створює нову версію даних. \n3.  **Прогнозованість стану**: Запобігає несподіваним побічним ефектам, коли різні частини програми посилаються на один і той же об'єкт і змінюють його без відома інших. \n4.  **Спрощує відлагодження**: Легше відслідковувати історію змін стану. \n\n**Приклад (мутація vs. імутабельність):** \n```javascript \n// Мутація (погано для React) \nconst arr = [1, 2, 3]; \narr.push(4); // arr тепер [1, 2, 3, 4], але посилання на arr не змінилося \n\n// Імутабельність (добре для React) \nconst arr = [1, 2, 3]; \nconst newArr = [...arr, 4]; // newArr тепер [1, 2, 3, 4], arr залишається [1, 2, 3] \n```",
    "additionalQuestions": [
      {
        "id": "adv-react-q7-aq1",
        "question": "Які методи JavaScript допомагають працювати з імутабельними даними для масивів та об'єктів?",
        "answer": "Для масивів: `concat()`, `slice()`, `map()`, `filter()`, `reduce()`, оператор спред `...` (`[...arr, item]`). \nДля об'єктів: `Object.assign({}, obj, { key: value })`, оператор спред `...` (`{...obj, key: value}`). \nДля глибоких змін можуть використовуватися бібліотеки, такі як Immer."
      },
      {
        "id": "adv-react-q7-aq2",
        "question": "Чи є `PureComponent` або `React.memo` \"глибоким\" порівнянням?",
        "answer": "Ні, `PureComponent` та `React.memo` виконують **поверхневе порівняння** (shallow comparison) `props` та `state`. Це означає, що вони перевіряють, чи змінилися посилання на об'єкти/масиви, а не їхній вміст. Тому імутабельність є критично важливою для їхньої коректної роботи."
      },
      {
        "id": "adv-react-q7-aq3",
        "question": "Які бібліотеки існують для роботи з імутабельними даними?",
        "answer": "Популярні бібліотеки: **Immer** (найбільш поширений, дозволяє писати мутуючий код, який потім перетворюється на імутабельні оновлення), Immutable.js (більш об'ємний, створює власні імутабельні структури даних)."
      }
    ]
  },
  {
    "id": "adv-react-q8",
    "topic": "Advanced React",
    "mainQuestion": "Як можна оптимізувати рендеринг компонентів? (`keys`, `shouldComponentUpdate`, `PureComponent`, `React.memo`)",
    "mainAnswer": "Оптимізація рендерингу компонентів у React є критично важливою для продуктивності великих застосунків. Основна мета — мінімізувати кількість непотрібних повторних рендерингів. \n\n1.  **`key` (ключі)**: \n    -   **Що це:** Спеціальний строковий атрибут, який надається елементам списків (наприклад, при використанні `map`). \n    -   **Для чого:** Допомагає React ефективно ідентифікувати елементи в списку, відстежувати їхні зміни, додавання, видалення та перевпорядкування. Це дозволяє React оптимізувати оновлення DOM, повторно використовувати існуючі елементи замість перерендерингу всього списку. \n\n2.  **`shouldComponentUpdate` (тільки класові компоненти)**: \n    -   **Що це:** Метод життєвого циклу класового компонента, який викликається перед кожним повторним рендерингом (крім початкового). Він приймає `nextProps` та `nextState` і має повернути `true` (для рендерингу) або `false` (для пропуску рендерингу). \n    -   **Для чого:** Дозволяє вручну контролювати, коли компонент повинен оновлюватися, запобігаючи непотрібним рендерингам, якщо props або state не змінилися значуще. \n    -   **Недолік:** Потрібно обережно реалізувати логіку порівняння, щоб не допустити помилок. \n\n3.  **`PureComponent` (тільки класові компоненти)**: \n    -   **Що це:** Базовий клас для компонентів-класів, який виконує поверхневе порівняння (shallow comparison) `props` та `state` у своєму `shouldComponentUpdate` за замовчуванням. \n    -   **Для чого:** Автоматично оптимізує компоненти, запобігаючи рендерингу, якщо `props` та `state` (поверхнево) не змінилися. \n    -   **Важливо:** Працює ефективно лише з **імутабельними даними**, оскільки робить поверхневе порівняння посилань. \n\n4.  **`React.memo` (тільки функціональні компоненти)**: \n    -   **Що це:** Higher-Order Component, який обгортає функціональний компонент і мемоізує результат його рендерингу. Він повторно рендерить компонент лише тоді, коли його `props` змінилися (за замовчуванням, поверхневе порівняння). \n    -   **Для чого:** Аналогічно `PureComponent` для функціональних компонентів, дозволяє оптимізувати продуктивність шляхом запобігання непотрібним рендерингам. \n    -   **Кастомне порівняння:** Можна передати другий аргумент — функцію порівняння, щоб визначити власну логіку порівняння props.",
    "additionalQuestions": [
      {
        "id": "adv-react-q8-aq1",
        "question": "Коли `React.memo` не спрацює для оптимізації?",
        "answer": "`React.memo` (як і `PureComponent`) не спрацює ефективно, якщо: \n1.  Пропси змінюються дуже часто. \n2.  Пропси містять об'єкти або функції, які створюються на кожному рендерингу батьківського компонента (потрібно використовувати `useCallback` або `useMemo` для мемоізації цих пропсів). \n3.  Компонент використовує `context` і `context` часто оновлюється."
      },
      {
        "id": "adv-react-q8-aq2",
        "question": "Чи завжди варто використовувати `React.memo` для всіх функціональних компонентів?",
        "answer": "Ні, не завжди. `React.memo` додає невеликі накладні витрати на порівняння пропсів. Його варто використовувати лише тоді, коли ви стикаєтеся з проблемами продуктивності через надмірні рендеринги, і коли компонент рендериться часто з тими ж пропсами."
      },
      {
        "id": "adv-react-q8-aq3",
        "question": "Як `key` пов'язаний з оптимізацією Virtual DOM?",
        "answer": "`key` є критично важливим для алгоритму 'reconciliation' (узгодження) React. Він допомагає React точно визначити, які елементи в списку були додані, видалені, змінені або переміщені, дозволяючи йому виконувати мінімально необхідні маніпуляції з реальним DOM."
      }
    ]
  },
  {
    "id": "adv-react-q9",
    "topic": "Advanced React",
    "mainQuestion": "Що таке мемоізація?",
    "mainAnswer": "**Мемоізація (Memoization)** — це техніка оптимізації, яка полягає в кешуванні результатів виконання дорогих функцій і поверненні кешованого результату, якщо ті ж вхідні дані з'являються знову. Це дозволяє уникнути повторного виконання обчислень, якщо залежності не змінилися. \n\nУ React мемоізація використовується для оптимізації рендерингу компонентів та обчислень. \n\n**Приклади в React:** \n-   **`React.memo`**: Мемоізує функціональні компоненти, запобігаючи їхньому повторному рендерингу, якщо їхні пропси не змінилися. \n-   **`useMemo` хук**: Мемоізує обчислені значення. Виконує функцію лише тоді, коли змінилися її залежності. \n    ```jsx \n    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]); \n    ``` \n-   **`useCallback` хук**: Мемоізує функції. Повертає мемоізовану версію функції, яка змінюється лише тоді, коли змінюються її залежності. Це корисно для передачі колбеків як пропсів до мемоізованих дочірніх компонентів, щоб уникнути їхнього непотрібного рендерингу. \n    ```jsx \n    const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]); \n    ``` \nМемоізація допомагає уникнути зайвих обчислень та рендерингів, коли дані не змінилися, тим самим покращуючи продуктивність застосунку.",
    "additionalQuestions": [
      {
        "id": "adv-react-q9-aq1",
        "question": "Коли варто використовувати `useMemo`?",
        "answer": "`useMemo` варто використовувати для мемоізації результатів дорогих обчислень, які залежать від певних значень. Якщо ці значення не змінилися між рендерами, `useMemo` поверне кешований результат, уникнувши повторного виконання обчислень. Це особливо корисно, коли обчислення займає багато часу, і його результат використовується в рендерингу або передається дочірнім компонентам."
      },
      {
        "id": "adv-react-q9-aq2",
        "question": "Коли варто використовувати `useCallback`?",
        "answer": "`useCallback` варто використовувати для мемоізації функцій-колбеків, які передаються як пропси до мемоізованих дочірніх компонентів (`React.memo`). Якщо функція не мемоізована, вона буде створюватися на кожному рендері батьківського компонента, і дочірній компонент, який мемоізований за допомогою `React.memo`, буде непотрібно перерендеритися, оскільки посилання на функцію зміниться."
      },
      {
        "id": "adv-react-q9-aq3",
        "question": "Чи потрібно мемоізувати кожну функцію та значення?",
        "answer": "Ні, надмірна мемоізація може мати негативний вплив на продуктивність, оскільки сам механізм мемоізації має накладні витрати (потребує пам'ять для кешу та час для порівняння залежностей). Мемоізувати варто лише ті обчислення або функції, які дійсно є 'дорогими' або якщо вони викликають непотрібні рендеринги дочірніх компонентів."
      }
    ]
  },
  {
    "id": "adv-react-q10",
    "topic": "Advanced React",
    "mainQuestion": "Як завантажити дані з сервера в React?",
    "mainAnswer": "У React завантаження даних з сервера (data fetching) зазвичай відбувається у методах життєвого циклу класових компонентів або за допомогою хука `useEffect` у функціональних компонентах. \n\n**Основні підходи:** \n1.  **`componentDidMount` (для класових компонентів):** \n    -   Найкраще місце для першого завантаження даних. Запит виконується один раз після того, як компонент вмонтовано в DOM. \n    -   `fetch('your-api-endpoint').then(res => res.json()).then(data => this.setState({ data }));` \n\n2.  **`useEffect` (для функціональних компонентів):** \n    -   Універсальний хук для побічних ефектів, який може замінити `componentDidMount`, `componentDidUpdate` та `componentWillUnmount`. \n    -   Щоб імітувати `componentDidMount` (виконати один раз), передайте порожній масив залежностей `[]` другим аргументом. \n    -   ```jsx \n        import React, { useState, useEffect } from 'react'; \n        function MyComponent() { \n          const [data, setData] = useState(null); \n          useEffect(() => { \n            fetch('your-api-endpoint') \n              .then(res => res.json()) \n              .then(data => setData(data)); \n          }, []); // Пустий масив означає, що ефект запускається лише один раз \n          return <div>{data ? <p>Дані: {data.message}</p> : <p>Завантаження...</p>}</div>; \n        } \n        ``` \n\n**Інші підходи та інструменти:** \n-   **`componentDidUpdate`**: Для завантаження даних при зміні певних props (наприклад, ID користувача). \n-   **Бібліотеки для HTTP-запитів**: `axios` (популярний, надає більше функціональності, ніж вбудований `fetch`). \n-   **Бібліотеки для управління станом та кешування даних**: `React Query` (TanStack Query), `SWR`, `Apollo Client` (для GraphQL). Вони спрощують кешування, ревалідацію, обробку помилок та інше.",
    "additionalQuestions": [
      {
        "id": "adv-react-q10-aq1",
        "question": "Чому не варто завантажувати дані у `render` методі?",
        "answer": "Завантаження даних у `render` призведе до нескінченних циклів рендерингу, оскільки встановлення нового стану після отримання даних викличе повторний рендеринг, який знову ініціює завантаження даних, і так далі. `render` повинен бути 'чистою функцією' від `props` і `state`."
      },
      {
        "id": "adv-react-q10-aq2",
        "question": "Як обробляти помилки при завантаженні даних у React?",
        "answer": "Помилки зазвичай обробляються за допомогою блоків `try...catch` (з `async/await`) або методом `.catch()` (з `Promise` та `fetch`/`axios`). Результат помилки можна зберігати у стані компонента і відображати користувачеві відповідне повідомлення."
      },
      {
        "id": "adv-react-q10-aq3",
        "question": "Що таке 'race conditions' при завантаженні даних і як їх уникнути?",
        "answer": "'Race conditions' виникають, коли виконується кілька асинхронних запитів, і результат пізнішого запиту приходить раніше, ніж результат попереднього, що може призвести до відображення застарілих даних. Уникнути цього можна, наприклад, за допомогою AbortController API (для `fetch`), або за допомогою більш досконалих бібліотек, які мають вбудовані механізми управління конкуруючими запитами (`React Query`, `SWR`)."
      }
    ]
  },
  {
    "id": "adv-react-q11",
    "topic": "Advanced React",
    "mainQuestion": "Які особливості `static getDerivedStateFromProps`?",
    "mainAnswer": "`static getDerivedStateFromProps(props, state)` — це метод життєвого циклу класового компонента React (статичний метод), який викликається безпосередньо перед кожним рендерингом, як при монтуванні, так і при оновленні компонента. \n\n**Особливості:** \n-   **Статичний метод**: Він не має доступу до `this` екземпляра компонента. \n-   **Повертає об'єкт або `null`**: \n    -   Якщо повертає об'єкт, цей об'єкт буде об'єднаний з поточним станом компонента. \n    -   Якщо повертає `null`, нічого не змінюється в стані. \n-   **Призначений для синхронізації стану з пропсами**: Його єдина мета — дозволити компоненту оновити свій внутрішній стан на основі змін у `props`. \n-   **Використовується обережно**: Це досить рідкісний випадок використання, і React рекомендує використовувати його лише для строго контрольованих сценаріїв, де стан повністю залежить від props. Зазвичай його використовують для очищення або скидання внутрішнього стану компонента, коли певні props змінюються. \n-   **Не викликає побічних ефектів**: Оскільки він є статичним, він не повинен виконувати побічні ефекти (наприклад, мережеві запити, підписки), оскільки він може бути викликаний багато разів і не завжди призводить до фактичного оновлення DOM. Для побічних ефектів використовуйте `componentDidMount` або `componentDidUpdate` (або `useEffect`). \n\n**Приклад:** \n```jsx \nclass MyComponent extends React.Component { \n  state = { \n    prevPropValue: null, \n    currentValue: null \n  }; \n  static getDerivedStateFromProps(nextProps, prevState) { \n    if (nextProps.someValue !== prevState.prevPropValue) { \n      return { \n        prevPropValue: nextProps.someValue, \n        currentValue: nextProps.someValue.toUpperCase() \n      }; \n    } \n    return null; \n  } \n  render() { \n    return <p>{this.state.currentValue}</p>; \n  } \n} \n``` \nУ функціональних компонентах його роль частково може виконувати `useState` з функцією ініціалізації або `useEffect` з обережним управлінням залежностями.",
    "additionalQuestions": [
      {
        "id": "adv-react-q11-aq1",
        "question": "Які типові помилки при використанні `getDerivedStateFromProps`?",
        "answer": "Типові помилки: використання його для побічних ефектів, використання його замість `componentDidUpdate` або `useEffect`, або повернення стану, який не повністю залежить від пропсів, що призводить до непередбачуваної поведінки."
      },
      {
        "id": "adv-react-q11-aq2",
        "question": "Чому цей метод був доданий до React?",
        "answer": "Він був доданий як безпечніший і передбачуваний спосіб обробки 'deriving state from props' порівняно зі старим `componentWillReceiveProps`, який мав проблеми з асинхронним рендерингом і потенційними 'багами'."
      },
      {
        "id": "adv-react-q11-aq3",
        "question": "Чи впливає `getDerivedStateFromProps` на продуктивність?",
        "answer": "Так, оскільки він викликається при кожному рендерингу (навіть якщо `props` не змінилися), важливо, щоб логіка всередині цього методу була максимально легкою і не виконувала дорогих обчислень. Якщо він повертає `null`, це не обов'язково означає, що рендеринг буде пропущено; він лише означає, що стан не буде оновлено на цьому етапі."
      }
    ]
  },
  {
    "id": "adv-react-q12",
    "topic": "Advanced React",
    "mainQuestion": "Які є способи роботи з CSS в React? Плюси / мінуси",
    "mainAnswer": "У React існує багато способів стилізації компонентів, кожен зі своїми плюсами та мінусами: \n\n1.  **Звичайний CSS (`.css` файли)**: \n    -   **Як:** Імпорт глобальних або модульних CSS-файлів. \n    -   **Плюси:** Простота, знайомий синтаксис, кешування браузером. \n    -   **Мінуси:** Глобальна область видимості (можливі конфлікти імен класів), складно керувати у великих проектах. \n\n2.  **CSS Modules (`.module.css` файли)**: \n    -   **Як:** Імпорт CSS-файлів як об'єктів. Кожен клас автоматично отримує унікальне ім'я, щоб уникнути конфліктів. \n    -   **Плюси:** Інкапсуляція стилів на рівні компонента (немає глобальних конфліктів), зрозуміла залежність стилів від компонента. \n    -   **Мінуси:** Потрібен бандлер (наприклад, Webpack) для підтримки. \n\n3.  **Inline Styles (Інлайн-стилі)**: \n    -   **Як:** Стилі пишуться як JavaScript-об'єкт в атрибуті `style` JSX-елемента. \n    -   **Плюси:** Стилі інкапсульовані в компоненті, динамічні стилі легко застосовувати. \n    -   **Мінуси:** Не підтримують псевдо-класи (`:hover`, `:active`), псевдо-елементи, медіа-запити. Немає автоматичного вендорного префіксингу. Код стає менш читабельним для великих стилів. \n\n4.  **CSS-in-JS (наприклад, Styled Components, Emotion)**: \n    -   **Як:** Стилі пишуться безпосередньо в JavaScript-файлах, зазвичай за допомогою шаблонних літералів. Бібліотеки створюють унікальні імена класів і впроваджують стилі в DOM. \n    -   **Плюси:** Повна інкапсуляція стилів на рівні компонента, динамічні стилі на основі props, теми, підтримка всіх CSS-функцій, автоматичний вендорний префіксинг. \n    -   **Мінуси:** Додає додаткову залежність, може збільшити розмір бандлу, невелика накладні витрати на виконання JavaScript. \n\n5.  **Препроцесори CSS (Sass, Less, Stylus)**: \n    -   **Як:** Пишете CSS з розширеними функціями (змінні, міксини, вкладеність), які потім компілюються в чистий CSS. \n    -   **Плюси:** Покращують організацію CSS, розширюють можливості синтаксису. \n    -   **Мінуси:** Все ще мають глобальні проблеми (якщо не використовуються з методологіями типу BEM) та можуть бути повільнішими для великих проектів.",
    "additionalQuestions": [
      {
        "id": "adv-react-q12-aq1",
        "question": "Який підхід до стилізації рекомендований для більшості нових React-проектів?",
        "answer": "Для більшості нових React-проектів часто рекомендується комбінація **CSS Modules** для загальних компонентів (де потрібна інкапсуляція, але простий CSS) та **CSS-in-JS** бібліотек (наприклад, Styled Components або Emotion) для більш складних, динамічних або тематичних стилів. Це дозволяє використовувати сильні сторони кожного підходу."
      },
      {
        "id": "adv-react-q12-aq2",
        "question": "Чому інлайн-стилі обмежені в React?",
        "answer": "Інлайн-стилі обмежені, тому що вони не підтримують: \n-   **Псевдо-класи** (`:hover`, `:focus`, `:active`) \n-   **Псевдо-елементи** (`::before`, `::after`) \n-   **Медіа-запити** (для адаптивного дизайну) \n-   **Ключові кадри для анімації** (`@keyframes`) \nТакож вони не є частиною файлу стилів, що може ускладнити їх централізоване управління."
      },
      {
        "id": "adv-react-q12-aq3",
        "question": "Що таке 'Atomic CSS' і як він пов'язаний з React?",
        "answer": "Atomic CSS (або Utility-first CSS, наприклад, Tailwind CSS) — це підхід, де стилі створюються як дуже маленькі, одноцільові класи (наприклад, `text-red-500`, `flex`, `p-4`), а потім застосовуються безпосередньо в HTML/JSX. Це може дуже добре поєднуватися з React, оскільки дозволяє стилізувати компоненти без написання додаткового CSS-коду і мінімізує проблеми з конфліктами імен, але може призвести до 'захламлення' розмітки великою кількістю класів."
      }
    ]
  },
  {
    "id": "adv-react-q13",
    "topic": "Advanced React",
    "mainQuestion": "Переваги функціональних компонентів над повноцінними компонентами (класовими компонентами)",
    "mainAnswer": "Після появи React Hooks у версії 16.8, **функціональні компоненти** значно покращилися і тепер є рекомендованим способом написання React-компонентів, пропонуючи ряд переваг над класовими компонентами: \n\n1.  **Простота та читабельність**: \n    -   Вони є простими JavaScript-функціями, що легше читати та розуміти. \n    -   Усувають необхідність використання `this` контексту та прив'язки методів, що є поширеним джерелом помилок у класових компонентах. \n\n2.  **Повторне використання логіки (Custom Hooks)**: \n    -   Хуки дозволяють легко витягувати та повторно використовувати логіку стану та побічних ефектів між компонентами, не використовуючи складніші патерни HOC або render props. \n\n3.  **Згрупована логіка**: \n    -   Хук `useEffect` дозволяє групувати пов'язану логіку життєвого циклу (наприклад, підписка та відписка) в одному місці, тоді як у класових компонентах ця логіка часто розкидана по різних методах (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`). \n\n4.  **Менше коду**: \n    -   Зазвичай функціональні компоненти вимагають менше boilerplate-коду. \n\n5.  **Легкість тестування**: \n    -   Будучи функціями, вони легше піддаються модульному тестуванню. \n\n6.  **Потенціал для оптимізації**: \n    -   React може краще оптимізувати функціональні компоненти у майбутньому, оскільки вони не мають стану, який потрібно перевіряти в кожному екземплярі.",
    "additionalQuestions": [
      {
        "id": "adv-react-q13-aq1",
        "question": "Чи варто переписувати всі існуючі класові компоненти на функціональні?",
        "answer": "Зазвичай, ні. Якщо класовий компонент працює коректно і не є джерелом проблем з продуктивністю або читабельністю, немає нагальної потреби його переписувати. React підтримує обидва підходи. Переписувати варто, якщо є очевидні переваги (наприклад, для рефакторингу, покращення підтримки, або для інтеграції з новою функціональністю на хуках)."
      },
      {
        "id": "adv-react-q13-aq2",
        "question": "Який єдиний випадок, коли функціональний компонент не може повністю замінити класовий?",
        "answer": "Єдиний випадок, де класові компоненти все ще мають унікальну функціональність, це `componentDidCatch` та `getDerivedStateFromError` (методи життєвого циклу для обробки помилок), які використовуються для створення **Error Boundaries**. Хуки не надають прямої заміни для цієї функціональності (хоча ви можете використовувати бібліотеки, які надають Error Boundaries як компоненти)."
      },
      {
        "id": "adv-react-q13-aq3",
        "question": "Як функціональні компоненти працюють зі станом без `this.state`?",
        "answer": "Функціональні компоненти працюють зі станом за допомогою хука `useState`. `useState` повертає масив, що містить поточне значення стану та функцію-сеттер для його оновлення. Це дозволяє компоненту зберігати та керувати своїм станом без необхідності бути класом."
      }
    ]
  },
  {
    "id": "adv-react-q14",
    "topic": "Advanced React",
    "mainQuestion": "Що таке React Router?",
    "mainAnswer": "**React Router** — це найпопулярніша стандартна бібліотека для декларативного маршрутизації в React-застосунках. Вона дозволяє синхронізувати UI вашого застосунку з URL-адресою, що робить його повноцінним односторінковим застосунком (SPA) з можливістю навігації між різними \"сторінками\" без перезавантаження сторінки. \n\n**Основні можливості:** \n-   **Декларативне оголошення маршрутів**: Ви визначаєте маршрути за допомогою JSX, що робить їх легко читабельними та інтегрованими з вашими компонентами. \n-   **Динамічна маршрутизація**: Можливість створення маршрутів з динамічними сегментами (наприклад, `/users/:id`). \n-   **Вкладена маршрутизація**: Компоненти можуть мати власні, вкладені маршрути. \n-   **Навігація**: Надає компоненти (`<Link>`, `<NavLink>`) та хуки (`useNavigate`, `useLocation`, `useParams`) для програмної та декларативної навігації. \n-   **Історія браузера**: Інтегрується з History API браузера для безшовного управління URL-адресами. \n\n**Основні компоненти/хуки:** \n-   **`<BrowserRouter>` / `<HashRouter>`**: Компоненти, які обгортають ваш застосунок і надають функціональність маршрутизації. `BrowserRouter` використовує History API, `HashRouter` — хеш у URL. \n-   **`<Routes>`**: Контейнер для `<Route>` елементів, який рендерить перший `<Route>`, що збігається з поточним URL. \n-   **`<Route>`**: Визначає відповідність між URL-шляхом та компонентом, який має бути відрендерений. \n-   **`<Link>` / `<NavLink>`**: Компоненти для навігації між сторінками. `<NavLink>` додає стилізацію активного посилання. \n-   **`useNavigate`**: Хук для програмної навігації. \n-   **`useParams`**: Хук для доступу до динамічних параметрів URL. \n-   **`useLocation`**: Хук для доступу до поточного об'єкта URL-адреси.",
    "additionalQuestions": [
      {
        "id": "adv-react-q14-aq1",
        "question": "У чому перевага використання `React Router` над ручною маршрутизацією у SPA?",
        "answer": "Ручна маршрутизація вимагає багато boilerplate-коду для управління URL, History API, відображення компонентів на основі шляху та підтримки станів. `React Router` надає готові абстракції та інструменти, які значно спрощують ці завдання, роблячи код чистішим, легшим для підтримки та передбачуваним."
      },
      {
        "id": "adv-react-q14-aq2",
        "question": "Яка різниця між `<BrowserRouter>` та `<HashRouter>`?",
        "answer": "`<BrowserRouter>` використовує History API (HTML5 API) для керування URL-адресами, що дає чисті URL (наприклад, `example.com/about`). `HashRouter` використовує хеш-частину URL (наприклад, `example.com/#/about`), що робить його сумісним зі старими браузерами або середовищами, де серверне налаштування для прямого доступу до маршрутів неможливе."
      },
      {
        "id": "adv-react-q14-aq3",
        "question": "Як обробити '404 Not Found' сторінку за допомогою `React Router`?",
        "answer": "Для обробки 404 сторінки ви можете додати `<Route path=\"*\" element={<NotFoundPage />} />` як останній маршрут всередині компонента `<Routes>`. Маршрут `*` (зірочка) буде відповідати будь-якому URL, який не збігся з жодним з попередніх маршрутів."
      }
    ]
  },
  {
    "id": "adv-react-q15",
    "topic": "Advanced React",
    "mainQuestion": "Що таке Server-Side Rendering (SSR) в контексті React?",
    "mainAnswer": "**Server-Side Rendering (SSR)**, або серверний рендеринг, в контексті React — це техніка, при якій початковий HTML-код для React-застосунку генерується на сервері при кожному запиті, а потім надсилається клієнту (браузеру). Замість того, щоб надсилати порожній HTML-файл та JavaScript, який потім будує UI на клієнті, SSR відправляє вже готовий HTML. \n\nПісля того, як HTML-файл завантажений браузером, React на клієнті \"оживляє\" його (процес називається **гідратацією - hydration**), прикріплюючи обробники подій та ініціалізуючи стан, що дозволяє застосунку функціонувати як звичайний React SPA. \n\n**Основні переваги SSR:** \n-   **SEO (Search Engine Optimization)**: Пошукові роботи можуть легше індексувати вміст сторінки, оскільки вони отримують вже відрендерений HTML. Це особливо важливо для контентно-орієнтованих сайтів. \n-   **Покращена продуктивність (Perceived Performance)**: Користувачі бачать вміст сторінки швидше, оскільки HTML вже готовий. Це покращує 'час до першого змістовного рендерингу' (First Contentful Paint) та 'час до інтерактивності' (Time to Interactive). \n-   **Кращий користувацький досвід**: Для користувачів з повільним інтернет-з'єднанням або на слабких пристроях. \n\n**Недоліки SSR:** \n-   **Складність налаштування**: Вимагає налаштування серверного середовища для рендерингу React-компонентів. \n-   **Більше навантаження на сервер**: Сервер повинен рендерити HTML для кожного запиту, що може збільшити навантаження. \n-   **Збільшений час до першого байта (TTFB)**: Час відповіді сервера може бути довшим, оскільки йому потрібно відрендерити React-застосунок перед відправкою. \n-   **Більша складність для налагодження та розгортання.** \n\nПопулярні фреймворки, такі як **Next.js** та **Gatsby**, значно спрощують реалізацію SSR або статичної генерації сайтів (SSG) у React.",
    "additionalQuestions": [
      {
        "id": "adv-react-q15-aq1",
        "question": "У чому різниця між SSR та Client-Side Rendering (CSR)?",
        "answer": "При **CSR** (Client-Side Rendering) браузер отримує майже порожній HTML-файл і потім завантажує JavaScript, який будує весь UI на клієнті. При **SSR** (Server-Side Rendering) сервер вже надсилає повністю сформований HTML, а JavaScript на клієнті лише \"оживляє\" його."
      },
      {
        "id": "adv-react-q15-aq2",
        "question": "Що таке \"гідратація\" (Hydration) в SSR?",
        "answer": "Гідратація — це процес, під час якого клієнтський JavaScript-код React \"прикріплюється\" до вже відрендереного сервером HTML. React аналізує DOM, відтворений сервером, і додає обробники подій та ініціалізує внутрішній стан, перетворюючи статичний HTML на інтерактивний React-застосунок."
      },
      {
        "id": "adv-react-q15-aq3",
        "question": "Коли варто використовувати SSR, а коли CSR?",
        "answer": "Використовуйте **SSR**, коли SEO є критично важливим, або коли вам потрібен дуже швидкий 'час до першого змістовного рендерингу' для покращення UX (наприклад, для блогових платформ, електронної комерції). \nВикористовуйте **CSR** для застосунків, де SEO менш важливе, і коли більша частина даних завантажується після першого рендерингу (наприклад, адмін-панелі, веб-додатки, які сильно залежать від взаємодії користувача)."
      }
    ]
  },
  {
    "id": "adv-react-q16",
    "topic": "Advanced React",
    "mainQuestion": "Що таке React Context API?",
    "mainAnswer": "**React Context API** — це вбудований механізм у React, який дозволяє передавати дані через дерево компонентів без необхідності передавати їх через `props` на кожному рівні. Це особливо корисно для глобальних даних, таких як налаштування теми, мова, автентифікація користувача тощо. \n\n**Основні компоненти Context API:** \n-   **`React.createContext()`**: Створює новий контекст. Повертає об'єкт з двома компонентами: `Provider` та `Consumer`. \n-   **`<Context.Provider>`**: Компонент, який надає значення контексту всім дочірнім компонентам. Він приймає `value` пропс, який буде доступний для споживачів контексту. \n-   **`<Context.Consumer>`**: Компонент, який дозволяє отримувати значення контексту. Він використовує функцію як дочірній елемент (render prop) для доступу до значення контексту. \n-   **`useContext(Context)`**: Хук, який дозволяє отримувати значення контексту в функціональних компонентах без використання `<Context.Consumer>`. \n\n**Приклад використання Context API:** \n```jsx \nconst ThemeContext = React.createContext('light'); // Створення контексту з дефолтним значенням 'light' \nfunction App() { \n  return ( \n    <ThemeContext.Provider value=\"dark\"> {/* Надання значення 'dark' */} \n      <Toolbar /> \n    </ThemeContext.Provider> \n  ); \n} \nfunction Toolbar() { \n  return ( \n    <div> \n      <ThemedButton /> {/* Дочірній компонент, який використовує контекст */} \n    </div> \n  ); \n} \nfunction ThemedButton() { \n  const theme = useContext(ThemeContext); // Отримання значення контексту \n  return <button className={theme}>Кнопка з темою {theme}</button>; \n} \n``` \n\n**Переваги Context API:** \n-   **Уникнення \"пробросу пропсів\" (prop drilling)**: Дозволяє передавати дані на глибокі рівні дерева компонентів без необхідності передавати їх через кожен проміжний компонент. \n-   **Глобальний стан**: Зручно для управління глобальним станом, який потрібен багатьом компонентам. \n\n**Недоліки Context API:** \n-   **Перерендеринг**: Якщо значення контексту змінюється, всі компоненти, які його споживають, будуть перерендерені, що може вплинути на продуктивність. Щоб уникнути цього, можна використовувати `React.memo` або розділяти контексти на менші частини.",
    "additionalQuestions": [
      {
        "id": "adv-react-q16-aq1",
        "question": "Коли варто використовувати Context API?",
        "answer": "Context API варто використовувати, коли вам потрібно передати дані, які використовуються багатьма компонентами на різних рівнях дерева, і ці дані не змінюються часто. Наприклад, налаштування теми, мова інтерфейсу, автентифікація користувача."
      },
      {
        "id": "adv-react-q16-aq2",
        "question": "Чи можна використовувати Context API для управління станом додатку?",
        "answer": "Так, Context API може бути використаний для управління станом додатку, але для складніших сценаріїв (наприклад, з частими оновленнями стану) краще використовувати бібліотеки для управління станом (Redux, MobX) або React Hooks (`useReducer`, `useState`), оскільки вони оптимізовані для таких випадків."
      },
      {
        "id": "adv-react-q16-aq3",
        "question": "Чи можна вкладати `Provider` в інші компоненти?",
        "answer": "Так, ви можете вкладати кілька `Provider` один в одного. Це дозволяє створювати контексти з різними значеннями для різних частин дерева компонентів. Кожен дочірній компонент буде отримувати значення найближчого до нього `Provider`."
      }
    ]
  },
  {
    "id": "adv-react-q17",
    "topic": "Advanced React",
    "mainQuestion": "Що таке React Hooks?",
    "mainAnswer": "**React Hooks** — це функції, які дозволяють використовувати стан та інші можливості React у функціональних компонентах. Вони були введені в React 16.8 і дозволяють писати компоненти без класів, зберігаючи при цьому всі переваги управління станом та побічними ефектами. \n\n**Основні правила використання Hooks:** \n1.  **Використовувати тільки всередині функціональних компонентів або власних хуків**: Не можна викликати хуки в звичайних JavaScript-функціях, умовах або циклах. \n2.  **Викликати хуки на верхньому рівні**: Це дозволяє React правильно відстежувати порядок викликів хуків між рендерами. \n\n**Основні хуки:** \n-   **`useState`**: Дозволяє додавати стан до функціональних компонентів. Повертає масив з поточним значенням стану та функцією для його оновлення. \n-   **`useEffect`**: Виконує побічні ефекти (наприклад, запити до API, підписки) після кожного рендерингу або при зміні залежностей. Може замінити `componentDidMount`, `componentDidUpdate` та `componentWillUnmount`. \n-   **`useContext`**: Дозволяє отримувати значення контексту без використання `<Context.Consumer>`. \n-   **`useReducer`**: Альтернатива `useState`, яка дозволяє управляти складним станом за допомогою редюсера (функції, яка приймає попередній стан і дію та повертає новий стан). \n-   **`useRef`**: Дозволяє створювати реф (посилання на DOM-елемент або зберігати будь-яке значення, яке не викликає повторний рендеринг при зміні). \n-   **`useMemo`**: Оптимізує обчислення, кешуючи результат функції до наступного рендерингу, якщо залежності не змінилися. \n-   **`useCallback`**: Повертає мемоізовану версію функції, яка змінюється лише при зміні залежностей, що корисно для оптимізації передачі колбеків у дочірні компоненти. \n\n**Приклад використання хуків:** \n```jsx \nimport React, { useState, useEffect } from 'react'; \nfunction Counter() { \n  const [count, setCount] = useState(0); // Використання useState для стану лічильника \n  useEffect(() => { // Використання useEffect для побічного ефекту \n    document.title = `Ви натиснули ${count} разів`; // Оновлення заголовку документа \n  }, [count]); // Залежність від count \n  return ( \n    <div> \n      <p>Ви натиснули {count} разів</p> \n      <button onClick={() => setCount(count + 1)}>Натиснути</button> \n    </div> \n  ); \n} \n```",
    "additionalQuestions": [
      {
        "id": "adv-react-q17-aq1",
        "question": "Чому хуки не можна викликати в умовах або циклах?",
        "answer": "Хуки повинні викликатися в однаковому порядку при кожному рендері, щоб React міг правильно відстежувати їх стан. Якщо ви викликаєте хуки в умовах або циклах, це може призвести до порушення порядку викликів і, як наслідок, до помилок у стані."
      },
      {
        "id": "adv-react-q17-aq2",
        "question": "Що таке власні хуки (Custom Hooks)?",
        "answer": "Власні хуки — це функції, які використовують інші хуки та дозволяють вам витягувати та повторно використовувати логіку стану та побічних ефектів між компонентами. Вони починаються з `use`, наприклад, `useFetch`, `useForm`, і можуть приймати параметри та повертати значення."
      },
      {
        "id": "adv-react-q17-aq3",
        "question": "Як працює `useEffect` і коли його використовувати?",
        "answer": "`useEffect` виконує побічні ефекти після кожного рендерингу компонента. Ви можете вказати залежності, при зміні яких ефект буде виконаний. Використовуйте його для запитів до API, підписок, маніпуляцій з DOM тощо. Якщо ви повертаєте функцію з `useEffect`, вона буде виконана перед наступним рендерингом або при розмонтуванні компонента."
      }
    ]
  }
]