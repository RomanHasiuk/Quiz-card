[
  {
    "id": "web_001",
    "topic": "Web",
    "mainQuestion": "У чому різниця між відносним та абсолютним шляхом?",
    "mainAnswer": "**Абсолютний шлях** – це повний шлях до файлу або ресурсу, починаючи від кореня файлової системи або домену (наприклад, `https://example.com/images/logo.png` або `/home/user/documents/file.txt`). **Відносний шлях** – це шлях до файлу або ресурсу відносно поточного місцезнаходження або поточного документа (наприклад, `../images/logo.png` або `css/style.css`).",
    "additionalQuestions": [
      {
        "id": "web_001_1",
        "question": "Коли варто використовувати абсолютний шлях?",
        "answer": "Абсолютні шляхи ідеально підходять, коли вам потрібно вказати точне місце розташування ресурсу, незалежно від того, де знаходиться поточний файл, наприклад, для зовнішніх ресурсів або кореневих посилань."
      },
      {
        "id": "web_001_2",
        "question": "Коли доцільніше використовувати відносний шлях?",
        "answer": "Відносні шляхи краще використовувати для внутрішніх посилань у межах одного проєкту, оскільки вони роблять код більш портативним та не залежать від зміни домену або кореневої директорії."
      },
      {
        "id": "web_001_3",
        "question": "Як `.` та `..` використовуються у відносних шляхах?",
        "answer": "`./` позначає поточний каталог, а `../` позначає батьківський каталог (на один рівень вище)."
      }
    ]
  },
  {
    "id": "web_002",
    "topic": "Web",
    "mainQuestion": "Що таке скрінрідери?",
    "mainAnswer": "**Скрінрідери** (screen readers) – це програмне забезпечення, яке допомагає людям з вадами зору (та іншими інвалідностями) взаємодіяти з цифровим контентом. Вони перетворюють текстову та графічну інформацію, що відображається на екрані, у синтезовану мову або шрифт Брайля, дозволяючи користувачам 'чути' або 'читати' вміст інтерфейсу.",
    "additionalQuestions": [
      {
        "id": "web_002_1",
        "question": "Як скрінрідери взаємодіють з веб-сторінками?",
        "answer": "Вони використовують доступне дерево (accessibility tree), яке формується браузером на основі DOM та ARIA-атрибутів, щоб представити структуру та семантику сторінки користувачу."
      },
      {
        "id": "web_002_2",
        "question": "Які елементи веб-сторінки особливо важливі для скрінрідерів?",
        "answer": "Важливі елементи включають семантичні HTML5-теги (`<header>`, `<nav>`, `<main>`, `<footer>`), альтернативний текст для зображень (`alt`), мітки для форм (`<label>`) та ARIA-атрибути для динамічного контенту."
      },
      {
        "id": "web_002_3",
        "question": "Наведіть приклад популярного скрінрідера.",
        "answer": "Серед популярних скрінрідерів: JAWS (Windows), NVDA (Windows, безкоштовний), VoiceOver (macOS/iOS), TalkBack (Android)."
      }
    ]
  },
  {
    "id": "web_003",
    "topic": "Web",
    "mainQuestion": "Як зробити сторінку доступною для людей з інвалідністю?",
    "mainAnswer": "Щоб зробити веб-сторінку доступною, необхідно дотримуватися принципів веб-доступності (WCAG). Це включає використання семантичного HTML, надання альтернативного тексту для нетекстового контенту, забезпечення навігації за допомогою клавіатури, створення контрастних кольорів, підтримку масштабування тексту та використання ARIA-атрибутів для покращення взаємодії зі скрінрідерами та іншими допоміжними технологіями.",
    "additionalQuestions": [
      {
        "id": "web_003_1",
        "question": "Що таке WCAG?",
        "answer": "**WCAG** (Web Content Accessibility Guidelines) – це міжнародні рекомендації, розроблені W3C, які визначають, як зробити веб-контент доступним для людей з різними видами інвалідності."
      },
      {
        "id": "web_003_2",
        "question": "Яка роль семантичного HTML у доступності?",
        "answer": "Семантичний HTML надає чітку структуру та значення контенту, дозволяючи скрінрідерам та іншим допоміжним технологіям правильно інтерпретувати та представляти інформацію користувачам."
      },
      {
        "id": "web_003_3",
        "question": "Що таке ARIA-атрибути і коли їх використовувати?",
        "answer": "**ARIA** (Accessible Rich Internet Applications) – це набір атрибутів HTML, які надають додаткову семантику та інформацію про інтерактивні елементи та динамічний контент, що недоступні для звичайного HTML. Використовувати їх слід лише тоді, коли семантичний HTML не може забезпечити потрібну доступність."
      }
    ]
  },
  {
    "id": "web_004",
    "topic": "Web",
    "mainQuestion": "Що таке cookies, localStorage та sessionStorage? У чому різниця між ними?",
    "mainAnswer": "**Cookies**, **localStorage** та **sessionStorage** – це механізми зберігання даних на стороні клієнта у веб-браузері. Вони відрізняються обсягом зберігання, терміном дії та доступом:",
    "additionalQuestions": [
      {
        "id": "web_004_1",
        "question": "Опишіть Cookies.",
        "answer": "Кукі – невеликі файли (до 4 КБ), що відправляються сервером і зберігаються браузером. Відправляються з кожним запитом на сервер. Мають термін дії. Використовуються для сесій, відстеження, персоналізації."
      },
      {
        "id": "web_004_2",
        "question": "Опишіть localStorage.",
        "answer": "LocalStorage – зберігає дані безстроково (до видалення користувачем) і доступний лише на стороні клієнта. Об'єм зберігання до 5-10 МБ. Дані не відправляються на сервер."
      },
      {
        "id": "web_004_3",
        "question": "Опишіть sessionStorage.",
        "answer": "SessionStorage – зберігає дані лише на час сесії (до закриття вкладки або браузера). Об'єм зберігання до 5-10 МБ. Дані не відправляються на сервер. Кожна вкладка має свій окремий `sessionStorage`."
      }
    ]
  },
  {
    "id": "web_005",
    "topic": "Web",
    "mainQuestion": "Що означає HTTP?",
    "mainAnswer": "**HTTP** означає **HyperText Transfer Protocol** (Протокол Передачі Гіпертексту). Це протокол прикладного рівня для передачі даних у Всесвітній павутині. Він є основою для обміну даними між веб-браузерами та веб-серверами, дозволяючи завантажувати веб-сторінки, зображення, відео та інший контент.",
    "additionalQuestions": [
      {
        "id": "web_005_1",
        "question": "Яка основна функція HTTP?",
        "answer": "Основна функція HTTP – дозволити клієнтам (браузерам) запитувати ресурси у серверів та отримувати відповіді."
      },
      {
        "id": "web_005_2",
        "question": "Чи є HTTP протоколом без стану?",
        "answer": "Так, HTTP є протоколом без стану (stateless). Це означає, що кожен запит від клієнта до сервера є незалежним, і сервер не зберігає інформацію про попередні запити клієнта. Для підтримки стану використовуються такі механізми, як кукі або сесії."
      },
      {
        "id": "web_005_3",
        "question": "Яка версія HTTP є актуальною?",
        "answer": "Наразі широко використовуються HTTP/1.1 та HTTP/2. HTTP/3 є новітньою версією, яка базується на QUIC для підвищення продуктивності."
      }
    ]
  },
  {
    "id": "web_006",
    "topic": "Web",
    "mainQuestion": "Поясніть максимально детально, що робить сучасний браузер, коли користувач вводить URL і натискає Enter.",
    "mainAnswer": "Коли користувач вводить URL і натискає Enter, сучасний браузер проходить через складний процес для завантаження та відображення сторінки. Цей процес включає розділення URL, перетворення доменного імені в IP-адресу (DNS-запит), встановлення TCP-з'єднання, надсилання HTTP-запиту, отримання відповіді від сервера, парсинг HTML, завантаження та обробку ресурсів (CSS, JS, зображення), рендеринг сторінки та, зрештою, її відображення користувачу.",
    "additionalQuestions": [
      {
        "id": "web_006_1",
        "question": "Яку роль відіграє DNS в цьому процесі?",
        "answer": "DNS (Domain Name System) перетворює доменне ім'я (наприклад, google.com) в IP-адресу, яку комп'ютер може використовувати для встановлення з'єднання з сервером, де розміщено веб-сайт."
      },
      {
        "id": "web_006_2",
        "question": "Що відбувається після отримання HTTP-відповіді?",
        "answer": "Браузер починає парсити HTML-документ, створюючи DOM-дерево. Він також виявляє посилання на інші ресурси (CSS, JavaScript, зображення) і починає їх завантажувати. Починається процес рендерингу: побудова CSSOM, формування дерева рендерингу, layout, paint і composition."
      },
      {
        "id": "web_006_3",
        "question": "Як браузер обробляє JavaScript?",
        "answer": "Коли браузер зустрічає тег `<script>`, він зазвичай призупиняє парсинг HTML і виконує JavaScript. Це може заблокувати рендеринг сторінки, якщо скрипт великий або повільний."
      }
    ]
  },
  {
    "id": "web_007",
    "topic": "Web",
    "mainQuestion": "Поясніть процес рендерингу сторінки (calc styles => reflow => repaint => composition).",
    "mainAnswer": "Процес рендерингу сторінки в браузері включає кілька ключових етапів: **Парсинг (Parsing)** HTML та CSS, створення **DOM** та **CSSOM**, об'єднання їх у **Render Tree**. Потім йдуть: **Layout (Reflow)** – обчислення геометрії та положення кожного елемента; **Paint (Repaint)** – заповнення пікселів, малювання елементів на екрані; **Composition** – поєднання окремих шарів на екрані для фінального відображення.",
    "additionalQuestions": [
      {
        "id": "web_007_1",
        "question": "Що таке DOM та CSSOM?",
        "answer": "**DOM** (Document Object Model) – це об'єктне представлення HTML-документа. **CSSOM** (CSS Object Model) – це об'єктне представлення стилів CSS, застосованих до документа."
      },
      {
        "id": "web_007_2",
        "question": "Що таке 'Reflow' (Layout) і чому його варто уникати?",
        "answer": "Reflow – це перерахунок розмірів та положення всіх елементів на сторінці. Це ресурсоємний процес, який відбувається при зміні DOM, CSS, розмірів вікна браузера тощо. Часті reflows можуть значно знизити продуктивність."
      },
      {
        "id": "web_007_3",
        "question": "Що таке 'Repaint' (Paint) і чим він відрізняється від Reflow?",
        "answer": "Repaint – це процес перемальовування пікселів елемента на екрані без зміни його розмірів чи положення (наприклад, зміна кольору фону). Repaint менш затратний, ніж Reflow, але все одно може впливати на продуктивність."
      }
    ]
  },
  {
    "id": "web_008",
    "topic": "Web",
    "mainQuestion": "Що таке critical CSS?",
    "mainAnswer": "**Critical CSS** (критичний CSS) – це мінімальний набір CSS-правил, необхідних для стилізації 'першого екрану' (above-the-fold content) веб-сторінки. Його вбудовують безпосередньо в HTML-документ (inline CSS) в `<head>`, щоб браузер міг одразу відобразити верхню частину сторінки без очікування завантаження зовнішніх CSS-файлів, покращуючи perceived performance.",
    "additionalQuestions": [
      {
        "id": "web_008_1",
        "question": "Навіщо використовувати Critical CSS?",
        "answer": "Використання Critical CSS допомагає покращити метрику 'First Contentful Paint' (FCP) та 'Largest Contentful Paint' (LCP), що є важливими для SEO та користувацького досвіду, оскільки користувач бачить вміст сторінки швидше."
      },
      {
        "id": "web_008_2",
        "question": "Як отримати Critical CSS?",
        "answer": "Існують різні інструменти та плагіни (наприклад, Critical, penthouse, або вбудовані функції деяких фреймворків), які автоматично аналізують сторінку та витягують критичний CSS."
      },
      {
        "id": "web_008_3",
        "question": "Де розміщується Critical CSS?",
        "answer": "Critical CSS розміщується всередині тегу `<style>` у розділі `<head>` HTML-документа."
      }
    ]
  },
  {
    "id": "web_009",
    "topic": "Web",
    "mainQuestion": "Як пов'язані CSS файли впливають на рендеринг сторінки?",
    "mainAnswer": "Зовнішні CSS-файли (підключені через `<link rel='stylesheet' href='style.css'>`) є **ресурсами, що блокують рендеринг**. Браузер не може розпочати відображення сторінки, доки всі CSS-файли не будуть завантажені та розпарсені, оскільки CSSOM необхідний для побудови дерева рендерингу. Це може затримувати відображення вмісту.",
    "additionalQuestions": [
      {
        "id": "web_009_1",
        "question": "Чому CSS блокує рендеринг?",
        "answer": "Браузеру потрібен повний CSSOM для правильного розрахунку стилів та макета сторінки. Якщо CSS-файл не завантажений, браузер не знає, як мають виглядати елементи, тому він призупиняє рендеринг, щоб уникнути 'миготіння нестилізованого контенту' (FOUC)."
      },
      {
        "id": "web_009_2",
        "question": "Як оптимізувати завантаження CSS?",
        "answer": "Можна використовувати Critical CSS, відкладати завантаження некритичного CSS (наприклад, за допомогою `media` атрибута в `<link>` або JavaScript), мінімізувати та компресувати файли CSS, використовувати HTTP/2 для паралельного завантаження."
      },
      {
        "id": "web_009_3",
        "question": "Що таке 'FOUC'?",
        "answer": "**FOUC** (Flash Of Unstyled Content) – це явище, коли веб-сторінка тимчасово відображається без застосованих стилів, а потім раптово перемальовується зі стилями після завантаження CSS. Це небажаний ефект для користувацького досвіду."
      }
    ]
  },
  {
    "id": "web_010",
    "topic": "Web",
    "mainQuestion": "У чому різниця між включенням `<script>` у `<head>` та перед `</body>`?",
    "mainAnswer": "Розміщення `<script>` тегу впливає на час завантаження та виконання JavaScript, а отже, і на рендеринг сторінки: \n* **У `<head>`:** Скрипт завантажується та виконується до того, як браузер почне парсити та відображати тіло сторінки. Це блокує рендеринг. \n* **Перед `</body>` (end of body):** Скрипт завантажується та виконується після того, як весь HTML-контент сторінки вже був розпарсений. Це дозволяє сторінці швидше відобразитися, і скрипти можуть безпечно звертатися до елементів DOM без помилок.",
    "additionalQuestions": [
      {
        "id": "web_010_1",
        "question": "Які недоліки розміщення скриптів у `<head>`?",
        "answer": "Основний недолік – блокування рендерингу сторінки. Користувач буде бачити порожню сторінку, доки всі скрипти не будуть завантажені та виконані, що погіршує perceived performance."
      },
      {
        "id": "web_010_2",
        "question": "Які переваги розміщення скриптів перед `</body>`?",
        "answer": "Переваги: не блокує рендеринг, що прискорює відображення вмісту користувачу; скрипти мають доступ до всіх елементів DOM, оскільки DOM вже побудований."
      },
      {
        "id": "web_010_3",
        "question": "Коли все ж таки є сенс розміщувати скрипти у `<head>`?",
        "answer": "Рідко, але може бути необхідно для певних функцій, які повинні бути доступні одразу (наприклад, поліфіли, скрипти для аналітики, що не блокують рендеринг, або скрипти з атрибутами `async` чи `defer`)."
      }
    ]
  },
  {
    "id": "web_011",
    "topic": "Web",
    "mainQuestion": "Що означають `async` та `defer` у `<script>`?",
    "mainAnswer": "Атрибути `async` та `defer` у тегу `<script>` дозволяють змінити поведінку завантаження та виконання JavaScript-файлів, щоб запобігти блокуванню рендерингу сторінки: \n* **`async`**: Скрипт завантажується асинхронно у фоновому режимі, не блокуючи парсинг HTML. Після завантаження він виконується, і це може блокувати рендеринг на час виконання. Порядок виконання скриптів з `async` не гарантується. \n* **`defer`**: Скрипт завантажується асинхронно у фоновому режимі, не блокуючи парсинг HTML. Виконання відкладається до повного завершення парсингу HTML (і до того, як спрацює подія `DOMContentLoaded`). Порядок виконання скриптів з `defer` зберігається.",
    "additionalQuestions": [
      {
        "id": "web_011_1",
        "question": "Коли використовувати `async`?",
        "answer": "Використовуйте `async` для незалежних скриптів, які не залежать від DOM та не впливають на інші скрипти (наприклад, скрипти аналітики, сторонні віджети)."
      },
      {
        "id": "web_011_2",
        "question": "Коли використовувати `defer`?",
        "answer": "Використовуйте `defer` для скриптів, які залежать від DOM або від інших скриптів (наприклад, jQuery, кастомні скрипти для інтерактивності сторінки). Це часто є кращою альтернативою розміщенню скриптів перед `</body>`."
      },
      {
        "id": "web_011_3",
        "question": "Яка поведінка скриптів без `async` та `defer`?",
        "answer": "Без цих атрибутів скрипт завантажується та виконується синхронно, блокуючи парсинг HTML та рендеринг сторінки до свого завершення."
      }
    ]
  },
  {
    "id": "web_012",
    "topic": "Web",
    "mainQuestion": "Який найкращий спосіб включити CSS та JS у HTML-сторінку?",
    "mainAnswer": "Найкращий спосіб включення CSS та JS полягає в оптимізації їх завантаження та виконання для покращення продуктивності та користувацького досвіду: \n* **CSS:** Ключовий CSS (Critical CSS) для 'першого екрану' слід вбудовувати безпосередньо в `<head>` (inline `<style>`). Весь інший CSS підключати через зовнішні файли (`<link rel='stylesheet' href='style.css'>`) з атрибутами `media` для відкладеного завантаження або використовувати `@import` в JavaScript для динамічного завантаження. \n* **JavaScript:** Більшість JavaScript-файлів слід підключати перед закриваючим тегом `</body>` або використовувати атрибути `defer` чи `async` у тегу `<script>` для асинхронного завантаження та неблокуючого виконання.",
    "additionalQuestions": [
      {
        "id": "web_012_1",
        "question": "Чому Critical CSS краще вбудовувати?",
        "answer": "Це дозволяє браузеру одразу відобразити 'перший екран' сторінки без очікування завантаження зовнішніх CSS-файлів, що покращує сприйману швидкість завантаження."
      },
      {
        "id": "web_012_2",
        "question": "Які переваги зовнішніх CSS та JS файлів?",
        "answer": "Зовнішні файли кешуються браузером, зменшуючи час завантаження при повторних відвідуваннях. Вони також покращують читабельність коду та його підтримку."
      },
      {
        "id": "web_012_3",
        "question": "Як `defer` і `async` допомагають з JavaScript?",
        "answer": "Вони дозволяють завантажувати скрипти паралельно з парсингом HTML, зменшуючи час блокування рендерингу та прискорюючи відображення сторінки."
      }
    ]
  },
  {
    "id": "web_013",
    "topic": "Web",
    "mainQuestion": "Як покращити продуктивність веб-сайту?",
    "mainAnswer": "Покращення продуктивності веб-сайту включає оптимізацію як фронтенду, так і бекенду. Ключові стратегії включають мінімізацію та компресію ресурсів (HTML, CSS, JS, зображення), кешування (на стороні браузера та сервера), використання CDN, оптимізацію зображень, ледаче завантаження (lazy loading), зменшення кількості HTTP-запитів, оптимізацію критичного шляху рендерингу та ефективну роботу з JavaScript.",
    "additionalQuestions": [
      {
        "id": "web_013_1",
        "question": "Що таке CDN і як він допомагає?",
        "answer": "**CDN** (Content Delivery Network) – це мережа розподілених серверів, які зберігають копії вашого контенту. Коли користувач запитує контент, CDN доставляє його з найближчого сервера, що зменшує затримку та прискорює завантаження."
      },
      {
        "id": "web_013_2",
        "question": "Що таке 'lazy loading'?",
        "answer": "**Lazy loading** (ледаче завантаження) – це техніка, при якій зображення або інші ресурси завантажуються лише тоді, коли вони стають видимими в області перегляду користувача, а не одразу при завантаженні сторінки. Це зменшує початковий час завантаження."
      },
      {
        "id": "web_013_3",
        "question": "Як оптимізувати зображення?",
        "answer": "Оптимізація зображень включає вибір правильного формату (WebP, AVIF), стиснення без втрати якості, використання адаптивних зображень (srcset, sizes), встановлення атрибутів `width` та `height` для уникнення зсувів макета."
      }
    ]
  },
  {
    "id": "web_014",
    "topic": "Web",
    "mainQuestion": "Що таке Shadow DOM?",
    "mainAnswer": "**Shadow DOM** – це одна з трьох ключових технологій Web Components (разом з Custom Elements та HTML Templates). Вона дозволяє інкапсулювати дерево DOM та стилі (CSS) елемента, створюючи 'тіньовий' DOM-піддерево, яке ізольоване від основного документа. Це запобігає конфліктам стилів та забезпечує незалежність компонента.",
    "additionalQuestions": [
      {
        "id": "web_014_1",
        "question": "Для чого використовується Shadow DOM?",
        "answer": "Він використовується для створення інкапсульованих, повторно використовуваних веб-компонентів, де внутрішні деталі реалізації (розмітка, стилі) приховані від зовнішнього світу та не впливають на основний DOM."
      },
      {
        "id": "web_014_2",
        "question": "Які переваги Shadow DOM?",
        "answer": "Основні переваги: **ізоляція CSS** (стилі в Shadow DOM не витікають назовні, а зовнішні стилі не впливають на нього) та **ізоляція DOM** (внутрішня структура елемента не доступна напряму з основного DOM)."
      },
      {
        "id": "web_014_3",
        "question": "Як створити Shadow DOM?",
        "answer": "Shadow DOM створюється за допомогою методу `attachShadow()` на елементі DOM (наприклад, `element.attachShadow({ mode: 'open' });`). Режим 'open' дозволяє доступ до тіньового кореня з JavaScript, 'closed' – забороняє."
      }
    ]
  },
  {
    "id": "web_015",
    "topic": "Web",
    "mainQuestion": "Що таке AJAX?",
    "mainAnswer": "**AJAX** (Asynchronous JavaScript and XML) – це набір веб-технологій, які дозволяють веб-сторінкам асинхронно обмінюватися даними з сервером, без необхідності перезавантаження всієї сторінки. Це покращує взаємодію з користувачем, роблячи веб-додатки більш динамічними та чуйними.",
    "additionalQuestions": [
      {
        "id": "web_015_1",
        "question": "Які основні компоненти AJAX?",
        "answer": "Основними компонентами є JavaScript для керування логікою та `XMLHttpRequest` (або сучасний `Fetch API`) для надсилання HTTP-запитів до сервера. Також використовуються DOM для оновлення вмісту сторінки та JSON (раніше XML) для формату обміну даними."
      },
      {
        "id": "web_015_2",
        "question": "Які переваги використання AJAX?",
        "answer": "Покращення користувацького досвіду (відсутність перезавантаження сторінки), зменшення навантаження на сервер (передаються лише необхідні дані), швидший час відгуку, можливість створення більш інтерактивних інтерфейсів."
      },
      {
        "id": "web_015_3",
        "question": "Чи завжди AJAX використовує XML?",
        "answer": "Ні. Хоча в назві є 'XML', на практиці набагато частіше використовується **JSON** як формат обміну даними через його легкість та простоту парсингу в JavaScript."
      }
    ]
  },
  {
    "id": "web_016",
    "topic": "Web",
    "mainQuestion": "Що таке HTTP та HTTPS?",
    "mainAnswer": "**HTTP** (HyperText Transfer Protocol) – це протокол прикладного рівня для передачі даних у Всесвітній павутині. **HTTPS** (HyperText Transfer Protocol Secure) – це безпечна версія HTTP, яка використовує SSL/TLS шифрування для захисту даних, що передаються між клієнтом і сервером.",
    "additionalQuestions": [
      {
        "id": "web_016_1",
        "question": "Яка головна відмінність між HTTP та HTTPS?",
        "answer": "Головна відмінність полягає в безпеці. HTTPS шифрує дані, що передаються, забезпечуючи конфіденційність, цілісність та автентифікацію, тоді як HTTP передає дані у відкритому вигляді."
      },
      {
        "id": "web_016_2",
        "question": "Які порти за замовчуванням використовуються для HTTP та HTTPS?",
        "answer": "За замовчуванням HTTP використовує порт **80**, а HTTPS – порт **443**."
      },
      {
        "id": "web_016_3",
        "question": "Що таке SSL/TLS?",
        "answer": "**SSL** (Secure Sockets Layer) та його наступник **TLS** (Transport Layer Security) – це криптографічні протоколи, які забезпечують безпечний зв'язок через комп'ютерну мережу, шифруючи дані та автентифікуючи сторони."
      }
    ]
  },
  {
    "id": "web_017",
    "topic": "Web",
    "mainQuestion": "Що таке request method? Назвіть деякі з поширених методів.",
    "mainAnswer": "**Request method** (або HTTP-метод) – це індикатор HTTP-запиту, який вказує бажану дію для ресурсу, визначеного URI. Він визначає тип операції, яку клієнт хоче виконати над ресурсом на сервері.",
    "additionalQuestions": [
      {
        "id": "web_017_1",
        "question": "Назвіть найпоширеніші HTTP-методи та їх призначення.",
        "answer": "**GET** (отримати ресурс), **POST** (створити ресурс або надіслати дані), **PUT** (повністю оновити ресурс), **DELETE** (видалити ресурс), **PATCH** (частково оновити ресурс), **HEAD** (отримати заголовки без тіла), **OPTIONS** (отримати дозволені методи)."
      },
      {
        "id": "web_017_2",
        "question": "Що означає 'ідемпотентний' метод?",
        "answer": "Ідемпотентний метод означає, що багаторазове виконання того ж запиту матиме той самий ефект на сервері, як і одноразове виконання. Наприклад, `GET`, `PUT`, `DELETE` є ідемпотентними."
      },
      {
        "id": "web_017_3",
        "question": "Що означає 'безпечний' метод?",
        "answer": "Безпечний метод означає, що він не змінює стан сервера. Наприклад, `GET` та `HEAD` є безпечними методами."
      }
    ]
  },
  {
    "id": "web_018",
    "topic": "Web",
    "mainQuestion": "Що таке домен та порт?",
    "mainAnswer": "**Домен** (доменне ім'я) – це легко запам'ятовувана адреса в інтернеті, яка замінює складні IP-адреси (наприклад, `google.com`). **Порт** – це логічний номер, який ідентифікує конкретний процес або застосунок на комп'ютері, через який відбувається мережеве з'єднання.",
    "additionalQuestions": [
      {
        "id": "web_018_1",
        "question": "Як домен та IP-адреса пов'язані?",
        "answer": "Доменне ім'я – це читабельне для людини представлення IP-адреси. DNS-сервери (Domain Name System) перетворюють доменні імена в IP-адреси, які використовуються для маршрутизації в інтернеті."
      },
      {
        "id": "web_018_2",
        "question": "Навіщо потрібні порти?",
        "answer": "Порти дозволяють декільком застосункам або службам на одному сервері одночасно використовувати мережеве з'єднання, направляючи вхідні пакети даних до правильного застосунку."
      },
      {
        "id": "web_018_3",
        "question": "Назвіть стандартні порти для веб-трафіку.",
        "answer": "Стандартний порт для HTTP – **80**, для HTTPS – **443**."
      }
    ]
  },
  {
    "id": "web_019",
    "topic": "Web",
    "mainQuestion": "Що таке заголовки? Назвіть кілька поширених.",
    "mainAnswer": "**Заголовки** (HTTP Headers) – це пари 'ім'я-значення', які передаються в HTTP-запитах та відповідях. Вони містять метадані про повідомлення, такі як тип контенту, довжина, кешування, авторизація, інформація про клієнта/сервер, допомагаючи сторонам правильно інтерпретувати та обробляти дані.",
    "additionalQuestions": [
      {
        "id": "web_019_1",
        "question": "Які є категорії HTTP-заголовків?",
        "answer": "Заголовки поділяються на: загальні (General Headers), заголовки запиту (Request Headers), заголовки відповіді (Response Headers) та заголовки сутності (Entity Headers)."
      },
      {
        "id": "web_019_2",
        "question": "Назвіть кілька поширених заголовків запиту.",
        "answer": "`User-Agent` (ідентифікує браузер/клієнт), `Accept` (типи медіа, які приймає клієнт), `Content-Type` (тип вмісту тіла запиту), `Authorization` (для автентифікації)."
      },
      {
        "id": "web_019_3",
        "question": "Назвіть кілька поширених заголовків відповіді.",
        "answer": "`Content-Type` (тип вмісту тіла відповіді), `Cache-Control` (інструкції кешування), `Set-Cookie` (встановлення кукі), `Location` (для перенаправлення)."
      }
    ]
  },
  {
    "id": "web_020",
    "topic": "Web",
    "mainQuestion": "Що таке response status code?",
    "mainAnswer": "**Response status code** (код стану відповіді HTTP) – це тризначне число, яке повертається сервером у відповідь на HTTP-запит клієнта. Він вказує на результат спроби запиту та надає інформацію про те, чи був запит успішним, чи сталася помилка, чи потрібна додаткова дія.",
    "additionalQuestions": [
      {
        "id": "web_020_1",
        "question": "Які існують категорії статусних кодів?",
        "answer": "Статусні коди поділяються на 5 категорій: **1xx** (інформаційні), **2xx** (успішні), **3xx** (перенаправлення), **4xx** (помилки клієнта), **5xx** (помилки сервера)."
      },
      {
        "id": "web_020_2",
        "question": "Назвіть кілька поширених статусних кодів.",
        "answer": "**200 OK** (успіх), **201 Created** (ресурс створено), **400 Bad Request** (некоректний запит), **404 Not Found** (ресурс не знайдено), **500 Internal Server Error** (внутрішня помилка сервера)."
      },
      {
        "id": "web_020_3",
        "question": "Коли використовується статус 301, а коли 302?",
        "answer": "**301 Moved Permanently** використовується для постійного перенаправлення (змінюється URL в закладках пошукових систем). **302 Found** (тимчасове перенаправлення) використовується для тимчасових перенаправлень, коли ресурс буде доступний за старим URL пізніше."
      }
    ]
  },
  {
    "id": "web_021",
    "topic": "Web",
    "mainQuestion": "Який потік взаємодії між клієнтом, сервером та базою даних?",
    "mainAnswer": "Потік взаємодії починається з **клієнта** (наприклад, веб-браузера), який надсилає **HTTP-запит** до **сервера**. Сервер приймає запит, обробляє його за допомогою бізнес-логіки. Якщо потрібно, сервер взаємодіє з **базою даних** (надсилає SQL-запити або використовує ORM) для отримання, зберігання або зміни даних. База даних повертає дані серверу, який, у свою чергу, формує **HTTP-відповідь** та відправляє її назад клієнту. Клієнт отримує відповідь та відображає дані користувачу.",
    "additionalQuestions": [
      {
        "id": "web_021_1",
        "question": "Які ролі клієнта, сервера та бази даних у цьому потоці?",
        "answer": "Клієнт ініціює запит та відображає результат. Сервер (бек-енд) обробляє запити, виконує бізнес-логіку та взаємодіє з базою даних. База даних зберігає та надає доступ до даних."
      },
      {
        "id": "web_021_2",
        "question": "Що може спричинити затримку у цьому потоці?",
        "answer": "Затримки можуть виникати через мережеву латентність, повільну обробку на сервері, неефективні запити до бази даних, великий обсяг даних у відповіді або повільний рендеринг на клієнті."
      },
      {
        "id": "web_021_3",
        "question": "Як забезпечується безпека у цьому потоці?",
        "answer": "Безпека забезпечується на різних рівнях: HTTPS для шифрування зв'язку, автентифікація та авторизація на сервері, захист від SQL-ін'єкцій та XSS-атак, а також належне керування доступом до бази даних."
      }
    ]
  },
  {
    "id": "web_022",
    "topic": "Web",
    "mainQuestion": "Опишіть механізм аутентифікації для взаємодії клієнт/сервер.",
    "mainAnswer": "Механізм **автентифікації** – це процес перевірки ідентичності користувача або системи. Для взаємодії клієнт/сервер він зазвичай включає надсилання облікових даних (наприклад, логіну та пароля) з клієнта на сервер. Сервер перевіряє ці дані. У разі успіху сервер видає токен (наприклад, сесійний кукі або JWT), який клієнт зберігає і відправляє з кожним наступним запитом для доведення своєї ідентичності без повторного введення облікових даних.",
    "additionalQuestions": [
      {
        "id": "web_022_1",
        "question": "Які поширені типи автентифікації?",
        "answer": "Найпоширеніші: автентифікація на основі сесій (з кукі), на основі токенів (JWT), OAuth 2.0 (для сторонніх застосунків), Basic Auth (для простих випадків), API-ключі."
      },
      {
        "id": "web_022_2",
        "question": "Як працює автентифікація на основі сесій?",
        "answer": "Після успішного входу сервер створює унікальний ідентифікатор сесії, зберігає його на сервері, а клієнту відправляє кукі з цим ідентифікатором. Браузер відправляє кукі з кожним наступним запитом, і сервер використовує його для ідентифікації користувача."
      },
      {
        "id": "web_022_3",
        "question": "Чому JWT популярний для API?",
        "answer": "JWT (JSON Web Tokens) є безстатевими (stateless), що робить їх ідеальними для масштабованих API та мікросервісів. Вони не вимагають зберігання стану сесії на сервері, а всю необхідну інформацію містять у собі (підписані, але не зашифровані)."
      }
    ]
  },
  {
    "id": "web_023",
    "topic": "Web",
    "mainQuestion": "Що таке REST API? Як він будується?",
    "mainAnswer": "**REST API** (Representational State Transfer Application Programming Interface) – це архітектурний стиль для розподілених систем, що використовує HTTP-протокол. Він базується на принципах, які дозволяють створювати масштабовані, гнучкі та ефективні веб-сервіси. REST API працює з ресурсами (наприклад, 'користувачі', 'продукти'), доступ до яких здійснюється через унікальні URL-адреси, а взаємодія відбувається за допомогою стандартних HTTP-методів.",
    "additionalQuestions": [
      {
        "id": "web_023_1",
        "question": "Які ключові принципи REST?",
        "answer": "1. **Клієнт-серверна архітектура:** Чітке розділення ролей. 2. **Безстатевість (Stateless):** Кожен запит від клієнта містить всю необхідну інформацію. 3. **Кешованість:** Відповіді можуть бути кешовані. 4. **Уніфікований інтерфейс:** Стандартні методи HTTP, ідентифікація ресурсів. 5. **Шари (Layered System):** Дозволяє проксі та балансувальники навантаження. 6. **Код на вимогу (Code-on-Demand):** Опціонально, дозволяє серверу розширювати функціонал клієнта через код."
      },
      {
        "id": "web_023_2",
        "question": "Як REST API працює з ресурсами?",
        "answer": "Ресурси ідентифікуються за допомогою URL (URI). Наприклад, `/users` може представляти колекцію користувачів, а `/users/123` – конкретного користувача з ID 123. HTTP-методи (`GET`, `POST`, `PUT`, `DELETE`) використовуються для виконання операцій над цими ресурсами."
      },
      {
        "id": "web_023_3",
        "question": "Які формати даних найчастіше використовуються в REST API?",
        "answer": "Найчастіше використовується **JSON** (JavaScript Object Notation) через його легкість, читабельність та простоту парсингу в JavaScript. Іноді також використовується XML."
      }
    ]
  },
  {
    "id": "web_024",
    "topic": "Web",
    "mainQuestion": "У чому різниця між PUT та PATCH?",
    "mainAnswer": "Обидва HTTP-методи, `PUT` та `PATCH`, використовуються для оновлення ресурсів на сервері, але вони відрізняються підходом: \n* **`PUT`**: Використовується для **повного оновлення** ресурсу. Клієнт надсилає повне представлення ресурсу, і сервер замінює існуючий ресурс цим новим представленням. Якщо ресурс не існує, `PUT` може створити його (ідемпотентно). \n* **`PATCH`**: Використовується для **часткового оновлення** ресурсу. Клієнт надсилає лише ті зміни, які необхідно внести в ресурс. Сервер застосовує ці зміни до існуючого ресурсу.",
    "additionalQuestions": [
      {
        "id": "web_024_1",
        "question": "Наведіть приклад використання PUT.",
        "answer": "Якщо у вас є ресурс користувача `{ 'id': 1, 'name': 'John', 'email': 'john@example.com' }`, і ви хочете змінити лише ім'я, з `PUT` вам все одно доведеться відправити весь об'єкт: `PUT /users/1 { 'id': 1, 'name': 'Jane', 'email': 'john@example.com' }`."
      },
      {
        "id": "web_024_2",
        "question": "Наведіть приклад використання PATCH.",
        "answer": "Для того ж користувача, щоб змінити лише ім'я за допомогою `PATCH`, ви відправите лише частину об'єкта: `PATCH /users/1 { 'name': 'Jane' }`."
      },
      {
        "id": "web_024_3",
        "question": "Який метод є ідемпотентним?",
        "answer": "**PUT** є ідемпотентним, оскільки багаторазові запити `PUT` з однаковим тілом призведуть до того ж стану ресурсу. **PATCH** не є ідемпотентним за визначенням, оскільки повторні запити `PATCH` можуть призвести до різних станів, якщо застосовується 'патч'."
      }
    ]
  },
  {
    "id": "web_025",
    "topic": "Web",
    "mainQuestion": "Поясніть CORS. Чому він існує?",
    "mainAnswer": "**CORS** (Cross-Origin Resource Sharing) – це механізм безпеки браузера, який дозволяє веб-сторінці робити запити до ресурсів іншого домену (відмінного від домену, з якого завантажено саму сторінку). Він існує для реалізації **політики єдиного джерела (Same-Origin Policy)**, яка за замовчуванням забороняє браузерам виконувати cross-origin запити з міркувань безпеки, щоб запобігти шкідливим діям (наприклад, викраденню даних або міжсайтовим атакам). CORS надає безпечний спосіб 'дозволити' такі міждоменні запити.",
    "additionalQuestions": [
      {
        "id": "web_025_1",
        "question": "Що таке Same-Origin Policy?",
        "answer": "Same-Origin Policy – це фундаментальна концепція безпеки у веб-браузерах, яка обмежує взаємодію скриптів, що завантажуються з одного 'джерела' (комбінація протоколу, домену та порту), з ресурсами іншого 'джерела'."
      },
      {
        "id": "web_025_2",
        "question": "Як сервер дозволяє CORS?",
        "answer": "Сервер надсилає спеціальні HTTP-заголовки у відповідь на cross-origin запити, зокрема `Access-Control-Allow-Origin`, який вказує, які домени дозволено запитувати його ресурси. Можуть бути також `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers` та інші."
      },
      {
        "id": "web_025_3",
        "question": "Що таке 'preflight request' в CORS?",
        "answer": "Це запит `OPTIONS`, який браузер автоматично відправляє перед певними 'складними' CORS-запитами (наприклад, з нестандартними заголовками або методами, крім `GET`/`POST` без певних `Content-Type`), щоб отримати дозвіл від сервера на виконання основного запиту."
      }
    ]
  },
  {
    "id": "web_026",
    "topic": "Web",
    "mainQuestion": "Поясніть модель OSI.",
    "mainAnswer": "**Модель OSI** (Open Systems Interconnection model) – це концептуальна архітектурна модель, яка стандартизує функції комунікаційної системи на сім логічно розділених шарів. Кожен шар моделі виконує певну роль і взаємодіє лише з безпосередньо вищим та нижчим шарами, забезпечуючи чітке розділення обов'язків у мережевій взаємодії. Вона допомагає зрозуміти, як різні мережеві технології співпрацюють.",
    "additionalQuestions": [
      {
        "id": "web_026_1",
        "question": "Назвіть сім шарів моделі OSI.",
        "answer": "Знизу догори: 1. Фізичний (Physical), 2. Канальний (Data Link), 3. Мережевий (Network), 4. Транспортний (Transport), 5. Сесійний (Session), 6. Представлення (Presentation), 7. Прикладний (Application)."
      },
      {
        "id": "web_026_2",
        "question": "Які функції виконує Мережевий шар?",
        "answer": "Мережевий шар (Layer 3) відповідає за логічну адресацію (IP-адреси), маршрутизацію пакетів через мережу та забезпечення міжмережевого зв'язку."
      },
      {
        "id": "web_026_3",
        "question": "Які функції виконує Транспортний шар?",
        "answer": "Транспортний шар (Layer 4) забезпечує наскрізну передачу даних між застосунками. Він відповідає за сегментацію даних, контроль потоку, виявлення та виправлення помилок, а також мультиплексування/демультиплексування (наприклад, TCP та UDP)."
      }
    ]
  }
]