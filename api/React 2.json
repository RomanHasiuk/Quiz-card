[
  {
    "id": "react-q16",
    "topic": "React",
    "mainQuestion": "Що таке контрольовані компоненти?",
    "mainAnswer": "**Контрольовані компоненти** (Controlled Components) — це елементи форм у React (наприклад, `<input>`, `<textarea>`, `<select>`), значення яких повністю контролюються станом (state) React-компонента. Значення поля форми не зберігається безпосередньо в DOM, а зберігається в стані компонента. Коли користувач вводить дані, React перехоплює цю подію (`onChange`), оновлює стан компонента, і це нове значення стану потім відображається в полі форми. \n**Приклад:** \n```jsx \nfunction MyForm() { \n  const [value, setValue] = useState(''); \n  return <input type=\"text\" value={value} onChange={(e) => setValue(e.target.value)} />; \n} \n``` \nЦе забезпечує єдине джерело істини для даних форми, полегшує валідацію та маніпуляції з формою.",
    "additionalQuestions": [
      {
        "id": "react-q16-aq1",
        "question": "Яка головна перевага контрольованих компонентів?",
        "answer": "Головна перевага — це те, що стан форми завжди синхронізований зі станом React. Це значно спрощує доступ до даних форми, їх валідацію та маніпуляції з ними, оскільки дані вже знаходяться у керуючому компоненті."
      },
      {
        "id": "react-q16-aq2",
        "question": "Який атрибут використовується для контрольованого `input` і який обробник подій?",
        "answer": "Для контрольованого `<input>` використовується атрибут `value` (для введення тексту) або `checked` (для чекбоксів/радіокнопок) для зв'язування зі станом, а обробник подій `onChange` використовується для оновлення стану при зміні значення."
      },
      {
        "id": "react-q16-aq3",
        "question": "Чи можна використовувати контрольовані компоненти без хука `useState`?",
        "answer": "Так, у компонентах-класах контрольовані компоненти реалізуються за допомогою `this.state` та `this.setState()`. Хук `useState` є сучасним способом управління станом у функціональних компонентах."
      }
    ]
  },
  {
    "id": "react-q17",
    "topic": "React",
    "mainQuestion": "Чи відрізняються чимось атрибути та події для полів форми у Реакті від звичайних у DOM?",
    "mainAnswer": "Так, є кілька ключових відмінностей: \n- **Іменування атрибутів (Naming Conventions)**: У React атрибути пишуться в `camelCase` (наприклад, `htmlFor` замість `for`, `className` замість `class`), тоді як у HTML/DOM вони зазвичай у `kebab-case` або просто нижньому регістрі. \n- **Обробники подій (Event Handlers)**: У React обробники подій також пишуться в `camelCase` (наприклад, `onClick`, `onChange`) і приймають **функції** як значення, тоді як у HTML/DOM вони зазвичай у нижньому регістрі (`onclick`) і приймають **рядки з JavaScript-кодом**. \n- **Синтетичні події (Synthetic Events)**: React створює об'єкти 'синтетичних подій' як обгортки для нативних подій браузера, забезпечуючи кросбраузерну сумісність. \n- **Значення полів форми**: Для текстових полів (`<input type=\"text\">`, `<textarea>`), значення контролюється атрибутом `value` (а не `defaultValue`). Для `checkbox` та `radio` — `checked` (а не `defaultChecked`). \n- **Атрибут `style`**: У React атрибут `style` приймає об'єкт JavaScript, а не рядок CSS-стилів. Наприклад: `style={{ color: 'red', fontSize: '16px' }}`. \n- **`for` в `label`**: У React використовується `htmlFor` замість `for` для атрибута `label`.",
    "additionalQuestions": [
      {
        "id": "react-q17-aq1",
        "question": "Як у React призначити CSS-стилі інлайн?",
        "answer": "У React інлайн-стилі призначаються за допомогою об'єкта JavaScript, де ключі — це властивості CSS у camelCase, а значення — їхні значення: `<div style={{ backgroundColor: 'blue', padding: '10px' }}></div>`."
      },
      {
        "id": "react-q17-aq2",
        "question": "Яка роль атрибута `defaultValue` для полів форми в React?",
        "answer": "`defaultValue` використовується для *неконтрольованих* компонентів форми, щоб встановити початкове значення. Після цього React перестає керувати цим значенням, і воно контролюється DOM."
      },
      {
        "id": "react-q17-aq3",
        "question": "Що потрібно робити з об'єктом події (`event`) у React, якщо мені потрібно його використовувати асинхронно?",
        "answer": "Об'єкти синтетичних подій React повторно використовуються для оптимізації. Якщо вам потрібно отримати доступ до властивостей події асинхронно (після того, як обробник завершив роботу), вам потрібно викликати `event.persist()` (хоча в нових версіях React це рідко потрібно, оскільки подію вже не обнуляють) або зберегти потрібні властивості в окремі змінні."
      }
    ]
  },
  {
    "id": "react-q18",
    "topic": "React",
    "mainQuestion": "Що таке неконтрольовані компоненти? У яких випадках є сенс їх використовувати?",
    "mainAnswer": "**Неконтрольовані компоненти** (Uncontrolled Components) — це елементи форм у React, значення яких керуються DOM, а не станом React-компонента. Замість того, щоб React керував значенням поля через стан та обробник `onChange`, ви використовуєте рефи (refs) для прямого доступу до DOM-вузла поля та отримання його значення, коли це потрібно (наприклад, при відправці форми). \n**Приклад:** \n```jsx \nfunction MyUncontrolledForm() { \n  const inputRef = useRef(null); \n  function handleSubmit(event) { \n    event.preventDefault(); \n    alert('Введено: ' + inputRef.current.value); \n  } \n  return ( \n    <form onSubmit={handleSubmit}> \n      <input type=\"text\" ref={inputRef} defaultValue=\"Привіт\" /> \n      <button type=\"submit\">Відправити</button> \n    </form> \n  ); \n} \n``` \n**Коли використовувати:** \n- **Прості форми**: Для невеликих форм, де не потрібна миттєва валідація або складні маніпуляції з введенням. \n- **Інтеграція зі сторонніми бібліотеками DOM**: Якщо ви використовуєте бібліотеку, яка безпосередньо маніпулює DOM-елементами форми (наприклад, деякі плагіни для введення дати). \n- **Зменшення кількості повторних рендерингів**: Для дуже великих форм з багатьма полями, де контрольовані компоненти можуть викликати надмірні рендеринги. \nЗазвичай, **контрольовані компоненти є рекомендованим підходом** у React, оскільки вони забезпечують єдине джерело істини та кращий контроль над даними форми.",
    "additionalQuestions": [
      {
        "id": "react-q18-aq1",
        "question": "Що таке 'рефи' (refs) у React і для чого вони використовуються?",
        "answer": "Рефи — це спосіб отримати прямий доступ до DOM-вузлів або екземплярів React-компонентів. Вони використовуються у випадках, коли потрібно взаємодіяти з елементами DOM напряму (наприклад, фокусування, прокрутка, вимірювання розмірів) або для інтеграції зі сторонніми бібліотеками, які працюють безпосередньо з DOM."
      },
      {
        "id": "react-q18-aq2",
        "question": "Який хук використовується для створення рефів у функціональних компонентах?",
        "answer": "Для створення рефів у функціональних компонентах використовується хук `useRef`. Він повертає об'єкт рефа, який можна прив'язати до DOM-елемента за допомогою атрибута `ref`."
      },
      {
        "id": "react-q18-aq3",
        "question": "Чому контрольовані компоненти є кращими для більшості випадків?",
        "answer": "Контрольовані компоненти забезпечують більш передбачуваний потік даних, спрощують валідацію введених даних в реальному часі, дозволяють легше скидати форми та керувати їхнім станом декларативно. Це призводить до більш підтримуваного та передбачуваного коду."
      }
    ]
  },
  {
    "id": "react-q19",
    "topic": "React",
    "mainQuestion": "Що таке підйом стану (lifting state up)? Наведіть приклад ситуації, коли ним варто скористатися.",
    "mainAnswer": "**Підйом стану** (Lifting State Up) — це патерн у React, коли кілька компонентів потребують одного й того ж спільного стану, або коли один компонент потребує зміни стану іншого (не-дочірнього) компонента. Замість того, щоб зберігати цей стан у кожному з цих компонентів окремо, стан **переміщується вгору** до їхнього найближчого спільного батьківського компонента. \nБатьківський компонент потім передає дані зі свого стану вниз до дочірніх компонентів через `props`, а також може передавати функції-колбеки як `props`, щоб дочірні компоненти могли повідомляти батьківський про зміни, які вимагають оновлення стану. \n\n**Приклад ситуації:** \nВи маєте два компоненти: `TemperatureInput` (для введення температури в Цельсіях) та `CelsiusDisplay` (для відображення температури в Цельсіях). Обидва компоненти повинні відображати або оновлювати **одну й ту саму температуру**. \nЗамість того, щоб кожен компонент зберігав свою власну температуру, стан температури `temperature` піднімається до спільного батьківського компонента (наприклад, `Calculator`). Батьківський компонент `Calculator` керує станом `temperature`, передає його до `TemperatureInput` як `props` (разом з функцією-колбеком для оновлення) та до `CelsiusDisplay` як `props` для відображення.",
    "additionalQuestions": [
      {
        "id": "react-q19-aq1",
        "question": "Яка головна перевага підйому стану?",
        "answer": "Головна перевага — це підтримка єдиного джерела істини (single source of truth) для спільного стану. Це забезпечує синхронізацію даних між компонентами, полегшує налагодження та робить потік даних більш передбачуваним."
      },
      {
        "id": "react-q19-aq2",
        "question": "Чи завжди варто піднімати стан, якщо він використовується кількома компонентами?",
        "answer": "Так, якщо кілька компонентів потребують доступу до одного й того ж стану або цей стан впливає на них, підйом стану є рекомендованим патерном. Однак, для дуже складних глобальних станів може бути доцільніше використовувати системи управління станом, такі як Redux, Zustand, Recoil або React Context API."
      },
      {
        "id": "react-q19-aq3",
        "question": "Як дочірній компонент повідомляє батьківський про зміну стану при підйомі стану?",
        "answer": "Батьківський компонент передає функцію-колбек (яка змінює стан батька) як `prop` до дочірнього компонента. Коли в дочірньому компоненті відбувається подія, він викликає цю функцію-колбек, передаючи їй необхідні дані."
      }
    ]
  },
  {
    "id": "react-q20",
    "topic": "React",
    "mainQuestion": "Що таке композиція компонентів?",
    "mainAnswer": "**Композиція компонентів** (Component Composition) — це фундаментальний патерн у React, який полягає в побудові складних UI-елементів шляхом поєднання (композиції) простіших, незалежних компонентів. Замість того, щоб успадковувати функціональність (як у традиційному об'єктно-орієнтованому програмуванні), React заохочує композицію, де компоненти 'міститимуть' інші компоненти у своїй розмітці. \nЦе дозволяє створювати гнучкі, модульні та багаторазово використовувані UI. Компоненти можуть передавати дані та функціональність іншим компонентам через `props`, включаючи `children` prop. \n**Приклад:** \n```jsx \n// Компонент-контейнер, що приймає дочірні елементи \nfunction Card({ children }) { \n  return <div className=\"card\">{children}</div>; \n} \n// Використання: \n<Card> \n  <h2>Заголовок картки</h2> \n  <p>Опис картки.</p> \n  <button>Дія</button> \n</Card> \n``` \nТут `Card` є компонентом, який 'компонує' інші елементи, що передаються йому через `children`.",
    "additionalQuestions": [
      {
        "id": "react-q20-aq1",
        "question": "Яка альтернатива композиції компонентів у ООП і чому React віддає перевагу композиції?",
        "answer": "Альтернатива — це успадкування (inheritance). React віддає перевагу композиції, тому що вона є більш гнучкою, дозволяє уникнути проблем 'ієрархії успадкування' та 'крихкості базового класу'. Композиція робить компоненти більш незалежними, багаторазово використовуваними та легкими для тестування."
      },
      {
        "id": "react-q20-aq2",
        "question": "Що таке `props.children` і для чого він використовується?",
        "answer": "`props.children` — це спеціальний prop, який автоматично передається до компонента, коли він має дочірні елементи (тобто все, що знаходиться між відкриваючим і закриваючим тегами компонента). Він дозволяє 'прокидати' вміст, переданий компоненту, до його рендеру."
      },
      {
        "id": "react-q20-aq3",
        "question": "Наведіть приклад композиції 'спеціалізації'.",
        "answer": "Композиція може використовуватися для 'спеціалізації' компонентів. Наприклад, ви можете мати загальний компонент `Button` і створити `PrimaryButton` або `DangerButton`, які рендерять `Button` з певними попередньо встановленими стилями або властивостями, передаючи їх через props: `<Button type=\"primary\" />`."
      }
    ]
  },
  {
    "id": "react-q21",
    "topic": "React",
    "mainQuestion": "Що таке `React.Fragment` і в яких випадках ним варто користуватися?",
    "mainAnswer": "`React.Fragment` (та його скорочений синтаксис `<></>`) — це спеціальний компонент у React, який дозволяє групувати кілька елементів без додавання додаткових DOM-вузлів у браузері. \n**Коли ним варто користуватися:** \n- **Повернення кількох елементів**: Метод `render()` або функціональний компонент повинні повертати один кореневий елемент. Якщо вам потрібно повернути кілька елементів без створення зайвого `div` (наприклад, у списках або таблицях), `Fragment` є ідеальним рішенням. \n- **Чиста DOM-структура**: Допомагає підтримувати семантично коректну та чисту DOM-структуру, особливо при використанні CSS-фреймворків, таких як Flexbox або Grid, де зайві обгортки можуть порушити макет. \n- **Уникнення 'обгорткових' `div`'ів**: Замість того, щоб писати `<div><ChildA /><ChildB /></div>`, ви можете написати `<><ChildA /><ChildB /></>`, що робить код більш читабельним і не додає зайвого HTML.",
    "additionalQuestions": [
      {
        "id": "react-q21-aq1",
        "question": "Чи можна використовувати `key` з коротким синтаксисом фрагментів (`<></>`)?",
        "answer": "Ні, короткий синтаксис `<></>` не підтримує атрибут `key`. Якщо вам потрібно передати `key` (наприклад, при рендерингу фрагментів у списку), ви повинні використовувати повний синтаксис `React.Fragment` з атрибутом `key`: `<React.Fragment key={item.id}>...</React.Fragment>`."
      },
      {
        "id": "react-q21-aq2",
        "question": "Яка різниця між `React.Fragment` та просто `div` для обгортання елементів?",
        "answer": "`div` створить реальний DOM-елемент у браузері, тоді як `React.Fragment` не додає ніяких додаткових вузлів у DOM. Це може бути важливо для продуктивності та семантики."
      },
      {
        "id": "react-q21-aq3",
        "question": "Чи можуть фрагменти містити лише один дочірній елемент?",
        "answer": "Так, фрагменти можуть містити лише один дочірній елемент, хоча це зазвичай не має сенсу, оскільки сам цей елемент вже є кореневим. Але синтаксично це дозволено."
      }
    ]
  },
  {
    "id": "react-q22",
    "topic": "React",
    "mainQuestion": "Для чого потрібен PropTypes і які види перевірок у ньому доступні?",
    "mainAnswer": "**PropTypes** — це бібліотека (раніше частина React, тепер окремий пакет `prop-types`), яка використовується для **валідації типів props**, що передаються компонентам. Вона допомагає розробникам відловлювати помилки, пов'язані з неправильним типом даних, на етапі розробки, перш ніж вони призведуть до проблем під час виконання. PropTypes є дуже корисним для розробки великих застосунків, де є багато компонентів та розробників. \n**Види перевірок (декілька прикладів):** \n- **Основні типи:** `PropTypes.string`, `PropTypes.number`, `PropTypes.bool`, `PropTypes.array`, `PropTypes.object`, `PropTypes.func`, `PropTypes.symbol`. \n- **Обов'язкові props:** Додайте `.isRequired` до будь-якого типу: `PropTypes.string.isRequired`. \n- **Конкретні типи елементів React:** `PropTypes.element` (для одного елемента), `PropTypes.node` (для будь-якого рендерованого React-об'єкта: числа, рядки, елементи, масиви). \n- **Конкретні значення:** `PropTypes.oneOf(['News', 'Photos'])`. \n- **Масив певного типу:** `PropTypes.arrayOf(PropTypes.number)`. \n- **Об'єкт з певними властивостями:** `PropTypes.shape({ name: PropTypes.string, age: PropTypes.number })`. \n- **Екземпляр класу:** `PropTypes.instanceOf(MyClass)`. \n- **Будь-який тип:** `PropTypes.any` (слід уникати). \nПриклад використання: \n```jsx \nimport PropTypes from 'prop-types'; \nfunction Greeting({ name }) { return <h1>Привіт, {name}</h1>; } \nGreeting.propTypes = { \n  name: PropTypes.string.isRequired \n}; \n``` \n**Важливо**: PropTypes виконує перевірки лише в режимі розробки і не впливає на продуктивність у продакшн-збірці.",
    "additionalQuestions": [
      {
        "id": "react-q22-aq1",
        "question": "Чи замінює TypeScript PropTypes?",
        "answer": "Так, TypeScript значною мірою замінює PropTypes. TypeScript надає статичну типізацію, яка перевіряє типи props під час компіляції (розробки), що є більш надійним і потужним, ніж PropTypes, який працює лише під час виконання в режимі розробки. У більшості сучасних React-проектів з TypeScript PropTypes вже не використовується."
      },
      {
        "id": "react-q22-aq2",
        "question": "Що станеться, якщо передати prop неправильного типу, коли PropTypes встановлений?",
        "answer": "Якщо ви передасте prop неправильного типу, React виведе попередження у консолі розробника в режимі розробки. У режимі продакшну ці перевірки вимкнені, і попередження не відображаються."
      },
      {
        "id": "react-q22-aq3",
        "question": "Чи впливає PropTypes на розмір бандлу (bundle size) застосунку?",
        "answer": "Так, оскільки PropTypes є бібліотекою, її включення збільшує розмір бандлу. Однак, більшість бандлерів (наприклад, Webpack) автоматично видаляють код PropTypes у продакшн-збірках, щоб зменшити розмір файлу для користувача."
      }
    ]
  },
  {
    "id": "react-q23",
    "topic": "React",
    "mainQuestion": "Розкажи про React Hooks.",
    "mainAnswer": "**React Hooks** — це функції, які були представлені в React 16.8, що дозволяють функціональним компонентам використовувати стан (state) та інші можливості React (методи життєвого циклу) без необхідності писати клас. Вони дозволяють 'підключитися' до функцій стану та життєвого циклу React з функціональних компонентів. \n**Основні хуки:** \n- **`useState`**: Дозволяє функціональним компонентам додавати стан. Повертає пару: поточне значення стану та функцію для його оновлення. \n- **`useEffect`**: Дозволяє виконувати побічні ефекти (side effects) у функціональних компонентах (наприклад, завантаження даних, маніпуляції з DOM, підписки). Він спрацьовує після рендерингу, і може бути налаштований на спрацьовування лише при зміні певних залежностей. \n- **`useContext`**: Дозволяє підписуватися на React контекст без вкладеності компонентів. \n- **`useRef`**: Дозволяє створювати рефи для прямого доступу до DOM-елементів або для збереження змінюваних значень, які не викликають повторного рендерингу. \n- **`useReducer`**: Альтернатива `useState` для більш складної логіки стану. \n- **`useCallback` / `useMemo`**: Для оптимізації продуктивності, запам'ятовують функції/значення, щоб уникнути непотрібних перерахунків/перерендерингів. \n\n**Переваги хуків:** \n- **Спрощення коду**: Усувають необхідність писати класи, що зменшує складність коду та полегшує його розуміння. \n- **Повторне використання логіки стану**: Дозволяють легко ділитися логікою стану між компонентами. \n- **Більш зрозумілі життєві цикли**: `useEffect` дозволяє групувати пов'язану логіку (наприклад, підписка та відписка) в одному місці, замість розділення по різних методах життєвого циклу класу. \n- **Простіший тест**: Функціональні компоненти з хуками легше тестувати.",
    "additionalQuestions": [
      {
        "id": "react-q23-aq1",
        "question": "Які 'Правила хуків' (Rules of Hooks) потрібно дотримуватися?",
        "answer": "Існує два основні правила: \n1. **Викликайте хуки лише на верхньому рівні** (Top Level): Не викликайте хуки всередині циклів, умов або вкладених функцій. \n2. **Викликайте хуки лише з функцій React**: Викликайте хуки лише з функціональних компонентів React або з власних (custom) хуків."
      },
      {
        "id": "react-q23-aq2",
        "question": "Чи замінюють хуки повністю компоненти-класи?",
        "answer": "Хоча React офіційно не планує видаляти компоненти-класи, хуки є рекомендованим підходом для написання нового коду, оскільки вони пропонують більш простий та потужний спосіб роботи з функціональністю React. Усі нові функції React будуть додаватися в хуки."
      },
      {
        "id": "react-q23-aq3",
        "question": "У чому відмінність між `useCallback` та `useMemo`?",
        "answer": "`useCallback` використовується для мемоізації **функції**, тобто вона повертає мемоізовану версію функції, яка змінюється лише тоді, коли змінюється одна з її залежностей. `useMemo` використовується для мемоізації **значення**, тобто він повертає мемоізоване значення, яке перераховується лише тоді, коли змінюються його залежності."
      }
    ]
  },
  {
    "id": "react-q24",
    "topic": "React",
    "mainQuestion": "Що таке React Portals і коли їх варто використовувати?",
    "mainAnswer": "**React Portals** — це функція, яка дозволяє рендерити дочірні елементи поза DOM-ієрархією батьківського компонента. Це корисно для створення модальних вікон, спливаючих меню, тултипів та інших елементів, які повинні 'вириватися' з поточного контексту DOM, але при цьому зберігати логіку та стан React-компонента. \n**Коли використовувати:** \n- **Модальні вікна**: Коли потрібно відобразити модальне вікно поверх іншого контенту, не порушуючи структуру DOM. \n- **Спливаючі меню/Тултипи**: Коли потрібно розмістити елемент поверх інших елементів без зміни їхнього порядку в DOM. \n- **Контекстні меню**: Для створення контекстних меню, які відкриваються при кліку правою кнопкою миші. \n\n**Приклад використання:** \n```jsx \nimport ReactDOM from 'react-dom'; \nfunction Modal({ children }) { \n  return ReactDOM.createPortal( \n    <div className=\"modal\">{children}</div>, \n    document.getElementById('modal-root') // Цільовий вузол у DOM \n  ); \n} \n``` \nУ цьому прикладі `Modal` рендериться у вузол з ID `modal-root`, який може бути розташований поза ієрархією батьківського компонента.",
    "additionalQuestions": [
      {
        "id": "react-q24-aq1",
        "question": "Чи можна передавати `props` до компонентів, що рендеряться через портали?",
        "answer": "Так, ви можете передавати `props` до компонентів, що рендеряться через портали, так само, як і до звичайних компонентів."
      },
      {
        "id": "react-q24-aq2",
        "question": "Чи впливають портали на CSS-стилі?",
        "answer": "Так, портали рендерять елементи в інше місце в DOM, але вони все ще підпорядковуються CSS-правилам. Ви можете стилізувати їх так само, як і звичайні елементи, але потрібно бути обережним з контекстом стилів (наприклад, якщо використовуються CSS-селектори, які залежать від батьківських елементів)."
      },
      {
        "id": "react-q24-aq3",
        "question": "Чи можна використовувати портали для рендерингу компонентів у різних частинах DOM?",
        "answer": "Так, портали дозволяють рендерити компоненти в будь-якому місці DOM, що робить їх дуже гнучкими для створення UI-елементів, які потребують особливого розташування в DOM."
      }
    ]
  },
  {
    "id": "react-q25",
    "topic": "React",
    "mainQuestion": "Що таке React Context і коли його варто використовувати?",
    "mainAnswer": "**React Context** — це механізм, який дозволяє передавати дані через дерево компонентів без необхідності передавати їх через `props` на кожному рівні. Це особливо корисно для глобальних даних, таких як налаштування теми, мова, автентифікація користувача тощо. \n**Коли використовувати:** \n- **Глобальні налаштування**: Коли потрібно передати налаштування, які використовуються в багатьох компонентах (наприклад, тема, мова). \n- **Дані автентифікації**: Для зберігання інформації про поточного користувача та його статус автентифікації. \n- **Загальні функції**: Коли потрібно передати функції або методи, які використовуються в багатьох компонентах (наприклад, функція для відкриття модального вікна). \n\n**Приклад використання:** \n```jsx \nimport React, { createContext, useContext } from 'react'; \nconst ThemeContext = createContext('light'); // Створення контексту з дефолтним значенням 'light' \nfunction ThemedComponent() { \n  const theme = useContext(ThemeContext); // Використання контексту \n  return <div className={`theme-${theme}`}>Тема: {theme}</div>; \n} \nfunction App() { \n  return ( \n    <ThemeContext.Provider value=\"dark\"> {/* Передача значення контексту */} \n      <ThemedComponent /> \n    </ThemeContext.Provider> \n  ); \n} \n```",
    "additionalQuestions": [
      {
        "id": "react-q25-aq1",
        "question": "Чи можна використовувати Context для управління станом?",
        "answer": "Так, Context може бути використаний для управління станом, але він не є заміною для систем управління станом (наприклад, Redux, Zustand). Context краще підходить для глобальних даних, які не змінюються часто, оскільки часті зміни контексту можуть призводити до непотрібних повторних рендерингів компонентів, які його використовують."
      },
      {
        "id": "react-q25-aq2",
        "question": "Чи можна використовувати кілька контекстів у одному компоненті?",
        "answer": "Так, ви можете використовувати кілька контекстів у одному компоненті, просто імпортуючи та використовуючи їх окремо. Це дозволяє комбінувати різні глобальні дані в одному компоненті."
      },
      {
        "id": "react-q25-aq3",
        "question": "Які є альтернативи React Context для управління глобальним станом?",
        "answer": "Альтернативами React Context для управління глобальним станом є системи управління станом, такі як Redux, Zustand, Recoil, MobX або використання хуків, таких як `useReducer` у поєднанні з Context."
      }
    ]
  },
  {
    "id": "react-q26",
    "topic": "React",
    "mainQuestion": "Що таке React.memo і для чого він використовується?",
    "mainAnswer": "**React.memo** — це вищий порядок компонент (Higher Order Component, HOC), який дозволяє оптимізувати продуктивність функціональних компонентів, запобігаючи їхньому повторному рендерингу, якщо їхні `props` не змінилися. Це корисно для компонентів, які отримують однакові `props` і не потребують повторного рендерингу при кожному оновленні батьківського компонента. \n**Як працює:** \n- `React.memo` порівнює попередні та нові `props` компонента. Якщо `props` не змінилися, компонент не буде перерендерено. \n- Ви можете передати власну функцію порівняння як другий аргумент до `React.memo`, щоб визначити, чи потрібно перерендерювати компонент на основі специфічних умов. \n\n**Приклад використання:** \n```jsx \nimport React from 'react'; \nconst MyComponent = React.memo(({ value }) => { \n  console.log('Рендеринг MyComponent'); \n  return <div>{value}</div>; \n}); \n``` \nУ цьому прикладі `MyComponent` буде перерендерено лише тоді, коли зміниться `value`. Якщо батьківський компонент оновиться з іншими `props`, але `value` залишиться незмінним, `MyComponent` не буде перерендерено.",
    "additionalQuestions": [
      {
        "id": "react-q26-aq1",
        "question": "Чи можна використовувати React.memo з класовими компонентами?",
        "answer": "Ні, `React.memo` призначений лише для функціональних компонентів. Для класових компонентів можна використовувати методи життєвого циклу, такі як `shouldComponentUpdate`, для оптимізації рендерингу."
      },
      {
        "id": "react-q26-aq2",
        "question": "Чи впливає React.memo на продуктивність у всіх випадках, чи є ситуації, коли його не варто використовувати?",
        "answer": "React.memo може покращити продуктивність, але не завжди. Якщо компонент часто отримує нові `props`, або якщо порівняння `props` є дорогим, використання `React.memo` може навіть погіршити продуктивність через додаткові витрати на порівняння. Тому його варто використовувати лише для компонентів, які отримують стабільні `props` і не потребують частого оновлення."
      },
      {
        "id": "react-q26-aq3",
        "question": "Як React.memo взаємодіє з хуками, такими як useState або useEffect?",
        "answer": "`React.memo` не впливає на роботу хуків, таких як `useState` або `useEffect`. Хуки все ще працюватимуть у межах компонента, і їхній стан буде збережено між рендерами. Однак, якщо `props` компонента не змінюються, то компонент не буде перерендерено, що може призвести до того, що хуки не будуть викликані знову."
      }
    ]
  },
  {
    "id": "react-q27",
    "topic": "React",
    "mainQuestion": "Що таке React Suspense і для чого він використовується?",
    "mainAnswer": "**React Suspense** — це функція, яка дозволяє відкладати рендеринг компонентів до тих пір, поки не будуть завантажені необхідні дані або ресурси. Це особливо корисно для асинхронного завантаження даних, таких як запити до API, або для динамічного імпорту компонентів. \n**Основні можливості:** \n- **Асинхронне завантаження даних**: Дозволяє 'захоплювати' стан завантаження та показувати запасний контент (наприклад, спінер) під час очікування на дані. \n- **Динамічний імпорт компонентів**: Дозволяє відкладати завантаження компонентів до моменту їхнього використання, що може зменшити початковий розмір бандлу. \n\n**Приклад використання:** \n```jsx \nimport React, { Suspense, lazy } from 'react'; \nconst LazyComponent = lazy(() => import('./LazyComponent')); // Динамічний імпорт компонента \nfunction App() { \n  return ( \n    <Suspense fallback={<div>Завантаження...</div>}> {/* Запасний контент */} \n      <LazyComponent /> \n    </Suspense> \n  ); \n} \n``` \nУ цьому прикладі `LazyComponent` буде завантажено асинхронно, а поки він завантажується, буде показано текст 'Завантаження...'.",
    "additionalQuestions": [
      {
        "id": "react-q27-aq1",
        "question": "Чи можна використовувати Suspense без React.lazy?",
        "answer": "Так, Suspense можна використовувати з будь-яким асинхронним кодом, який підтримує 'захоплення' стану завантаження. Наприклад, ви можете використовувати його з асинхронними запитами до API, якщо ви створите власний механізм для 'захоплення' стану завантаження. Однак, React.lazy є найбільш поширеним способом використання Suspense."
      },
      {
        "id": "react-q27-aq2",
        "question": "Чи підтримує Suspense серверний рендеринг (SSR)?",
        "answer": "Так, Suspense підтримує серверний рендеринг, але для цього потрібна спеціальна конфігурація та використання `ReactDOMServer.renderToPipeableStream` або `ReactDOMServer.renderToString` з відповідними опціями. Це дозволяє серверу віддавати HTML, який містить запасний контент, поки асинхронні компоненти завантажуються."
      },
      {
        "id": "react-q27-aq3",
        "question": "Які є обмеження при використанні React Suspense?",
        "answer": "Одне з основних обмежень — це те, що Suspense працює лише з асинхронними компонентами або даними, які підтримують 'захоплення' стану завантаження. Крім того, Suspense не може бути використаний для синхронних компонентів або даних, які вже доступні на момент рендерингу."
      }
    ]
  },
  {
    "id": "react-q28",
    "topic": "React",
    "mainQuestion": "Що таке React Server Components і як вони відрізняються від звичайних компонентів?",
    "mainAnswer": "**React Server Components** (RSC) — це новий тип компонентів у React, які дозволяють виконувати рендеринг на сервері. Вони дозволяють розробникам створювати компоненти, які можуть виконувати асинхронні запити до бази даних або API без необхідності передавати дані через клієнтський JavaScript. \n**Основні особливості:** \n- **Рендеринг на сервері**: Компоненти RSC рендеряться на сервері, що дозволяє зменшити обсяг JavaScript, який потрібно завантажити на клієнт. \n- **Асинхронність**: RSC можуть виконувати асинхронні запити до бази даних або API без блокування рендерингу. \n- **Відсутність стану**: RSC не мають стану (state) та життєвого циклу, оскільки вони призначені для рендерингу на сервері. \n\n**Приклад використання:** \n```jsx \n// Це псевдокод, оскільки RSC ще не є стабільною частиною React на момент написання цієї відповіді. \nimport { createServerComponent } from 'react'; \nconst MyServerComponent = createServerComponent(async () => { \n  const data = await fetchDataFromAPI(); // Асинхронний запит до API \n  return <div>{data}</div>; // Рендеринг даних на сервері \n}); \n``` \nУ цьому прикладі `MyServerComponent` виконує асинхронний запит до API та рендерить отримані дані на сервері.",
    "additionalQuestions": [
      {
        "id": "react-q28-aq1",
        "question": "Чи можна використовувати хуки в React Server Components?",
        "answer": "Ні, React Server Components не підтримують хуки, оскільки вони не мають стану (state) та життєвого циклу. Вони призначені лише для рендерингу даних на сервері."
      },
      {
        "id": "react-q28-aq2",
        "question": "Як React Server Components впливають на продуктивність застосунку?",
        "answer": "React Server Components можуть значно покращити продуктивність застосунку, оскільки вони дозволяють зменшити обсяг JavaScript, який потрібно завантажити на клієнт. Це може призвести до швидшого рендерингу та кращого користувацького досвіду, особливо для великих застосунків з багатьма компонентами."
      },
      {
        "id": "react-q28-aq3",
        "question": "Чи можна використовувати React Server Components разом з клієнтськими компонентами?",
        "answer": "Так, React Server Components можуть бути використані разом з клієнтськими компонентами. Ви можете створювати гібридні застосунки, де деякі компоненти рендеряться на сервері, а інші — на клієнті, що дозволяє оптимізувати продуктивність та користувацький досвід."
      }
    ]
  },
  {
    "id": "react-q29",
    "topic": "React",
    "mainQuestion": "Що таке React Strict Mode і для чого він використовується?",
    "mainAnswer": "**React Strict Mode** — це інструмент для виявлення потенційних проблем у React-застосунках. Він не впливає на рендеринг, але активує додаткові перевірки та попередження для компонентів, що допомагає розробникам виявляти небезпечні практики та помилки. \n**Основні можливості:** \n- **Виявлення небезпечних методів життєвого циклу**: Попереджає про використання застарілих методів життєвого циклу, таких як `componentWillMount`, `componentWillReceiveProps` та `componentWillUpdate`. \n- **Перевірка наявності ключів у списках**: Перевіряє, чи всі елементи в масивах мають унікальні ключі. \n- **Виявлення побічних ефектів**: Перевіряє, чи компоненти не мають побічних ефектів у методах рендерингу. \n- **Дублювання викликів методів**: Дублює виклики методів життєвого циклу (наприклад, `render`) для виявлення проблем з чистотою компонентів. \n\n**Приклад використання:** \n```jsx \nimport React from 'react'; \nfunction App() { \n  return ( \n    <React.StrictMode> {/* Обгортання застосунку в Strict Mode */} \n      <MyComponent /> \n    </React.StrictMode> \n  ); \n} \n```",
    "additionalQuestions": [
      {
        "id": "react-q29-aq1",
        "question": "Чи впливає Strict Mode на продуктивність застосунку?",
        "answer": "Strict Mode може незначно вплинути на продуктивність під час розробки, оскільки він дублює виклики методів життєвого циклу для виявлення проблем. Однак у продакшн-збірці ці перевірки вимкнені, тому вони не впливають на продуктивність кінцевого застосунку."
      },
      {
        "id": "react-q29-aq2",
        "question": "Чи можна використовувати Strict Mode з класовими компонентами?",
        "answer": "Так, Strict Mode працює як з функціональними, так і з класовими компонентами. Він перевіряє всі компоненти, незалежно від їхнього типу."
      },
      {
        "id": "react-q29-aq3",
        "question": "Чи можна використовувати Strict Mode в продакшн-збірці?",
        "answer": "Strict Mode призначений для використання лише в режимі розробки. У продакшн-збірці він не має сенсу, оскільки всі перевірки вимкнені. Тому його слід використовувати лише під час розробки для виявлення потенційних проблем."
      }
    ]
  }
]