[
  {
    "id": "vue-q1",
    "topic": "Vue",
    "mainQuestion": "Що таке Vue.js і які його ключові особливості?",
    "mainAnswer": "Vue.js – це прогресивний JavaScript-фреймворк з відкритим вихідним кодом для побудови користувацьких інтерфейсів та односторінкових додатків. Його ключові особливості включають: реактивність, компонентно-орієнтована архітектура, віртуальний DOM, простота у вивченні та використанні, а також гнучкість, що дозволяє використовувати його як бібліотеку або як повноцінний фреймворк.",
    "additionalQuestions": [
      {
        "id": "vue-q1-aq1",
        "question": "Чим Vue.js відрізняється від Angular та React?",
        "answer": "Vue.js часто вважають чимось середнім між Angular та React. Він більш гнучкий і менш 'opinionated' (нав'язуючий свою думку), ніж Angular, але пропонує більше вбудованих рішень (наприклад, реактивність, шаблони) порівняно з React, який є більш бібліотекою для UI. Vue часто хвалять за його простоту та криву навчання."
      },
      {
        "id": "vue-q1-aq2",
        "question": "Що означає 'прогресивний фреймворк' у контексті Vue.js?",
        "answer": "Прогресивний фреймворк означає, що Vue.js можна використовувати поступово. Можна почати з додавання невеликих інтерактивних елементів на існуючу сторінку (як бібліотека) і поступово розширювати його до повноцінного SPA, якщо це необхідно. Це робить його дуже гнучким для інтеграції."
      },
      {
        "id": "vue-q1-aq3",
        "question": "Для яких типів проектів Vue.js підходить найкраще?",
        "answer": "Vue.js відмінно підходить для широкого спектру проектів: від невеликих інтерактивних компонентів на існуючих сайтах до великих односторінкових додатків (SPA), мобільних додатків (через NativeScript або Ionic) та десктопних додатків (через Electron)."
      }
    ]
  },
  {
    "id": "vue-q2",
    "topic": "Vue",
    "mainQuestion": "Поясніть концепцію компонентів (Components) у Vue.js.",
    "mainAnswer": "Компоненти – це багаторазові, самодостатні та інкапсульовані блоки коду, які складають UI-додатки у Vue.js. Кожен компонент має свій шаблон (HTML), скрипт (JavaScript) та стилі (CSS), що робить його логічною одиницею для розробки інтерфейсу.",
    "additionalQuestions": [
      {
        "id": "vue-q2-aq1",
        "question": "Як виглядає структура однофайлового компонента (.vue)?",
        "answer": "Однофайловий компонент Vue.js зазвичай складається з трьох основних блоків: `<template>` для HTML-розмітки, `<script>` для JavaScript-логіки та `<style>` для CSS-стилів. Це забезпечує чисту і організовану структуру для кожного компонента."
      },
      {
        "id": "vue-q2-aq2",
        "question": "Як реєструвати компоненти у Vue.js?",
        "answer": "Компоненти можна реєструвати глобально (доступні в будь-якому місці додатку) або локально (доступні лише в межах певного батьківського компонента). Глобальна реєстрація: `Vue.component('my-component', { ... })`. Локальна реєстрація: в опції `components` батьківського компонента."
      },
      {
        "id": "vue-q2-aq3",
        "question": "Що таке 'props' і 'events' у контексті компонентів?",
        "answer": "**Props** (властивості) використовуються для передачі даних від батьківського компонента до дочірнього. **Events** (події) використовуються для зворотного зв'язку, дозволяючи дочірньому компоненту сповіщати батьківський компонент про певні дії або зміни."
      }
    ]
  },
  {
    "id": "vue-q3",
    "topic": "Vue",
    "mainQuestion": "Що таке реактивність у Vue.js і як вона працює?",
    "mainAnswer": "Реактивність у Vue.js – це механізм, який автоматично відстежує зміни в стані даних і відповідним чином оновлює DOM. Vue досягає цього за допомогою геттерів/сеттерів JavaScript та, в Vue 3, за допомогою `Proxy` для більш ефективного відстеження змін.",
    "additionalQuestions": [
      {
        "id": "vue-q3-aq1",
        "question": "Як Vue відстежує зміни в об'єктах та масивах?",
        "answer": "У Vue 2, для об'єктів Vue перетворює властивості на геттери/сеттери. Для масивів Vue перевизначає мутуючі методи (push, pop, splice тощо). У Vue 3, завдяки `Proxy`, відстеження змін в об'єктах та масивах стало набагато повнішим і ефективнішим, покриваючи додавання/видалення властивостей та прямий доступ до індексів масиву."
      },
      {
        "id": "vue-q3-aq2",
        "question": "Що таке 'computed properties' (обчислювані властивості) і 'watchers' (спостерігачі)?",
        "answer": "**Computed properties** використовуються для обчислення значень на основі реактивних даних. Вони кешуються і перераховуються лише тоді, коли їхні залежності змінюються. **Watchers** дозволяють виконувати довільну асинхронну або дорогу операцію у відповідь на зміни певних реактивних даних."
      },
      {
        "id": "vue-q3-aq3",
        "question": "Яка різниця між `ref` та `reactive` у Vue 3 Composition API?",
        "answer": "`ref` використовується для створення реактивного посилання на примітивні значення (числа, рядки, булеві) та об'єкти. Він повертає об'єкт з властивістю `.value`. `reactive` використовується для створення реактивних об'єктів (включаючи масиви), які є Proxy-об'єктами. `reactive` не потрібно використовувати `.value` для доступу до властивостей."
      }
    ]
  },
  {
    "id": "vue-q4",
    "topic": "Vue",
    "mainQuestion": "Опишіть життєвий цикл компонента у Vue.js. Назвіть основні хуки.",
    "mainAnswer": "Життєвий цикл компонента Vue – це послідовність етапів, через які проходить компонент, від його створення до знищення. Vue надає хуки (lifecycle hooks), які дозволяють виконувати код на певних етапах. Основні хуки для Options API: `beforeCreate`, `created`, `beforeMount`, `mounted`, `beforeUpdate`, `updated`, `beforeUnmount`, `unmounted`.",
    "additionalQuestions": [
      {
        "id": "vue-q4-aq1",
        "question": "Коли варто використовувати `created` та `mounted` хуки?",
        "answer": "`created` викликається після того, як екземпляр компонента створено, дані реактивно налаштовані, але DOM ще не змонтовано. Це гарне місце для ініціалізації даних. `mounted` викликається після того, як компонент змонтовано в DOM. Це місце для взаємодії з DOM або виконання сторонніх бібліотек, що залежать від DOM."
      },
      {
        "id": "vue-q4-aq2",
        "question": "Який хук використовується для очищення ресурсів і чому?",
        "answer": "`unmounted` (або `beforeUnmount` в Vue 3, `beforeDestroy` / `destroyed` у Vue 2) використовується для очищення ресурсів, таких як відписка від подій, очищення таймерів або звільнення пам'яті. Це важливо для запобігання витокам пам'яті та коректного завершення роботи компонента."
      },
      {
        "id": "vue-q4-aq3",
        "question": "Як життєві цикли працюють з Composition API (Vue 3)?",
        "answer": "У Composition API хуки життєвого циклу імпортуються як функції (наприклад, `onMounted`, `onUpdated`, `onUnmounted`) та викликаються всередині функції `setup()`. Це дозволяє групувати логіку за функціональністю, а не за хуками, покращуючи читабельність для складних компонентів."
      }
    ]
  },
  {
    "id": "vue-q5",
    "topic": "Vue",
    "mainQuestion": "Поясніть, що таке маршрутизація (Routing) у Vue.js та як вона реалізується.",
    "mainAnswer": "Маршрутизація у Vue.js дозволяє відображати різні компоненти в залежності від URL-адреси, створюючи багатосторінковий досвід в односторінковому додатку без перезавантаження сторінки. Вона реалізується за допомогою офіційної бібліотеки **Vue Router**.",
    "additionalQuestions": [
      {
        "id": "vue-q5-aq1",
        "question": "Яка роль `<router-view>` та `<router-link>`?",
        "answer": "`<router-view>` – це компонент, який є плейсхолдером. Він відображає компонент, що відповідає поточному маршруту. `<router-link>` – це компонент, який генерує посилання для навігації між маршрутами, аналогічно тегу `<a>`."
      },
      {
        "id": "vue-q5-aq2",
        "question": "Як передавати параметри в маршрут і отримувати їх у компоненті?",
        "answer": "Параметри можна передавати як частину URL (динамічні сегменти маршруту, наприклад, `/users/:id`) або як query-параметри (`/users?id=123`). У компоненті вони доступні через об'єкт `$route.params` або `$route.query`."
      },
      {
        "id": "vue-q5-aq3",
        "question": "Що таке 'Navigation Guards' (захисники навігації) у Vue Router?",
        "answer": "Navigation Guards дозволяють перехоплювати навігацію та виконувати логіку до, під час або після неї. Вони використовуються для перевірки автентифікації, авторизації, підтвердження залишення сторінки або отримання даних перед рендерингом."
      }
    ]
  },
  {
    "id": "vue-q6",
    "topic": "Vue",
    "mainQuestion": "Як працювати з HTTP-запитами у Vue.js?",
    "mainAnswer": "Vue.js не має вбудованого HTTP-клієнта. Зазвичай для роботи з HTTP-запитами використовують популярні бібліотеки, такі як **Axios** або вбудований **Fetch API** браузера. Ці бібліотеки дозволяють надсилати GET, POST, PUT, DELETE запити до API та обробляти відповіді.",
    "additionalQuestions": [
      {
        "id": "vue-q6-aq1",
        "question": "Наведіть приклад використання Axios для GET-запиту.",
        "answer": "```javascript\naxios.get('/api/data')\n  .then(response => {\n    console.log(response.data);\n  })\n  .catch(error => {\n    console.error('There was an error!', error);\n  });\n```"
      },
      {
        "id": "vue-q6-aq2",
        "question": "Як обробляти помилки HTTP-запитів?",
        "answer": "Помилки HTTP-запитів обробляються за допомогою блоків `.catch()` для Promise-базованих бібліотек (Axios, Fetch API) або за допомогою відповідних методів для Observable-базованих підходів. Важливо перевіряти статус коду відповіді (наприклад, 4xx, 5xx)."
      },
      {
        "id": "vue-q6-aq3",
        "question": "Чи можна створити централізований сервіс для HTTP-запитів у Vue?",
        "answer": "Так, це рекомендована практика. Можна створити окремий JavaScript-файл (наприклад, `api.js` або `http-service.js`), який інкапсулює логіку HTTP-запитів, налаштування базового URL, обробку помилок та додавання заголовків (наприклад, токенів авторизації). Потім цей сервіс імпортується та використовується в компонентах або Vuex-модулях."
      }
    ]
  },
  {
    "id": "vue-q7",
    "topic": "Vue",
    "mainQuestion": "Що таке Vuex і для чого він використовується?",
    "mainAnswer": "Vuex – це централізоване сховище для управління станом додатку у Vue.js, реалізація шаблону Flux/Redux. Він допомагає керувати складним станом у великих додатках, забезпечуючи передбачуваний шаблон для мутації стану.",
    "additionalQuestions": [
      {
        "id": "vue-q7-aq1",
        "question": "Які основні концепції Vuex?",
        "answer": "Основні концепції Vuex: **State** (централізований стан), **Getters** (обчислювані властивості для стану), **Mutations** (синхронні функції для зміни стану), **Actions** (асинхронні операції, які викликають мутації) та **Modules** (розбиття сховища на підмодулі)."
      },
      {
        "id": "vue-q7-aq2",
        "question": "Чому мутації (Mutations) повинні бути синхронними?",
        "answer": "Мутації повинні бути синхронними, щоб Vuex Devtools могли точно відстежувати зміни стану. Якщо мутації були б асинхронними, порядок змін став би непередбачуваним, і налагоджувати додаток було б дуже складно."
      },
      {
        "id": "vue-q7-aq3",
        "question": "Коли варто використовувати Vuex, а коли можна обійтися без нього?",
        "answer": "Vuex варто використовувати у великих додатках, де багато компонентів потребують доступу до спільного стану, або коли стан змінюється з багатьох джерел. Для невеликих додатків або локального стану компонентів можна обійтися передачею props/emit events або Composition API з `provide`/`inject`."
      }
    ]
  },
  {
    "id": "vue-q8",
    "topic": "Vue",
    "mainQuestion": "Що таке директиви (Directives) у Vue.js? Назвіть кілька прикладів.",
    "mainAnswer": "Директиви у Vue.js – це спеціальні атрибути з префіксом `v-` (наприклад, `v-if`, `v-for`, `v-bind`, `v-on`), які додають реактивну поведінку до елементів DOM. Вони дозволяють маніпулювати DOM на основі змін даних.",
    "additionalQuestions": [
      {
        "id": "vue-q8-aq1",
        "question": "Поясніть призначення `v-if`, `v-show` та їхні відмінності.",
        "answer": "`v-if` використовується для умовного рендерингу елементів: він повністю додає або видаляє елемент з DOM. `v-show` також використовується для умовного відображення, але він лише перемикає CSS-властивість `display` елемента. `v-if` дорожчий на етапі перемикання, але менш дорогий на етапі початкового рендерингу, тоді як `v-show` навпаки."
      },
      {
        "id": "vue-q8-aq2",
        "question": "Що таке `v-bind` та `v-on` (або `:` та `@`)?",
        "answer": "`v-bind` (скорочено `:`) використовується для динамічного прив'язування одного або кількох атрибутів HTML або властивостей компонента до виразу даних Vue. `v-on` (скорочено `@`) використовується для прослуховування подій DOM та виконання JavaScript при їх виникненні."
      },
      {
        "id": "vue-q8-aq3",
        "question": "Чи можна створити власну директиву?",
        "answer": "Так, Vue.js дозволяє створювати власні кастомні директиви, які можуть маніпулювати DOM або додавати спеціальну поведінку елементам. Це корисно для логіки, яка взаємодіє безпосередньо з DOM, але не є частиною основної логіки компонента."
      }
    ]
  },
  {
    "id": "vue-q9",
    "topic": "Vue",
    "mainQuestion": "Що таке слоти (Slots) у Vue.js і для чого вони потрібні?",
    "mainAnswer": "Слоти у Vue.js – це механізм для композиції компонентів, що дозволяє батьківському компоненту вставляти HTML-контент у визначені місця шаблону дочірнього компонента. Це забезпечує гнучкість та повторне використання компонентів.",
    "additionalQuestions": [
      {
        "id": "vue-q9-aq1",
        "question": "Яка різниця між іменованими слотами та слотами за замовчуванням?",
        "answer": "Слот за замовчуванням (без імені) використовується для вставки основного контенту. Іменовані слоти дозволяють вставляти контент у кілька конкретних місць дочірнього компонента, використовуючи атрибут `name` у тегу `<slot>` та `v-slot:name` або `#name` у батьківському компоненті."
      },
      {
        "id": "vue-q9-aq2",
        "question": "Що таке 'Scoped Slots' (слоти з областю видимості)?",
        "answer": "Scoped Slots дозволяють дочірньому компоненту передавати дані назад у батьківський компонент під час рендерингу вмісту слота. Це дозволяє батьківському компоненту отримати доступ до даних дочірнього компонента для рендерингу вмісту всередині слота."
      },
      {
        "id": "vue-q9-aq3",
        "question": "Коли варто використовувати слоти замість props?",
        "answer": "Слоти варто використовувати, коли потрібно передати блоки HTML-контенту (наприклад, елементи, інші компоненти), які не є просто рядками або числами. Props використовуються для передачі структурованих даних, таких як рядки, числа, об'єкти, масиви."
      }
    ]
  },
  {
    "id": "vue-q10",
    "topic": "Vue",
    "mainQuestion": "Як працювати з формами (Forms) у Vue.js?",
    "mainAnswer": "У Vue.js для роботи з формами зазвичай використовується директива `v-model` для двостороннього зв'язування даних між елементами форми та даними компонента. Це спрощує обробку введення користувача та синхронізацію даних.",
    "additionalQuestions": [
      {
        "id": "vue-q10-aq1",
        "question": "Поясніть роботу `v-model`.",
        "answer": "`v-model` є синтаксичним цукром для `v-bind:value` та `v-on:input` (для текстових полів введення). Це означає, що він автоматично оновлює дані компонента, коли користувач вводить дані у поле, і навпаки, оновлює поле введення, коли змінюються дані компонента."
      },
      {
        "id": "vue-q10-aq2",
        "question": "Як додати валідацію до форм у Vue.js?",
        "answer": "Валідація форм може бути реалізована вручну за допомогою умовних виразів та методів у компоненті, або за допомогою спеціалізованих бібліотек валідації, таких як Vuelidate або VeeValidate, які надають більш структурований підхід."
      },
      {
        "id": "vue-q10-aq3",
        "question": "Як обробляти відправку форми?",
        "answer": "Відправка форми обробляється за допомогою директиви `v-on:submit` (або `@submit`) на тегу `<form>`, яка викликає метод у компоненті. Важливо використовувати модифікатор `.prevent` (наприклад, `@submit.prevent`) для запобігання стандартній поведінці браузера щодо перезавантаження сторінки."
      }
    ]
  },
  {
    "id": "vue-q11",
    "topic": "Vue",
    "mainQuestion": "Що таке міксини (Mixins) та як вони використовуються у Vue.js?",
    "mainAnswer": "Міксини – це гнучкий спосіб повторного використання коду (логіки та функціональності) між компонентами у Vue.js. Вони дозволяють об'єднати властивості, методи, хуки життєвого циклу та інші опції з міксину в компонент, де вони використовуються.",
    "additionalQuestions": [
      {
        "id": "vue-q11-aq1",
        "question": "Які обмеження та потенційні проблеми з використанням міксинів?",
        "answer": "Обмеження міксинів включають: потенційні колізії імен властивостей або методів, складність відстеження джерела даних/логіки при багатьох міксинах, неявні залежності та обмежені можливості для повного повторного використання стану. У Vue 3 Composition API є кращою альтернативою для повторного використання логіки."
      },
      {
        "id": "vue-q11-aq2",
        "question": "У чому перевага Composition API перед міксинами для повторного використання логіки?",
        "answer": "Composition API (Vue 3) вирішує проблеми міксинів, дозволяючи групувати пов'язану логіку (через функції `setup()`, `ref`, `reactive`, `computed` тощо) у переносимі функції, що називаються 'composable'. Це забезпечує кращу організацію, усуває колізії імен та полегшує розуміння потоку даних та логіки."
      },
      {
        "id": "vue-q11-aq3",
        "question": "Наведіть приклад сценарію, де міксин може бути корисним.",
        "answer": "Міксин може бути корисним для спільної поведінки, яка не залежить від конкретного UI. Наприклад, міксин для логіки пагінації, фільтрації списку, керування модальним вікном або отримання даних, що використовуються в кількох компонентах."
      }
    ]
  },
  {
    "id": "vue-q12",
    "topic": "Vue",
    "mainQuestion": "Як оптимізувати продуктивність Vue.js-додатку?",
    "mainAnswer": "Оптимізація продуктивності Vue.js включає: ліниве завантаження компонентів та маршрутів, використання ключа `key` у `v-for`, мемоізація обчислюваних властивостей, оптимізація рендерингу (наприклад, `v-once`), віртуалізація довгих списків, оптимізація розміру bundle (Tree Shaking, збірка для продакшну) та використання `keep-alive` для кешування компонентів.",
    "additionalQuestions": [
      {
        "id": "vue-q12-aq1",
        "question": "Що таке 'Tree Shaking' і як він впливає на розмір bundle?",
        "answer": "Tree Shaking – це оптимізація, яка видаляє невикористаний код з кінцевого JavaScript-бандла. Вона допомагає зменшити розмір файлу, що завантажується браузером, покращуючи час завантаження додатка."
      },
      {
        "id": "vue-q12-aq2",
        "question": "Яка роль атрибута `key` у `v-for`?",
        "answer": "Атрибут `key` у `v-for` допомагає Vue ефективно відстежувати ідентичність вузлів DOM. Коли дані в списку змінюються, `key` дозволяє Vue повторно використовувати або переміщувати існуючі елементи, замість того, щоб перемальовувати їх повністю, що покращує продуктивність."
      },
      {
        "id": "vue-q12-aq3",
        "question": "Коли варто використовувати `<KeepAlive>` компонент?",
        "answer": "`<KeepAlive>` – це вбудований компонент Vue, який дозволяє кешувати динамічні компоненти, які перемикаються. Це запобігає їх повторному рендерингу та знищенню при кожному переключенні, зберігаючи їхній стан і покращуючи продуктивність навігації."
      }
    ]
  },
  {
    "id": "vue-q13",
    "topic": "Vue",
    "mainQuestion": "Що таке Vue CLI і для чого він використовується?",
    "mainAnswer": "Vue CLI – це стандартний інструментарій командного рядка для швидкої розробки Vue.js додатків. Він надає засоби для генерації проекту з готовою конфігурацією, управління плагінами, збірки та розгортання додатків.",
    "additionalQuestions": [
      {
        "id": "vue-q13-aq1",
        "question": "Які переваги використання Vue CLI порівняно з ручним налаштуванням проекту?",
        "answer": "Vue CLI значно прискорює початок роботи, надаючи готову конфігурацію для Webpack, Babel, ESLint, тестування тощо. Це дозволяє розробникам зосередитися на кодуванні, а не на налаштуванні збірки."
      },
      {
        "id": "vue-q13-aq2",
        "question": "Як створити новий проект за допомогою Vue CLI?",
        "answer": "Новий проект створюється командою `vue create my-project-name`. CLI запропонує вибрати пресети (стандартну конфігурацію) або вручну налаштувати функції (TypeScript, Vue Router, Vuex, CSS Pre-processors тощо)."
      },
      {
        "id": "vue-q13-aq3",
        "question": "Чи можна розширити або налаштувати конфігурацію Vue CLI?",
        "answer": "Так, Vue CLI надає можливість розширювати та налаштовувати конфігурацію Webpack та інших інструментів через файли `vue.config.js` або шляхом додавання плагінів."
      }
    ]
  },
  {
    "id": "vue-q14",
    "topic": "Vue",
    "mainQuestion": "Поясніть концепцію `provide` / `inject` у Vue.js (Vue 3 Composition API).",
    "mainAnswer": "`provide` та `inject` – це пара функцій, що використовуються в Composition API Vue 3 (а також в Options API з Vue 2.2+) для 'ін'єкції' залежностей. `provide` дозволяє батьківському компоненту 'надати' значення, яке потім може бути 'ін'єктоване' будь-яким нащадком у дереві компонентів, незалежно від глибини вкладеності.",
    "additionalQuestions": [
      {
        "id": "vue-q14-aq1",
        "question": "Яка головна перевага `provide` / `inject` над props drilling?",
        "answer": "Головна перевага полягає в уникненні 'props drilling' (передачі props через багато рівнів вкладеності компонентів, де проміжні компоненти не використовують ці props). `provide` / `inject` дозволяє передавати дані безпосередньо від постачальника до будь-якого споживача, що робить код чистішим та легшим для підтримки."
      },
      {
        "id": "vue-q14-aq2",
        "question": "Чи є `provide` / `inject` реактивним?",
        "answer": "Так, надані значення можуть бути реактивними. Якщо надається реактивний об'єкт або `ref`, то всі компоненти, які ін'єктують це значення, будуть реагувати на його зміни. Для цього потрібно використовувати `ref` або `reactive` при наданні значення."
      },
      {
        "id": "vue-q14-aq3",
        "question": "Коли варто використовувати `provide` / `inject` замість Vuex?",
        "answer": "`provide` / `inject` підходить для передачі невеликих порцій даних або сервісів через декілька рівнів вкладеності, коли централізоване сховище (як Vuex) є надмірним. Vuex краще підходить для глобального, передбачуваного та відстежуваного управління станом великих додатків."
      }
    ]
  },
  {
    "id": "vue-q15",
    "topic": "Vue",
    "mainQuestion": "Як тестувати Vue.js-додатки? Які інструменти використовуються?",
    "mainAnswer": "Для тестування Vue.js-додатків використовуються юніт-тести, інтеграційні тести та наскрізні (E2E) тести. Для юніт- та інтеграційних тестів зазвичай застосовують **Vue Test Utils** (офіційна бібліотека для тестування компонентів Vue) у поєднанні з тест-раннерами, такими як **Vitest** (рекомендовано для Vue 3) або **Jest**. Для E2E-тестів популярні **Cypress** або **Playwright**.",
    "additionalQuestions": [
      {
        "id": "vue-q15-aq1",
        "question": "У чому полягає перевага використання Vue Test Utils?",
        "answer": "Vue Test Utils надає утиліти та методи для легкого монтування та взаємодії з Vue-компонентами в ізольованому середовищі. Це дозволяє легко перевіряти вивід компонента, імітувати події, перевіряти props та стан, не потребуючи повного DOM-оточення."
      },
      {
        "id": "vue-q15-aq2",
        "question": "Наведіть приклад простого юніт-тесту компонента Vue.",
        "answer": "```javascript\nimport { shallowMount } from '@vue/test-utils';\nimport MyComponent from './MyComponent.vue';\n\ndescribe('MyComponent', () => {\n  it('renders a message', () => {\n    const wrapper = shallowMount(MyComponent, {\n      props: { msg: 'Hello Vue' }\n    });\n    expect(wrapper.find('h1').text()).toBe('Hello Vue');\n  });\n});\n```"
      },
      {
        "id": "vue-q15-aq3",
        "question": "Коли варто використовувати 'shallow mounting' (поверхневе монтування) при тестуванні?",
        "answer": "'Shallow mounting' використовується, коли потрібно протестувати компонент ізольовано, не рендерячи його дочірні компоненти повністю. Це дозволяє зосередитися на логіці батьківського компонента, запобігаючи непередбачуваним помилкам від дочірніх компонентів та прискорюючи виконання тестів."
      }
    ]
  }
]
